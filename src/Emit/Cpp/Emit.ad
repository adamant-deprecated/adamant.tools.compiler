public let TypeDeclarations: mut Source_File_Builder = new Source_File_Builder();
public let FunctionDeclarations: mut Source_File_Builder = new Source_File_Builder();
public let ClassDeclarations: mut Source_File_Builder= new Source_File_Builder();
public let GlobalDefinitions: mut Source_File_Builder = new Source_File_Builder();
public let Definitions: mut Source_File_Builder = new Source_File_Builder();

public var MainFunctionReturnType: string = "";
public var MainFunctionAcceptsConsole: bool = false;
public var MainFunctionAcceptsArgs: bool = false;

// ----------------------------------------------------------------------------
// Emitting C++
// ----------------------------------------------------------------------------

public IsValueType(type: Syntax_Node) -> bool
{
	// Here we assume that they follow convention and value types start lowercase
	if type.Type == PredefinedType
	{
		return true;
	}
	if type.Type == NullableType
	{
		// The first child is the basic type
		return IsValueType(type.Children[0]); // The type that is nullable
	}
	if type.Type == QualifiedName
	{
		// The last child is the real type
		return IsValueType(type.Children[|type.Children| - 1]);
	}
	if type.Type == GenericName
	{
		let firstChar: code_point = type.FirstChildOfType(IdentifierName).FirstChildOfType(Identifier).GetText()[0];
		return firstChar >= 'a' and firstChar <= 'z';
	}
	if type.Type == IdentifierName
	{
		let firstChar: code_point = type.FirstChildOfType(Identifier).GetText()[0];
		return firstChar >= 'a' and firstChar <= 'z';
	}
	if type.Type == MutableType
	{
		return IsValueType(type.Children[1]); // The type that is mutable
	}

	// TODO Error
	return true; // The value true is more likely to cause some kind of compiler error in the emitted source that we will notice
}

// Converts a type to C++
public ConvertType(type: Syntax_Node) -> string
{
	if type.Type == PredefinedType
	{
		let keyword: Syntax_Node = type.Children[0];
		// void we still use the C++ keyword
		if keyword.Type == Void
			{ return keyword.GetText(); }
		// int, bool, string, code_point, uint
		return "p_" + keyword.GetText();
	}

	if type.Type == IdentifierName
	{
		return "::" + type.GetText() + "_";
	}
	if type.Type == QualifiedName
	{
		return ConvertType(type.Children[0]) + ConvertType(type.Children[2]);
	}
	if type.Type == GenericName
	{
		return ConvertType(type.Children[0]) + "<" + ConvertType(true, type.Children[2]) + ">";
	}

	return FormatError("Unexpected Token of type "+type.Type+" found in CovertType(), `"+type.GetText()+"`");
}

// Converts a type to C++
public ConvertType(mutableBinding: bool, var type: Syntax_Node) -> string
{
	let nullable: bool = type.Type == NullableType;
	if nullable
	{
		type = type.Children[0]; // Remove the nullable wrapper
	}

	let mutableValue: bool = type.Type == MutableType;
	if mutableValue
	{
		type = type.Children[1]; // Remove the mutable wrapper
	}

	let isValueType: bool = IsValueType(type);
	var cppType: string = ConvertType(type);

	if isValueType
	{
		if nullable
			{ cppType = "p_maybe<" + cppType + ">"; }
		if not mutableBinding and not mutableValue
			{ cppType = cppType + " const"; }
	}
	else
	{
		if not mutableValue { cppType = cppType + " const"; }
		cppType = cppType + " *";
		//if nullable
		//	{ cppType = "p_maybe<" + cppType + ">"; }
		if not mutableBinding { cppType = cppType + "const" ; }
	}

	return cppType;
}

public ConvertParameterList(parameterList: Syntax_Node, isMainFunction: bool) -> string
{
	let builder: mut System.Text.String_Builder = new System.Text.String_Builder();
	builder.Append("(");
	var firstParameter: bool = true;
	for let parameter: Syntax_Node in parameterList.Children
	{
		if parameter.Type == Parameter
		{
			if not firstParameter
				{ builder.Append(", "); }
			else
				{ firstParameter = false; }

			let mutableBinding: bool = parameter.HasChildOfType(VarKeyword);
			let type: Syntax_Node = parameter.Children[|parameter.Children| - 1];
			builder.Append(ConvertType(mutableBinding, type));
			builder.Append(" ");
			builder.Append(parameter.FirstChildOfType(Identifier).GetText());
			builder.Append("_");

			if isMainFunction
			{
				var typeString: string;
				if type.Type == MutableType
					{ typeString = type.Children[1].GetText(); }
				else
					{ typeString = type.GetText(); }
				if typeString == "System.Console.Console"
					{ MainFunctionAcceptsConsole = true; }
				if typeString == "System.Console.Arguments"
					{ MainFunctionAcceptsArgs = true; }
			}
		}
	}
	builder.Append(")");
	return builder.ToString();
}

public ConvertParameterList(parameterList: Syntax_Node) -> string
{
	return ConvertParameterList(parameterList, false);
}

public ConvertExpression(syntax: Syntax_Node, builder: mut Source_File_Builder) -> void
{
	if syntax.Type == NewExpression
	{
		let type: Syntax_Node = syntax.Children[1];
		if not IsValueType(type) // place value types on the stack in C++ by not using new
			{ builder.Write("new "); }
		builder.Write(ConvertType(type));
		let argumentList: Syntax_Node = syntax.Children[2];
		ConvertExpression(argumentList, builder);
	}
	else if syntax.Type == ArgumentList
	{
		builder.Write("(");
		var firstExpression: bool = true;
		for let arg: Syntax_Node in syntax.Children
		{
			if arg.Type <> LeftParen
				and arg.Type <> RightParen
				and arg.Type <> Comma
			{
				if firstExpression
					{ firstExpression = false; }
				else
					{ builder.Write(", "); }
				ConvertExpression(arg, builder);
			}
		}
		builder.Write(")");
	}
	else if syntax.Type == NotExpression
	{
		ConvertExpression(syntax.Children[1], builder);
		builder.Write("->op_Not()");
	}
	else if syntax.Type == MagnitudeExpression
	{
		ConvertExpression(syntax.Children[1], builder);
		builder.Write("->op_Magnitude()");
	}
	else if syntax.Type == ParenthesizedExpression
	{
		ConvertExpression(syntax.Children[1], builder);
	}
	else if syntax.Type == NegateExpression
	{
		ConvertExpression(syntax.Children[1], builder);
		builder.Write("->op_Negate()");
	}
	else if syntax.Type == NullLiteralExpression
	{
		builder.Write("::None");
	}
	else if syntax.Type == SelfExpression
	{
		builder.Write("this");
	}
	else if syntax.Type == NumericLiteralExpression
	{
		builder.Write("p_int(" + syntax.GetText() + ")");
	}
	else if syntax.Type == TrueLiteralExpression
		or syntax.Type == FalseLiteralExpression
	{
		builder.Write("p_bool(" + syntax.GetText() + ")");
	}
	else if syntax.Type == CodePointLiteralExpression
	{
		builder.Write("p_code_point(" + syntax.GetText() + ")");
	}
	else if syntax.Type == IdentifierName
	{
		builder.Write(syntax.GetText() + "_");
	}
	else if syntax.Type == StringLiteralExpression
	{
		builder.Write("p_string(" + syntax.GetText() + ")");
	}
	else if syntax.Type == AssignmentExpression
	{
		let operator: int = syntax.Children[1].Type;
		if operator == Equals
		{
			ConvertExpression(syntax.Children[0], builder);
			builder.Write(" ");
			builder.Write(syntax.Children[1].GetText());
			builder.Write(" ");
			ConvertExpression(syntax.Children[2], builder);
		}
		else
		{
			ConvertExpression(syntax.Children[0], builder);
			builder.Write("->op_");
			if operator == PlusEquals
			{
				builder.Write("AddAssign");
			}
			else if operator == MinusEquals
			{
				builder.Write("SubtractAssign");
			}
			else
			{
				builder.Error("Unsupported assignment operator " + operator);
			}
			builder.Write("(");
			ConvertExpression(syntax.Children[2], builder);
			builder.Write(")");
		}
	}
	else if syntax.Type == EqualExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Equal(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == NotEqualExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_NotEqual(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == ComparisionExpression
	{
		let operator: int = syntax.Children[1].Type;
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_");
		if operator == LessThan
		{
			builder.Write("LessThan");
		}
		else if operator == LessThanEquals
		{
			builder.Write("LessThanOrEqual");
		}
		else if operator == GreaterThan
		{
			builder.Write("GreaterThan");
		}
		else if operator == GreaterThanEquals
		{
			builder.Write("GreaterThanOrEqual");
		}
		else
		{
			builder.Error("Unsupported comparision operator " + operator);
		}
		builder.Write("(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == AddExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Add(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == SubtractExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Subtract(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == MultiplyExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Multiply(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == DivideExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Divide(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == RemainderExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Remainder(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else if syntax.Type == OrExpression
	{
		// TODO based on types decide how to translate
		builder.Write("LogicalOr(");
		ConvertExpression(syntax.Children[0], builder);
		builder.Write(", [&] { return ");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write("; })");
	}
	else if syntax.Type == AndExpression
	{
		// TODO based on types decide how to translate
		builder.Write("LogicalAnd(");
		ConvertExpression(syntax.Children[0], builder);
		builder.Write(", [&] { return ");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write("; })");
	}
	else if syntax.Type == InvocationExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		ConvertExpression(syntax.Children[1], builder);
	}
	else if syntax.Type == MemberAccessExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->");
		ConvertExpression(syntax.Children[2], builder);
	}
	else if syntax.Type == ElementAccessExpression
	{
		ConvertExpression(syntax.Children[0], builder);
		builder.Write("->op_Element(");
		ConvertExpression(syntax.Children[2], builder);
		builder.Write(")");
	}
	else
	{
		builder.Error("Could not convert expression of type " + syntax.Type);
	}
}

public EmitStatement(statement: Syntax_Node) -> void
{
	Definitions.StatementSeparatorLine();

	if statement.Type == ReturnStatement
	{

		if |statement.Children| == 2
			{ Definitions.WriteLine("return;"); }
		else
		{
			Definitions.BeginLine("return ");
			ConvertExpression(statement.Children[1], Definitions);
			Definitions.EndLine(";");
		}
	}
	else if statement.Type == LoopStatement
	{
		Definitions.WriteLine("for (;;)");
		EmitStatement(statement.Children[1]); // Block Statement
	}
	else if statement.Type == Block
	{
		Definitions.BeginBlock();
		for let blockStatement: Syntax_Node in statement.Children
		{
			if blockStatement.Type <> LeftBrace and blockStatement.Type <> RightBrace
			{
				EmitStatement(blockStatement);
			}
		}
		Definitions.EndBlock();
	}
	else if statement.Type == WhileStatement
	{
		Definitions.BeginLine("while (");
		ConvertExpression(statement.Children[1], Definitions);
		Definitions.EndLine(".Value)"); // if the type isn't just bool, we need op_true() etc.
		EmitStatement(statement.Children[2]); // Block Statement
	}
	else if statement.Type == ForStatement
	{
		Definitions.BeginLine("for (");
		//let k: string = Token.GetText();
		//if not Accept("let") and not Accept("var")
		//	{ Definitions.Error("Expected `let` or `var` but found `" + Token.GetText() + "`"); }
		let variableDeclaration: Syntax_Node = statement.Children[1];
		let mutableBinding: bool = variableDeclaration.HasChildOfType(VarKeyword);
		let name: string = variableDeclaration.FirstChildOfType(Identifier).GetText();
		let type: Syntax_Node = variableDeclaration.Children[3];
		Definitions.Write(ConvertType(mutableBinding, type) + " " + name + "_");
		Definitions.Write(" : *(");
		ConvertExpression(statement.Children[3], Definitions); // expression
		Definitions.EndLine("))");
		EmitStatement(statement.Children[4]); // Block Statement
	}
	else if statement.Type == DoWhileStatement
	{
		Definitions.WriteLine("do");
		EmitStatement(statement.Children[1]); // Block Statement
		Definitions.BeginLine("while (");
		ConvertExpression(statement.Children[3], Definitions);
		Definitions.EndLine(".Value);"); // if the type isn't just bool, we need op_true() etc.
	}
	else if statement.Type == IfStatement
	{
		var ifStatement: Syntax_Node? = statement;
		Definitions.BeginLine("");
		loop
		{
			Definitions.Write("if (");
			ConvertExpression(ifStatement.Children[1], Definitions);
			Definitions.EndLine(".Value)"); // if the type isn't just bool, we need op_true() etc.
			EmitStatement(ifStatement.Children[2]); // Block Statement
			let elseClause: Syntax_Node? = ifStatement.FirstChildOfType(ElseClause);
			if elseClause <> null
			{
				ifStatement = elseClause.FirstChildOfType(IfStatement);
				if ifStatement <> null
				{
					Definitions.BeginLine("else ");
				}
				else
				{
					Definitions.WriteLine("else");
					EmitStatement(elseClause.Children[1]); // Block Statement
					break;
				}
			}
			else
				{ break; }
		}
	}
	else if statement.Type == BreakStatement
	{
		Definitions.WriteLine("break;");
	}
	else if statement.Type == ContinueStatement
	{
		Definitions.WriteLine("continue;");
	}
	else if statement.Type == LocalDeclarationStatement
	{
		let variableDeclaration: Syntax_Node = statement.Children[0];
		let variableName: string = variableDeclaration.FirstChildOfType(Identifier).GetText();
		let variableType: Syntax_Node = variableDeclaration.Children[3];
		let mutableBinding: bool = variableDeclaration.HasChildOfType(VarKeyword);
		Definitions.BeginLine(ConvertType(mutableBinding, variableType));
		Definitions.Write(" " + variableName + "_");
		if variableDeclaration.HasChildOfType(Equals)
		{
			Definitions.Write(" = ");
			ConvertExpression(variableDeclaration.Children[5], Definitions);
		}
		Definitions.EndLine(";");
	}
	else if statement.Type == ExpressionStatement
	{
		Definitions.BeginLine("");
		ConvertExpression(statement.Children[0], Definitions);
		Definitions.EndLine(";");
	}
	else
	{
		Definitions.Error("Could not emit statement of type " + statement.Type);
	}
}

public EmitClassMember(member: Syntax_Node, className: string) -> void
{
	if member.Type == ConstructorDeclaration
	{
		let parameters: string = ConvertParameterList(member.Children[2]);
		// Write out the function declaration for C++ so we can call functions defined after others
		ClassDeclarations.WriteLine(className + "_" + parameters + ";");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("::" + className + "_::" + className + "_" + parameters + "");
		EmitStatement(member.Children[3]);
	}
	else if member.Type == FieldDeclaration
	{
		let variableDeclaration: Syntax_Node = member.Children[1];
		let fieldName: string = variableDeclaration.Children[1].GetText();
		let fieldType: Syntax_Node = variableDeclaration.Children[3];
		let cppType: string = ConvertType(true, fieldType); // because we need to assign them in constructors don't mark fields const
		ClassDeclarations.WriteLine(cppType + " " + fieldName + "_;");
	}
	else if member.Type == MethodDeclaration
	{
		let methodName: string = member.Children[1].GetText();
		let parameterList: Syntax_Node = member.Children[2];
		let parameters: string = ConvertParameterList(parameterList);
		let selfParameter: Syntax_Node? = parameterList.FirstChildOfType(SelfParameter);
		let isAssociatedFuntion: bool = selfParameter == null;
		let mutableSelf: bool = not isAssociatedFuntion and selfParameter.HasChildOfType(MutableKeyword);
		let returnType: Syntax_Node = member.Children[4];
		let cppType: string = ConvertType(true, returnType);
		var staticModifier: string = "";
		if isAssociatedFuntion
			{ staticModifier = "static "; }
		var constModifier: string = "";
		if not mutableSelf and not isAssociatedFuntion
			{ constModifier = "const "; }
		ClassDeclarations.WriteLine(staticModifier + "auto " + methodName + "_" + parameters + " " + constModifier + "-> " + cppType + ";");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("auto ::" + className + "_::" + methodName + "_" + parameters + " " + constModifier + "-> " + cppType);
		let block: Syntax_Node = member.Children[5];
		EmitStatement(block);
	}
	else
	{
		Definitions.Error("Could not emit member of type " + member.Type);
	}
}

public EmitDeclaration(declaration: Syntax_Node) -> void
{
	if declaration.Type == GlobalDeclaration
	{
		let variableDeclaration: Syntax_Node = declaration.Children[1];
		let variableName: string = variableDeclaration.Children[1].GetText();
		let variableType: Syntax_Node = variableDeclaration.Children[3];
		let mutableBinding: bool = variableDeclaration.HasChildOfType(VarKeyword);
		let cppType: string = ConvertType(mutableBinding, variableType);
		GlobalDefinitions.BeginLine(cppType);
		GlobalDefinitions.Write(" " + variableName + "_ = ");
		let expression: Syntax_Node = variableDeclaration.Children[5];
		ConvertExpression(expression, GlobalDefinitions);
		GlobalDefinitions.EndLine(";");
	}
	else if declaration.Type == ClassDeclaration
	{
		let className: string = declaration.Children[2].GetText();
		TypeDeclarations.WriteLine("class " + className + "_;");
		ClassDeclarations.ElementSeparatorLine();
		ClassDeclarations.WriteLine("class " + className + "_");
		ClassDeclarations.BeginBlock();
		ClassDeclarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
		// Write out basic reference equality comparisions
		ClassDeclarations.WriteLine("p_bool op_Equal(" + className + "_ const * other) const { return this == other; }");
		ClassDeclarations.WriteLine("p_bool op_NotEqual(" + className + "_ const * other) const { return this != other; }");
		for let member: Syntax_Node in declaration.Children
		{
			// TODO fix this to a more reliable means of telling what should be emitted
			if member.Type == ConstructorDeclaration
				or member.Type == FieldDeclaration
				or member.Type == MethodDeclaration
			{
				EmitClassMember(member, className);
			}
		}
		ClassDeclarations.EndBlockWithSemicolon();
	}
	else if declaration.Type == EnumDeclaration
	{
		let enumName: string = declaration.Children[3].GetText();
		TypeDeclarations.WriteLine("enum class " + enumName + "_;");
		ClassDeclarations.ElementSeparatorLine();
		ClassDeclarations.WriteLine("enum class " + enumName + "_");
		ClassDeclarations.BeginBlock();
		for let member: Syntax_Node in declaration.Children
		{
			if member.Type == EnumMemberDeclaration
			{
				let memberName: string = member.Children[0].GetText();
				ClassDeclarations.BeginLine(memberName + "_");
				let memberValue: Syntax_Node? = member.FirstChildOfType(Number);
				if memberValue <> null
				{
					ClassDeclarations.Write(" = ");
					ClassDeclarations.Write(memberValue.GetText());
				}
				ClassDeclarations.EndLine(",");
			}
		}
		ClassDeclarations.EndBlockWithSemicolon();
	}
	else if declaration.Type == FunctionDeclaration
	{
		let name: string = declaration.Children[1].GetText();
		let isMain: bool = name == "Main";
		let parameters: string = ConvertParameterList(declaration.Children[2], isMain);
		let returnType: Syntax_Node = declaration.Children[4];
		let cppType: string = ConvertType(true, returnType);
		// Write out the function declaration for C++ so we can call functions defined after others
		FunctionDeclarations.WriteLine("auto " + name + "_" + parameters + " -> " + cppType + ";");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("auto " + name + "_" + parameters + " -> " + cppType);
		if isMain
		{
			if MainFunctionReturnType <> ""
				{ Definitions.Error("Multiple declarations of main"); }
			MainFunctionReturnType = cppType;
		}
		EmitStatement(declaration.Children[5]);
	}
	else
	{
		Definitions.Error("Could not emit declaration of type " + declaration.Type);
	}
}

public EmitCompilationUnit(unit: Syntax_Node) -> void
{
	for let declaration: Syntax_Node in unit.Children
	{
		EmitDeclaration(declaration);
	}
}

public EmitPackage(package: Syntax_Node) -> void
{
	for let compilationUnit: Syntax_Node in package.Children
	{
		EmitCompilationUnit(compilationUnit);
	}
}

public EmitPreamble() -> void
{
	// Setup the beginning of each section
	TypeDeclarations.WriteLine("#include \"RuntimeLibrary.h\"");
	TypeDeclarations.BlankLine();
	TypeDeclarations.WriteLine("// Type Declarations");
	FunctionDeclarations.BlankLine();
	FunctionDeclarations.WriteLine("// Function Declarations");
	ClassDeclarations.BlankLine();
	ClassDeclarations.WriteLine("// Class Declarations");
	GlobalDefinitions.BlankLine();
	GlobalDefinitions.WriteLine("// Global Definitions");
	Definitions.BlankLine();
	Definitions.WriteLine("// Definitions");
}

public EmitEntryPointAdapter(resources: System.Collections.List<Source_Text>) -> void
{
	Definitions.ElementSeparatorLine();
	Definitions.WriteLine("// Entry Point Adapter");
	Definitions.WriteLine("std::int32_t main(int argc, char const *const * argv)");
	Definitions.BeginBlock();

	for let resource: Source_Text in resources
	{
		Definitions.BeginLine("resource_manager_->AddResource(p_string(\"");
		Definitions.Write(resource.Name);
		Definitions.Write("\"), p_string(\"");
		Definitions.Write(resource.Text
								.Replace("\\", "\\\\")
								.Replace("\n", "\\n")
								.Replace("\r", "\\r")
								.Replace("\"", "\\\""));
		Definitions.EndLine("\"));");
	}
	if |resources| > 0
	{
		Definitions.EndLine(""); // Use EndLine to avoid having an indent on a blank line
	}

	// TODO should be `new mut`
	let args: mut System.Text.String_Builder = new System.Text.String_Builder();
	if MainFunctionAcceptsConsole
		{ args.Append("new ::System_::Console_::Console_()"); }
	if MainFunctionAcceptsArgs
	{
		if MainFunctionAcceptsConsole
			{ args.Append(", "); }
		args.Append("new ::System_::Console_::Arguments_(argc, argv)");
	}

	if MainFunctionReturnType == "void"
	{
		Definitions.WriteLine("Main_(" + args.ToString() + ");");
		Definitions.WriteLine("return 0;");
	}
	else
	{
		Definitions.WriteLine("return Main_(" + args.ToString() + ").Value;");
	}

	Definitions.EndBlock();
}
