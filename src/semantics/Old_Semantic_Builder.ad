/// Builds the semantic tree (`Old_Semantic_Node`s) including creating `Old_Symbol`s and declared `Type`s
public class Old_Semantic_Builder
{
	// Takes a package and builds the symbols for it
	public build_symbols(self, package_name: Package_Name, compilation_units: System.Collections.List<mut Old_Semantic_Node>) -> Old_Symbol
	{
		// TODO the package symbol name should match the package name
		let children: mut System.Collections.List<Old_Symbol> = new System.Collections.List<Old_Symbol>();
		let package_symbol: mut Old_Symbol = new Old_Symbol.package(package_name.unqualified, children);
		for let compilation_unit: mut Old_Semantic_Node in compilation_units
		{
			if compilation_unit.kind =/= CompilationUnit
				{ THROW_EXCEPTION("`Semantic_Builder.build_symbols(...)` called with node of type " + compilation_unit.kind); }

			build_symbols(package_symbol, compilation_unit);
		}

		return package_symbol;
	}

	// Because a single call could produce multiple symbols, we pass the symbol collection in and add symbols to it.
	// Once we have generators, this would be a good place to use them.
	private build_symbols(self, parent: Old_Symbol, node: mut Old_Semantic_Node) -> void
	{
		if node.kind == CompilationUnit
		{
			for let declaration: mut Old_Semantic_Node in node.children
			{
				build_symbols(parent, declaration);
			}
		}
		else if node.kind == FunctionDeclaration
			or node.kind == MethodDeclaration
		{
			let name: string = node.first_child(Identifier).get_text();
			let symbol: Old_Symbol = new Old_Symbol.identifier(name);
			build_function_symbols(parent, node, symbol);
		}
		else if node.kind == ClassDeclaration
			or node.kind == StructDeclaration
		{
			let name: string = node.first_child(Identifier).get_text();
			var type_kind: int;
			if node.kind == ClassDeclaration
				{ type_kind = ReferenceType; }
			else
				{ type_kind = ValueType; }
			let type: Type = new Type(type_kind, new Name(new Name.global_namespace(new Package_Name("default")), TypeName, name), true);
			let declarations: mut System.Collections.List<Old_Semantic_Node> = new System.Collections.List<Old_Semantic_Node>();
			declarations.add(node);
			let children: mut System.Collections.List<Old_Symbol> = new System.Collections.List<Old_Symbol>();
			let symbol: Old_Symbol = new Old_Symbol.declaring(type, declarations, children);

			for let member: mut Old_Semantic_Node in node.members()
			{
				build_symbols(symbol, member);
			}

			parent.children.Add(symbol);
			node.bind_symbol(symbol);
		}
		else if node.kind == ConstructorDeclaration
		{
			var full_name: string = "new";
			let constructor_name: Old_Semantic_Node? = node.first_child(Identifier);
			if constructor_name =/= none
				{ full_name = "new_" + constructor_name.get_text(); }
			let constructor_symbol: Old_Symbol = new Old_Symbol.special(full_name);
			constructor_symbol.declarations.Add(node);
			parent.children.Add(constructor_symbol);
			// Implicit `self` parameter
			let self_symbol: Old_Symbol = new Old_Symbol.special("self");
			// let type: Type = parent.get_type();
			// assert(type =/= none);
			// let declaration: Old_Semantic_Node = parent.declarations[0];
			// assert(declaration =/= none and (declaration.kind == ClassDeclaration or declaration.kind == StructDeclaration));
			// self_symbol.declarations.Add(declaration); // We reference our containing class/struct
			constructor_symbol.children.Add(self_symbol);
			build_function_symbols(parent, node, constructor_symbol);
		}
		else if node.kind == FieldDeclaration
		{
			let name: string = node.first_child(VariableDeclaration).first_child(Identifier).get_text();
			let field_symbol: Old_Symbol = new Old_Symbol.identifier(name);
			field_symbol.declarations.Add(node);
			parent.children.Add(field_symbol);
			node.bind_symbol(field_symbol);
		}
		else if node.kind == EnumDeclaration
		{
			let name: string = node.first_child(Identifier).get_text();
			let enum_symbol: Old_Symbol = new Old_Symbol.identifier(name);
			enum_symbol.declarations.Add(node);
			// TODO Add enum member symbols
			parent.children.Add(enum_symbol);
			node.bind_symbol(enum_symbol);
		}
		else if node.kind == GlobalDeclaration
		{
			let name: string = node.first_child(VariableDeclaration).first_child(Identifier).get_text();
			let global_declaration_symbol: Old_Symbol = new Old_Symbol.identifier(name);
			global_declaration_symbol.declarations.Add(node);
			parent.children.Add(global_declaration_symbol);
			node.bind_symbol(global_declaration_symbol);
		}
		else if node.kind == Block
		{
			for let statement: mut Old_Semantic_Node in node.statements()
			{
				build_symbols(parent, statement);
			}
		}
		else if node.kind == LoopStatement
			or node.kind == WhileStatement
			or node.kind == DoWhileStatement
		{
			build_symbols(parent, node.first_child(Block));
		}
		else if node.kind == ForStatement
		{
			let name: string = node.first_child(VariableDeclaration).first_child(Identifier).get_text();
			let for_symbol: Old_Symbol = new Old_Symbol.identifier(name);
			for_symbol.declarations.Add(node);
			parent.children.Add(for_symbol);
			node.bind_symbol(for_symbol);
			build_symbols(parent, node.first_child(Block));
		}
		else if node.kind == LocalDeclarationStatement
		{
			let identifier: mut Old_Semantic_Node = node.first_child(VariableDeclaration).first_child(Identifier);
			let declarations: mut System.Collections.List<Old_Semantic_Node> = new System.Collections.List<Old_Semantic_Node>();
			declarations.add(node);
			let symbol: Old_Symbol = new Old_Symbol.identifier(identifier.get_text(), declarations);
			identifier.bind_symbol(symbol);
			parent.children.Add(symbol);
		}
		else if node.kind == IfStatement
		{
			build_symbols(parent, node.first_child(Block));
			let else_clause: mut Old_Semantic_Node? = node.first_child(ElseClause);
			if else_clause =/= none
			{
				build_symbols(parent, else_clause);
			}
		}
		else if node.kind == ElseClause
		{
			// This might be a good place for some kind of coalesce operator
			let block: mut Old_Semantic_Node? = node.first_child(Block);
			if block =/= none
			{
				build_symbols(parent, block);
			}
			else
			{
				build_symbols(parent, node.first_child(IfStatement));
			}
		}
		else if node.kind == Parameter
		{
			let name: string = node.first_child(Identifier).get_text();
			let symbol: Old_Symbol = new Old_Symbol.identifier(name);
			symbol.declarations.Add(node);
			parent.children.Add(symbol);
		}
		else if node.kind == SelfParameter
		{
			let symbol: Old_Symbol = new Old_Symbol.special("self");
			symbol.declarations.Add(node);
			parent.children.Add(symbol);
		}
		else if node.kind == ExpressionStatement
			or node.kind == ReturnStatement
			or node.kind == BreakStatement
			or node.kind == ContinueStatement
			or node.kind == EndOfFileToken
		{
			// Ignore these nodes
		}
		else
		{
			THROW_EXCEPTION("`Semantic_Builder.Build()` unimplemented node type " + node.kind);
		}
	}

	private build_function_symbols(self, parent: Old_Symbol, function: mut Old_Semantic_Node, symbol: Old_Symbol) -> void
	{
		symbol.declarations.Add(function);

		let parameters: mut Old_Semantic_Node = function.first_child(ParameterList);
		for let parameter: mut Old_Semantic_Node in parameters.parameters()
		{
			build_symbols(symbol, parameter);
		}

		let body: mut Old_Semantic_Node = function.first_child(Block);
		build_symbols(symbol, body);

		parent.children.Add(symbol);
		function.bind_symbol(symbol);
	}
}
