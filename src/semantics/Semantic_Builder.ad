/// Builds the semantic tree (`Semantic_Node`s) including creating `Symbol`s and declared `Type`s
public class Semantic_Builder
{
	// Takes a package and builds the symbols for it
	public build_symbols(self, compilation_units: System.Collections.List<mut Semantic_Node>) -> Symbol
	{
		// TODO eventually the package symbol should have a name so that we can look up names in front of the package qualifier
		let package_symbol: mut Symbol = new Symbol("default", PackageSymbol);
		for let compilation_unit: mut Semantic_Node in compilation_units
		{
			if compilation_unit.kind =/= CompilationUnit
				{ THROW_EXCEPTION("`Semantic_Builder.build_symbols(...)` called with node of type " + compilation_unit.kind); }

			build_symbols(package_symbol, compilation_unit);
		}

		build_runtime_library_symbols(package_symbol);

		return package_symbol;
	}

	// Because a single call could produce multiple symbols, we pass the symbol collection in and add symbols to it.
	// Once we have generators, this would be a good place to use them.
	private build_symbols(self, parent: Symbol, node: mut Semantic_Node) -> void
	{
		if node.kind == CompilationUnit
		{
			for let declaration: mut Semantic_Node in node.children
			{
				build_symbols(parent, declaration);
			}
		}
		else if node.kind == FunctionDeclaration
			or node.kind == MethodDeclaration
		{
			let name: string = node.first_child(Identifier).get_text();
			let symbol: Symbol = new Symbol(name);
			build_function_symbols(parent, node, symbol);
		}
		else if node.kind == ClassDeclaration
			or node.kind == StructDeclaration
		{
			let name: string = node.first_child(Identifier).get_text();
			let symbol: Symbol = new Symbol(name);
			symbol.declarations.Add(node);
			for let member: mut Semantic_Node in node.members()
			{
				build_symbols(symbol, member);
			}

			parent.children.Add(symbol);
			node.bind_symbol(symbol);
		}
		else if node.kind == ConstructorDeclaration
		{
			var full_name: string = "new";
			let constructor_name: Semantic_Node? = node.first_child(Identifier);
			if constructor_name =/= none
				{ full_name = "new_" + constructor_name.get_text(); }
			let constructor_symbol: Symbol = new Symbol(full_name, SpecialSymbol);
			constructor_symbol.declarations.Add(node);
			parent.children.Add(constructor_symbol);
			// Implicit `self` parameter
			let self_symbol: Symbol = new Symbol("self", SpecialSymbol);
			// let type: Type = parent.get_type();
			// assert(type =/= none);
			// let declaration: Semantic_Node = parent.declarations[0];
			// assert(declaration =/= none and (declaration.kind == ClassDeclaration or declaration.kind == StructDeclaration));
			// self_symbol.declarations.Add(declaration); // We reference our containing class/struct
			constructor_symbol.children.Add(self_symbol);
			build_function_symbols(parent, node, constructor_symbol);
		}
		else if node.kind == FieldDeclaration
		{
			let name: string = node.first_child(VariableDeclaration).first_child(Identifier).get_text();
			let field_symbol: Symbol = new Symbol(name);
			field_symbol.declarations.Add(node);
			parent.children.Add(field_symbol);
			node.bind_symbol(field_symbol);
		}
		else if node.kind == EnumDeclaration
		{
			let name: string = node.first_child(Identifier).get_text();
			let enum_symbol: Symbol = new Symbol(name);
			enum_symbol.declarations.Add(node);
			// TODO Add enum member symbols
			parent.children.Add(enum_symbol);
			node.bind_symbol(enum_symbol);
		}
		else if node.kind == GlobalDeclaration
		{
			let name: string = node.first_child(VariableDeclaration).first_child(Identifier).get_text();
			let global_declaration_symbol: Symbol = new Symbol(name);
			global_declaration_symbol.declarations.Add(node);
			parent.children.Add(global_declaration_symbol);
			node.bind_symbol(global_declaration_symbol);
		}
		else if node.kind == Block
		{
			for let statement: mut Semantic_Node in node.statements()
			{
				build_symbols(parent, statement);
			}
		}
		else if node.kind == LoopStatement
			or node.kind == WhileStatement
			or node.kind == DoWhileStatement
		{
			build_symbols(parent, node.first_child(Block));
		}
		else if node.kind == ForStatement
		{
			let name: string = node.first_child(VariableDeclaration).first_child(Identifier).get_text();
			let for_symbol: Symbol = new Symbol(name);
			for_symbol.declarations.Add(node);
			parent.children.Add(for_symbol);
			node.bind_symbol(for_symbol);
			build_symbols(parent, node.first_child(Block));
		}
		else if node.kind == LocalDeclarationStatement
		{
			let identifier: mut Semantic_Node = node.first_child(VariableDeclaration).first_child(Identifier);
			let symbol: Symbol = new Symbol(identifier.get_text());
			symbol.declarations.Add(node);
			identifier.bind_symbol(symbol);
			parent.children.Add(symbol);
		}
		else if node.kind == IfStatement
		{
			build_symbols(parent, node.first_child(Block));
			let else_clause: mut Semantic_Node? = node.first_child(ElseClause);
			if else_clause =/= none
			{
				build_symbols(parent, else_clause);
			}
		}
		else if node.kind == ElseClause
		{
			// This might be a good place for some kind of coalesce operator
			let block: mut Semantic_Node? = node.first_child(Block);
			if block =/= none
			{
				build_symbols(parent, block);
			}
			else
			{
				build_symbols(parent, node.first_child(IfStatement));
			}
		}
		else if node.kind == Parameter
		{
			let name: string = node.first_child(Identifier).get_text();
			let symbol: Symbol = new Symbol(name);
			symbol.declarations.Add(node);
			parent.children.Add(symbol);
		}
		else if node.kind == SelfParameter
		{
			let symbol: Symbol = new Symbol("self", SpecialSymbol);
			symbol.declarations.Add(node);
			parent.children.Add(symbol);
		}
		else if node.kind == ExpressionStatement
			or node.kind == ReturnStatement
			or node.kind == BreakStatement
			or node.kind == ContinueStatement
			or node.kind == EndOfFileToken
		{
			// Ignore these nodes
		}
		else
		{
			THROW_EXCEPTION("`Semantic_Builder.Build()` unimplemented node type " + node.kind);
		}
	}

	private build_function_symbols(self, parent: Symbol, function: mut Semantic_Node, symbol: Symbol) -> void
	{
		symbol.declarations.Add(function);

		let parameters: mut Semantic_Node = function.first_child(ParameterList);
		for let parameter: mut Semantic_Node in parameters.parameters()
		{
			build_symbols(symbol, parameter);
		}

		let body: mut Semantic_Node = function.first_child(Block);
		build_symbols(symbol, body);

		parent.children.Add(symbol);
		function.bind_symbol(symbol);
	}

	/// This builds up a set of symbols that are actually in the Runtime Library
	/// as if they were part of the current package.
	///
	/// TODO this should actually be a separate package
	private build_runtime_library_symbols(self, package: Symbol) -> void
	{
		build_resource_manager(package);

		build_function(package, "THROW_EXCEPTION");
		build_function(package, "NOT_IMPLEMENTED");
		build_function(package, "UNREACHABLE");
		build_function(package, "assert");

		let system: mut Symbol = build(package, "System", NamespaceDeclaration);

		let collections: mut Symbol = build(system, "Collections", NamespaceDeclaration);
		build(collections, "List", ClassDeclaration);

		let console: Symbol = build(system, "Console", NamespaceDeclaration);
		build(console, "Console", ClassDeclaration);
		build(console, "Arguments", ClassDeclaration);

		let io: Symbol = build(system, "IO", NamespaceDeclaration);
		build(io, "File_Reader", ClassDeclaration);
		build(io, "File_Writer", ClassDeclaration);

		let text: Symbol = build(system, "Text", NamespaceDeclaration);
		build(text, "String_Builder", ClassDeclaration);
	}

	private build_resource_manager(parent: Symbol) -> void
	{
		let class_symbol: Symbol = build(parent, "Resource_Manager", ClassDeclaration);
		let fake_declaration: mut Semantic_Node = new Semantic_Node(new Syntax_Node(GlobalDeclaration, true, none, 0, 0));
		let symbol: mut Symbol = new Symbol("resource_manager");
		symbol.declarations.Add(fake_declaration);
		fake_declaration.bind_symbol(symbol);
		fake_declaration.bind_type(new Type(class_symbol));
		parent.children.Add(symbol);
	}

	private build(parent: Symbol, name: string, declaration_kind: int) -> mut Symbol
	{
		let fake_declaration: mut Semantic_Node = new Semantic_Node(new Syntax_Node(declaration_kind, true, none, 0, 0));
		let symbol: mut Symbol = new Symbol(name);
		symbol.declarations.Add(fake_declaration);
		fake_declaration.bind_symbol(symbol);
		fake_declaration.bind_type(new Type(symbol));
		parent.children.Add(symbol);
		return symbol;
	}

	private build_function(parent: Symbol, name: string) -> void
	{
		let fake_declaration: mut Semantic_Node = new Semantic_Node(new Syntax_Node(FunctionDeclaration, true, none, 0, 0));
		let symbol: mut Symbol = new Symbol(name);
		symbol.declarations.Add(fake_declaration);
		fake_declaration.bind_symbol(symbol);
		parent.children.Add(symbol);
	}
}
