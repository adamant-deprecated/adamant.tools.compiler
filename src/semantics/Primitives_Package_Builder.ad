/// Builds a package which represents the primitives
// TODO this could probably be better done with nested functions.
public class Primitives_Package_Builder
{
	public build(self) -> Package
	{
		// The primitives package has the special name `\primitives` to distinguish
		// it from all normal packages since backslash is invalid in a package name.
		// TODO use verbatim string
		let name: Package_Name = new Package_Name("\\primitives");

		// No referenced packages
		let references: System.Collections.List<Package_Reference> = new System.Collections.List<Package_Reference>();

		// The primitives package has no compilation units because it has no source
		let compilation_units: System.Collections.List<Compilation_Unit> = new System.Collections.List<Compilation_Unit>();

		let primitive_symbols: mut System.Collections.List<Symbol> = build_primitive_symbols();
		assert(|primitive_symbols| > 0, "|primitive_symbols=" + |primitive_symbols|);

		let package_symbol: Symbol = new Symbol(name.text, PackageSymbol, primitive_symbols);
		assert(|package_symbol.children| > 0, "|package_symbol.children|=" + |package_symbol.children|);

		return new Package(name, references, compilation_units, package_symbol);
	}

	private build_primitive_symbols(self) -> mut System.Collections.List<Symbol>
	{
		let symbols: mut System.Collections.List<Symbol> = new System.Collections.List<Symbol>();

		symbols.Add(build_primitive("void"));
		symbols.Add(build_primitive("never"));

		symbols.Add(build_primitive("bool"));
		symbols.Add(build_primitive("code_point"));
		symbols.Add(build_primitive("string"));

		symbols.Add(build_primitive("int8"));
		symbols.Add(build_primitive("int16"));
		symbols.Add(build_primitive("int"));
		symbols.Add(build_primitive("int64"));
		symbols.Add(build_primitive("int128"));

		symbols.Add(build_primitive("byte"));
		symbols.Add(build_primitive("uint16"));
		symbols.Add(build_primitive("uint"));
		symbols.Add(build_primitive("uint64"));
		symbols.Add(build_primitive("uint128"));

		symbols.Add(build_primitive("float32"));
		symbols.Add(build_primitive("float"));
		symbols.Add(build_primitive("float128"));

		build_fixed_point_primitives(symbols, 8);
		build_fixed_point_primitives(symbols, 16);
		build_fixed_point_primitives(symbols, 32);
		build_fixed_point_primitives(symbols, 64);

		symbols.Add(build_primitive("decimal32"));
		symbols.Add(build_primitive("decimal"));
		symbols.Add(build_primitive("decimal128"));

		symbols.Add(build_primitive("size"));
		symbols.Add(build_primitive("offset"));

		return symbols;
	}

	private build_primitive(name: string) -> Symbol
	{
		let type: Type = new Type(ValueType, name, true, true, true);
		return new Symbol(name, type);
	}

	private build_fixed_point_primitives(symbols: mut System.Collections.List<Symbol>, bits: int /*size*/) -> void
	{
		// TODO implement when language features make it easier
		// for let i: usize in 1..usize-1
		// {
		// 	symbols.Add(new_Symbol_primitive("fixed"+i+"."+(bitLength-i)));
		// 	symbols.Add(new_Symbol_primitive("fixed"+i+"."+(bitLength-i)));
		// }
	}
}
