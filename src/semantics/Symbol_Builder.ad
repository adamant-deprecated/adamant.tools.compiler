public class Symbol_Builder
{
	// Takes a package and builds the symbols for it
	public build_symbols(self, compilation_units: System.Collections.List<mut Semantic_Node>) -> Symbol
	{
		// TODO eventually the package symbol should have a name so that we can look up names in front of the package qualifier
		let package_symbol: mut Symbol = new Symbol(none, "", PackageSymbol);
		for let compilation_unit: mut Semantic_Node in compilation_units
		{
			if compilation_unit.Type =/= CompilationUnit
				{ THROW_EXCEPTION("`Symbol_Builder.build_symbols(...)` called with node of type " + compilation_unit.Type); }

			build_symbols(package_symbol, compilation_unit);
		}

		build_runtime_library_symbols(package_symbol);

		return package_symbol;
	}

	// Because a single call could produce multiple symbols, we pass the symbol collection in and add symbols to it.
	// Once we have generators, this would be a good place to use them.
	private build_symbols(self, parent: Symbol, node: mut Semantic_Node) -> void
	{
		if node.Type == CompilationUnit
		{
			for let declaration: mut Semantic_Node in node.Children
			{
				build_symbols(parent, declaration);
			}
		}
		else if node.Type == FunctionDeclaration
			or node.Type == MethodDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let symbol: Symbol = new Symbol(parent, name);
			build_function_symbols(parent, node, symbol);
		}
		else if node.Type == ClassDeclaration
			or node.Type == StructDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let symbol: Symbol = new Symbol(parent, name);
			symbol.Declarations.Add(node);
			for let member: mut Semantic_Node in node.Members()
			{
				build_symbols(symbol, member);
			}

			parent.Children.Add(symbol);
			node.BindSymbol(symbol);
		}
		else if node.Type == ConstructorDeclaration
		{
			let constructor_symbol: Symbol = new Symbol(none, "", ConstructorSymbol);
			// TODO create a special self symbol
			constructor_symbol.Declarations.Add(node);
			build_function_symbols(parent, node, constructor_symbol);
		}
		else if node.Type == FieldDeclaration
		{
			let name: string = node.FirstChildOfType(VariableDeclaration).FirstChildOfType(Identifier).GetText();
			let field_symbol: Symbol = new Symbol(none, name);
			field_symbol.Declarations.Add(node);
			parent.Children.Add(field_symbol);
			node.BindSymbol(field_symbol);
		}
		else if node.Type == EnumDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let enum_symbol: Symbol = new Symbol(parent, name);
			enum_symbol.Declarations.Add(node);
			// TODO add enum member symbols
			parent.Children.Add(enum_symbol);
			node.BindSymbol(enum_symbol);
		}
		else if node.Type == GlobalDeclaration
		{
			let name: string = node.FirstChildOfType(VariableDeclaration).FirstChildOfType(Identifier).GetText();
			let globalDeclarationSymbol: Symbol = new Symbol(none, name);
			globalDeclarationSymbol.Declarations.Add(node);
			parent.Children.Add(globalDeclarationSymbol);
			node.BindSymbol(globalDeclarationSymbol);
		}
		else if node.Type == Block
		{
			for let statement: mut Semantic_Node in node.Statements()
			{
				build_symbols(parent, statement);
			}
		}
		else if node.Type == LoopStatement
			or node.Type == WhileStatement
			or node.Type == DoWhileStatement
		{
			build_symbols(parent, node.FirstChildOfType(Block));
		}
		else if node.Type == ForStatement
		{
			let name: string = node.FirstChildOfType(VariableDeclaration).FirstChildOfType(Identifier).GetText();
			let for_symbol: Symbol = new Symbol(none, name);
			for_symbol.Declarations.Add(node);
			parent.Children.Add(for_symbol);
			node.BindSymbol(for_symbol);
			build_symbols(parent, node.FirstChildOfType(Block));
		}
		else if node.Type == LocalDeclarationStatement
		{
			let name: string = node.FirstChildOfType(VariableDeclaration).FirstChildOfType(Identifier).GetText();
			let symbol: Symbol = new Symbol(none, name);
			symbol.Declarations.Add(node);
			parent.Children.Add(symbol);
		}
		else if node.Type == IfStatement
		{
			build_symbols(parent, node.FirstChildOfType(Block));
			let elseClause: mut Semantic_Node? = node.FirstChildOfType(ElseClause);
			if elseClause =/= none
			{
				build_symbols(parent, elseClause);
			}
		}
		else if node.Type == ElseClause
		{
			// This might be a good place for some kind of coalesce operator
			let block: mut Semantic_Node? = node.FirstChildOfType(Block);
			if block =/= none
			{
				build_symbols(parent, block);
			}
			else
			{
				build_symbols(parent, node.FirstChildOfType(IfStatement));
			}
		}
		else if node.Type == Parameter
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let symbol: Symbol = new Symbol(none, name);
			symbol.Declarations.Add(node);
			parent.Children.Add(symbol);
		}
		else if node.Type == SelfParameter
		{
			let name: string = node.FirstChildOfType(SelfKeyword).GetText();
			let symbol: Symbol = new Symbol(none, name, PrimitiveSymbol);
			symbol.Declarations.Add(node);
			parent.Children.Add(symbol);
		}
		else if node.Type == ExpressionStatement
			or node.Type == ReturnStatement
			or node.Type == BreakStatement
			or node.Type == ContinueStatement
			or node.Type == EndOfFileToken
		{
			// Ignore these nodes
		}
		else
		{
			THROW_EXCEPTION("`Symbol_Builder.Build()` unimplemented node type " + node.Type);
		}
	}

	private build_function_symbols(self, parent: Symbol, node: mut Semantic_Node, symbol: Symbol) -> void
	{
		symbol.Declarations.Add(node);

		let parameters: mut Semantic_Node = node.FirstChildOfType(ParameterList);
		for let parameter: mut Semantic_Node in parameters.Parameters()
		{
			build_symbols(symbol, parameter);
		}

		let body: mut Semantic_Node = node.FirstChildOfType(Block);
		build_symbols(symbol, body);

		parent.Children.Add(symbol);
		node.BindSymbol(symbol);
	}

	/// This builds up a set of symbols that are actually in the Runtime Library
	/// as if they were part of the current package.
	///
	/// TODO this should actually be a separate package
	private build_runtime_library_symbols(self, package: Symbol) -> void
	{
		let fake_declaration: Semantic_Node = new Semantic_Node(new Syntax_Node(ClassDeclaration, true, none, 0, 0));

		package.Children.Add(new Symbol(package, "resource_manager"));
		package.Children.Add(new Symbol(package, "THROW_EXCEPTION"));

		let system: Symbol = new Symbol(package, "System");
		package.Children.Add(system);

		let collections: Symbol = new Symbol(system, "Collections");
		system.Children.Add(collections);

		let list: mut Symbol = new Symbol(system, "List");
		list.Declarations.Add(fake_declaration);
		collections.Children.Add(list);

		let console: Symbol = new Symbol(system, "Console");
		system.Children.Add(console);

		let console_class: mut Symbol = new Symbol(system, "Console");
		console_class.Declarations.Add(fake_declaration);
		console.Children.Add(console_class);

		let arguments: mut Symbol = new Symbol(system, "Arguments");
		arguments.Declarations.Add(fake_declaration);
		console.Children.Add(arguments);

		let io: Symbol = new Symbol(system, "IO");
		system.Children.Add(io);

		let file_reader: mut Symbol = new Symbol(system, "File_Reader");
		file_reader.Declarations.Add(fake_declaration);
		io.Children.Add(file_reader);

		let file_writer: mut Symbol = new Symbol(system, "File_Writer");
		file_writer.Declarations.Add(fake_declaration);
		io.Children.Add(file_writer);

		let text: Symbol = new Symbol(system, "Text");
		system.Children.Add(text);

		let string_builder: mut Symbol = new Symbol(text, "String_Builder");
		string_builder.Declarations.Add(fake_declaration);
		text.Children.Add(string_builder);
	}
}
