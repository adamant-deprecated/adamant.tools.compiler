// TODO split this into various more specific kinds of names

// TODO: There is actually a hierarchy where more qualified names inherit from less qualified names
// Unqualified_Name = `c`
// Qualified_Name = `a.b.c`
// Fully_Qualified_Name = `::a.b.c` has optional package name
// Package_Qualified_Name = `p::a.b.c`
public class Name
{
	// package == none means that the package is unspecified
	public let package: Package_Name?; // TODO there should be kinds of names that have to have a package
	public let segments: System.Collections.List<string>;
	public let is_special: bool;

	public new global_namespace()
	{
		self.package = none;
		self.segments = new System.Collections.List<string>();
		self.is_special = false;
	}

	public new global_namespace(package: Package_Name)
	{
		assert(package =/= none, "");
		self.package = package;
		self.segments = new System.Collections.List<string>();
		self.is_special = false;
	}

	public new(parent: Name, name: string)
	{
		assert(parent =/= none, "");
		assert(name.ByteLength() > 0, "");
		self.package = parent.package;
		let segments: mut System.Collections.List<string> = new System.Collections.List<string>();
		for let segment: string in parent.segments
		{
			segments.Add(segment);
		}
		segments.Add(name);
		self.segments = segments;
		self.is_special = false;
	}

	public new special(parent: Name, name: string)
	{
		assert(parent =/= none, "");
		assert(name.ByteLength() > 0, "");
		self.package = parent.package;
		let segments: mut System.Collections.List<string> = new System.Collections.List<string>();
		for let segment: string in parent.segments
		{
			segments.Add(segment);
		}
		segments.Add(name);
		self.segments = segments;
		self.is_special = true;
	}

	public unqualified(self) -> string
	{
		if |segments|==0 { return ""; }
		return segments[|segments| - 1];
	}

	public full(self) -> string
	{
		var name: string = "";
		if package =/= none
			{ name = package.full(); }

		name = name + "::";
		// TODO need string join
		var first: bool = true;
		for let segment: string in segments
		{
			if first
			{
				first = false;
				name = name + segment;
				continue;
			}
			// TODO correctly format names with special chars etc.
			name = name + "." + segment;
		}
		return name;
	}

	public is_descendant_of(self, ancestor: Name) -> bool
	{
		if (package =/= none
			and ancestor.package =/= none
			and package.full() =/= ancestor.package.full())
			or |segments| <= |ancestor.segments|
			{ return false; }

		var i: int = 0;
		for let segment: string in ancestor.segments
		{
			if segment =/= segments[i]
				{ return false;}

			i += 1;
		}
		return true;
	}

	public is_child_of(self, parent: Name) -> bool
	{
		return |parent.segments|+1 == |segments|
			and is_descendant_of(parent);
	}
}
