// TODO split this into various more specific kinds of names

// TODO: There is actually a hierarchy where more qualified names inherit from less qualified names
// Unqualified_Name = `c`
// Qualified_Name = `a.b.c`
// Fully_Qualified_Name = `::a.b.c` has optional package name
// Package_Qualified_Name = `p::a.b.c`
public class Name
{
    // package == none means that the package is unspecified
    public let package: Package_Name?; // TODO there should be kinds of names that have to have a package
    public let kind: int;
    public let segments: System.Collections.List<string>;
    public let is_special: bool;

    // TODO rename to Name.of_global_namespace
    public new global_namespace()
    {
        self.package = none;
        self.kind = NamespaceName;
        self.segments = new System.Collections.List<string>();
        self.is_special = false;
    }

    // TODO rename to Name.of_global_namespace
    public new global_namespace(package: Package_Name)
    {
        assert(package =/= none, "");
        self.package = package;
        self.kind = NamespaceName;
        self.segments = new System.Collections.List<string>();
        self.is_special = false;
    }

    // TODO replace kind with name constructors Name.of_function etc.
    //      once constructors can call each other and the code isn't so long
    public new(qualifier: Name, kind: int, name: string)
    {
        assert(qualifier =/= none, "");
        assert(name.ByteLength() > 0, "");
        self.package = qualifier.package;
        self.kind = kind;
        let segments: mut System.Collections.List<string> = new System.Collections.List<string>();
        for let segment: string in qualifier.segments
        {
            segments.Add(segment);
        }
        segments.Add(name);
        self.segments = segments;
        self.is_special = false;
    }

    public new(qualifier: Name, kind: int, name: string, is_special: bool)
    {
        assert(qualifier =/= none, "");
        assert(name.ByteLength() > 0, "");
        self.package = qualifier.package;
        self.kind = kind;
        let segments: mut System.Collections.List<string> = new System.Collections.List<string>();
        for let segment: string in qualifier.segments
        {
            segments.Add(segment);
        }
        segments.Add(name);
        self.segments = segments;
        self.is_special = is_special;
    }

    public new special(qualifier: Name, kind: int, name: string)
    {
        assert(qualifier =/= none, "");
        assert(name.ByteLength() > 0, "");
        self.package = qualifier.package;
        self.kind = kind;
        let segments: mut System.Collections.List<string> = new System.Collections.List<string>();
        for let segment: string in qualifier.segments
        {
            segments.Add(segment);
        }
        segments.Add(name);
        self.segments = segments;
        self.is_special = true;
    }

    private new(
        package: Package_Name?,
        kind: int,
        segments: System.Collections.List<string>,
        is_special: bool)
    {
        self.package = package;
        self.kind = kind;
        self.segments = segments;
        self.is_special = is_special;
    }

    public unqualified(self) -> string
    {
        if |segments|==0 { return ""; }
        return segments[|segments| - 1];
    }

    public full(self) -> string
    {
        var name: string = "";
        if package =/= none
            { name = package.full(); }

        name = name + "::";
        // TODO need string join
        var first: bool = true;
        for let segment: string in segments
        {
            if first
            {
                first = false;
                name = name + segment;
                continue;
            }
            // TODO correctly format names with special chars etc.
            name = name + "." + segment;
        }
        return name;
    }

    /// Whether the qualifier is the qualifier of some name qualifying this name
    // TODO this method name doesn't make it clear that the package could be unspecified
    public is_qualified_with(self, qualifier: Name) -> bool
    {
        if (package =/= none
            and qualifier.package =/= none
            and package.full() =/= qualifier.package.full())
            or |segments| <= |qualifier.segments|
            { return false; }

        var i: int = 0;
        for let segment: string in qualifier.segments
        {
            if segment =/= segments[i]
                { return false;}

            i += 1;
        }
        return true;
    }

    /// Whether the qualifier is the immediate qualifier of this name
    // TODO this method name doesn't make it clear that the package could be unspecified
    public qualifier_is(self, qualifier: Name) -> bool
    {
        return |qualifier.segments|+1 == |segments|
            and is_qualified_with(qualifier);
    }

    // TODO this name is a little confusing, it is like equal except for the package
    public names(self, other: Name) -> bool
    {
        if (package =/= none
            and (other.package == none or package.full() =/= other.package.full()))
            or |segments| =/= |other.segments|
        {
            return false;
        }

        var i: int = 0;
        for let segment: string in other.segments
        {
            if segment =/= segments[i]
                { return false;}

            i += 1;
        }
        return true;
    }

    public is_package_qualified(self) -> bool
    {
        return package =/= none;
    }

    public remove_package(self) -> Name
    {
        if package == none
            { return self; }
        else
            { return new Name(none, kind, segments, is_special); }
    }
}
