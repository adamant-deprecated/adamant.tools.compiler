/// The root binding scope that accounts for package names
public /*mut*/ class Name_Table
{
	public let any_package: mut Name_Subtable;
	private let packages: mut System.Collections.List<mut Name_Subtable>;

	public new()
	{
		self.any_package = new Name_Subtable.global_namespace(self);
		self.packages = new System.Collections.List<mut Name_Subtable>();
	}

	/// Adds a `Package_Binding_Declaration` for the named package
	public add(mut self, package_name: Package_Name) -> Name
	{
		// TODO deal with duplicate package names
		let subtable: mut Name_Subtable = new Name_Subtable.global_namespace(self, package_name);
		packages.add(subtable);
		return subtable.name;
	}

	// Adds a name to the `Name_Table`
	public add(mut self, parent: Name, symbol: Symbol) -> Name
	{
		var name: Name; // make this let when I can
		if symbol.declares_type =/= none
		{
			name = new Name(parent, TypeName, symbol.name, symbol.is_special_name);
			add(name, symbol.declares_type);
		}
		else
		{
			// TODO this could be something besides a function name
			name = new Name(parent, FunctionName, symbol.name, symbol.is_special_name);
			add(name, symbol.of_type);
		}
		return name;
	}

	public add(mut self, name: Name, type: Type) -> void
	{
		any_package.add(name, type);
		for let package: mut Name_Subtable in packages
		{
			if name.is_descendant_of(package.name)
			{
				package.add(name, type);
				return;
			}
		}
		THROW_EXCEPTION("Can't add name \""+name.full()+"\" because package doesn't exist in table.");
	}

	public get(self, name: Name) -> Name_Subtable?
	{
		NOT_IMPLEMENTED("");
	}
}
