/// The root binding scope that accounts for package names
public /*mut*/ class Name_Table
{
	private let any_package: mut Name_Subtable;
	private let packages: mut System.Collections.List<mut Name_Subtable>;

	public new()
	{
		self.any_package = new Name_Subtable.global_namespace(self);
		self.packages = new System.Collections.List<mut Name_Subtable>();
	}

	/// Adds a `Package_Binding_Declaration` for the named package
	public add(mut self, package_name: Package_Name) -> Name
	{
		// TODO deal with duplicate package names
		let subtable: mut Name_Subtable = new Name_Subtable.global_namespace(self, package_name);
		packages.add(subtable);
		return subtable.name;
	}

	// Adds a name to the `Name_Table`
	public add(mut self, parent: Name, symbol: Symbol) -> Name
	{
		if symbol.declares_type =/= none
		{
			return add(parent, symbol.name, symbol.declares_type);
		}
		else
		{
			return add(parent, symbol.name, symbol.type);
		}
	}

	// TODO not sure the name should be constructed in this function, pass it in instead?
	public add(mut self, parent: Name, unqualified_name: string, type: Type) -> Name
	{
		let name: Name = new Name(parent, unqualified_name);
		add(name, type);
		return name;
	}

	public add(mut self, name: Name, type: Type) -> void
	{
		any_package.add(name, type);
		for let package: mut Name_Subtable in packages
		{
			if name.is_descendant_of(package.name)
			{
				package.add(name, type);
				return;
			}
		}
		THROW_EXCEPTION("Can't add name \""+name.full()+"\" because package doesn't exist in table.");
	}
}
