/// The root binding scope that accounts for package names
public /*mut*/ class Name_Table
{
    public let any_package: mut Name_Subtable;
    private let packages: mut system.collections.List<mut Name_Subtable>;

    public new()
    {
        self.any_package = new Name_Subtable.global_namespace(self);
        self.packages = new system.collections.List<mut Name_Subtable>();
    }

    /// Adds a `Package_Binding_Declaration` for the named package
    public add(mut self, package_name: Package_Name) -> Name
    {
        // TODO deal with duplicate package names
        let subtable: mut Name_Subtable = new Name_Subtable.global_namespace(self, package_name);
        packages.add(subtable);
        return subtable.name;
    }

    // Adds a name to the `Name_Table`
    public add(mut self, parent: Name, symbol: Symbol) -> Name
    {
        var name: Name; // make this let when I can
        if symbol.declares_type =/= none
        {
            name = new Name(parent, TypeName, symbol.name, symbol.is_special_name);
            add(name, symbol.declares_type);
        }
        else
        {
            // TODO this could be something besides a function name
            name = new Name(parent, FunctionName, symbol.name, symbol.is_special_name);
            add(name, symbol.of_type);
        }
        return name;
    }

    public add(mut self, name: Name, type: Type) -> void
    {
        any_package.add(name, type);
        for let package: mut Name_Subtable in packages
        {
            if is_qualified_by(name, package.name)
            {
                package.add(name, type);
                return;
            }
        }
        THROW_EXCEPTION("Can't add name \""+full_name(name)+"\" because package doesn't exist in table.");
    }

    public get(self, name: Name) -> Name_Subtable?
    {
        // TODO this condition isn't intention revealing
        if name.package == none
        {
            return any_package.get(name);
        }

        for let package: Name_Subtable in packages
        {
            if is_qualified_by(name, package.name)
            {
                return package.get(name);
            }
        }

        return none;
    }
}
