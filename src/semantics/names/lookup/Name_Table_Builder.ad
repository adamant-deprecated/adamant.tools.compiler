/// Builds the binding scopes so that we can look up names
public class Name_Table_Builder
{
	public build(self,
		package_name: Package_Name,
		package_syntax: Syntax_Node,
		references: System.Collections.List<Package_Reference>)
		-> Name_Table
	{
		assert(package_syntax.kind == PackageNode, "package_syntax.kind=" + package_syntax.kind);
		let name_table: mut Name_Table = new Name_Table();
		add_referenced(name_table, references);
		add_package(name_table, package_name, package_syntax);
		return name_table;
	}

	private add_referenced(
		name_table: mut Name_Table,
		references: System.Collections.List<Package_Reference>)
		-> void
	{
		for let reference: Package_Reference in references
		{
			let reference_name: Package_Name = new Package_Name(reference.name);
			let global_namespace: Name = name_table.add(reference_name);
			// We already added the package symbol as a reference name, now add the children
			for let symbol: Symbol in reference.package.symbol.children
			{
				add_symbol(/*mut*/ name_table, global_namespace, symbol);
			}
		}
	}

	private add_symbol(name_table: mut Name_Table, parent: Name, symbol: Symbol) -> void
	{
		let name: Name = name_table.add(parent, symbol);
		for let child: Symbol in symbol.children
		{
			add_symbol(/*mut*/ name_table, name, child);
		}
	}

	private add_package(
		name_table: mut Name_Table,
		package_name: Package_Name,
		package_syntax: Syntax_Node)
		-> void
	{
		assert(package_syntax.kind == PackageNode, "package_syntax.kind=" + package_syntax.kind);
		let global_namespace: Name = name_table.add(package_name);
		for let compilation_unit: Syntax_Node in package_syntax.children
		{
			add_compilation_unit(name_table, global_namespace, compilation_unit);
		}
	}

	private add_compilation_unit(
		name_table: mut Name_Table,
		global_namespace: Name,
		compilation_unit: Syntax_Node)
		-> void
	{
		assert(compilation_unit.kind == CompilationUnit, "compilation_unit.kind=" + compilation_unit.kind);
		for let declaration: Syntax_Node in compilation_unit.children
		{
			add_syntax(name_table, global_namespace, declaration);
		}
	}

	private add_syntax(
		name_table: mut Name_Table,
		parent: Name,
		syntax: Syntax_Node)
		-> void
	{
		if syntax.kind == FunctionDeclaration
			or syntax.kind == MethodDeclaration
		{
			let name: Name = new Name(parent, syntax.first_child(Identifier).get_text());
			add_function(name_table, name, syntax);
		}
		else if syntax.kind == ClassDeclaration
			or syntax.kind == StructDeclaration
		{
			let unqualified_name: string = syntax.first_child(Identifier).get_text();
			var type_kind: int;
			if syntax.kind == ClassDeclaration
				{ type_kind = ReferenceType; }
			else
				{ type_kind = ValueType; }
			let type: Type = new Type(type_kind, new Name(parent, unqualified_name), false);
			let name: Name = name_table.add(parent, unqualified_name, type);
			for let member: Syntax_Node in syntax.members()
			{
				add_syntax(name_table, name, member);
			}
		}
		else if syntax.kind == Block
		{
			for let statement: Syntax_Node in syntax.statements()
			{
				add_syntax(name_table, parent, statement);
			}
		}
		else if syntax.kind == LocalDeclarationStatement
		{
			let identifier: Syntax_Node = syntax.first_child(VariableDeclaration).first_child(Identifier);
			name_table.add(parent, identifier.get_text(), none); // Haven't bound the type yet
		}
		else if syntax.kind == ExpressionStatement
			or syntax.kind == ReturnStatement
			or syntax.kind == BreakStatement
			or syntax.kind == ContinueStatement
			or syntax.kind == EndOfFileToken
		{
			// ignore these
		}
		else
		{
			NOT_IMPLEMENTED("syntax.kind=" + syntax.kind);
		}
	}

	private add_function(
		name_table: mut Name_Table,
		name: Name,
		function: Syntax_Node)
		-> void
	{
		let type: Type? = none; // we don't have a type for functions yet
		name_table.add(name, type); // ambiguous unless we type the variable first

		let parameters: Syntax_Node = function.first_child(ParameterList);
		for let parameter: Syntax_Node in parameters.parameters()
		{
			add_syntax(name_table, name, parameter);
		}

		let body: Syntax_Node = function.first_child(Block);
		add_syntax(name_table, name, body);
	}
}
