public /*mut*/ class Name_Subtable
{
	public let name_table: Name_Table;
	public let parent: Name_Subtable?; // TODO this should point at the package binding scope?
	public let name: Name;
	public let type: Type;
	private let subtables: mut System.Collections.List<mut Name_Subtable>;

	public new global_namespace(name_table: Name_Table)
	{
		// assert name package should be in the Name_Table
		self.name_table = name_table;
		self.parent = none;
		self.name = new Name.global_namespace();
		self.type = new Type.namespace(self.name);
		subtables = new System.Collections.List<mut Name_Subtable>();
	}

	public new global_namespace(name_table: Name_Table, package_name: Package_Name)
	{
		// assert name package should be in the Name_Table
		self.name_table = name_table;
		self.parent = none;
		self.name = new Name.global_namespace(package_name);
		self.type = new Type.namespace(self.name);
		subtables = new System.Collections.List<mut Name_Subtable>();
	}

	public find(self, name: string) -> Name_Subtable
	{
		for let subtable: Name_Subtable in subtables
		{
			if subtable.name.unqualified() == name
				{ return subtable; }
		}
		return none;
	}

	private new(parent: Name_Subtable, name: Name, type: Type)
	{
		// assert(parent.name.package == name.package);
		// assert parent name contains us
		self.name_table = parent.name_table;
		self.parent = parent;
		self.name = name;
		self.type = type;
		subtables = new System.Collections.List<mut Name_Subtable>();
	}

	public add(mut self, name: Name, type: Type) -> void
	{
		assert(name.is_descendant_of(self.name), "\""+name.full()+"\" is not a child of \""+self.name.full()+"\"");
		if name.is_child_of(self.name)
		{
			if self.name.package == none and type =/= none and type.kind == NamespaceType
			{
				subtables.add(new Name_Subtable(self, name.remove_package(), type.remove_package()));
			}
			else
			{
				subtables.add(new Name_Subtable(self, name, type));
			}
			return;
		}

		for let subtable: mut Name_Subtable in subtables
		{
			if name.is_descendant_of(subtable.name)
			{
				subtable.add(name, type);
				return;
			}
		}

		// TODO this assert is wrong
		assert(|name.segments| == |self.name.segments| + 1, "Can't add \""+name.full()+"\" to \""+self.name.full()+"\"");
	}
}
