/// Builds up the tree of `Semantic_Node`s for all the compilation units
/// This class actually builds up the semantic tree for the package
public /*mut*/ class Semantic_Tree_Builder
{
	public build(self,
		package_syntax: Syntax_Node,
		name_table: Name_Table)
		-> System.Collections.List<Compilation_Unit>
	{
		assert(package_syntax.kind == PackageNode, "package_syntax.kind=" + package_syntax.kind);

		let compilation_units: mut System.Collections.List<Compilation_Unit> = new System.Collections.List<Compilation_Unit>();

		for let compilation_unit_syntax: Syntax_Node in package_syntax.children
		{
			compilation_units.add(build_compilation_unit(compilation_unit_syntax, name_table));
		}
		return compilation_units;
	}

	private build_compilation_unit(
		compilation_unit_syntax: Syntax_Node,
		name_table: Name_Table)
		-> Compilation_Unit
	{
		assert(compilation_unit_syntax.kind == CompilationUnit, "compilation_unit_syntax.kind=" + compilation_unit_syntax.kind);

		let scope: Name_Subtable = none; //name_table; // TODO this isn't right, we need to load the correct one
		let declarations: mut System.Collections.List<Semantic_Node> = new System.Collections.List<Semantic_Node>();
		for let declaration_syntax: Syntax_Node in compilation_unit_syntax.children
		{
			declarations.add(build(declaration_syntax, name_table, name_table.any_package));
		}
		return new Compilation_Unit(compilation_unit_syntax.source, declarations);
	}

	private build(
		syntax: Syntax_Node,
		name_table: Name_Table,
		scope: Name_Subtable)
		-> Semantic_Node
	{
		let children: mut System.Collections.List<Semantic_Node> = new System.Collections.List<Semantic_Node>();
		if syntax.kind == FunctionDeclaration
			or syntax.kind == MethodDeclaration
		{
			children.add(build(syntax.access_modifier(), name_table, scope));
			let function_name: Syntax_Node = syntax.first_child(Identifier);
			children.add(build(function_name, name_table, scope));
			build_parameters(syntax, name_table, scope, children);

			let return_type: Syntax_Node = syntax.children[4]; // TODO need more reliable way to pick this out
			children.add(build(return_type, name_table, scope));

			let function_scope: Name_Subtable = scope.find(function_name.get_text());
			let body: Syntax_Node = syntax.first_child(Block);
			children.add(build(body, name_table, function_scope));

			// TODO what about the function type?
			return new Semantic_Node.concrete(syntax, children);
		}
		else if |syntax.children| == 0
		{
			// Create a semantic node to represent the token
			return new Semantic_Node.token(syntax);
		}
		else
		{
			// TODO this is a temporary measure to build up the tree.
			//      replace with specific constructions
			for let child_syntax: Syntax_Node in syntax.children
			{
				children.add(build(child_syntax, name_table, scope));
			}
			return new Semantic_Node.concrete(syntax, children);
		}
	}

	private build_parameters(
		syntax: Syntax_Node,
		name_table: Name_Table,
		scope: Name_Subtable,
		nodes: mut System.Collections.List<Semantic_Node>)
		-> void
	{
		let parameter_list: Syntax_Node = syntax.first_child(ParameterList);
		for let parameter: Syntax_Node in parameter_list.parameters()
		{
			let children: mut System.Collections.List<Semantic_Node> = new System.Collections.List<Semantic_Node>();
			if parameter.kind == Parameter
			{
				children.add(new Semantic_Node.token(parameter.first_child(Identifier)));
				let type_syntax: Syntax_Node = parameter.children[2];
				let type_node: Semantic_Node = build(type_syntax, name_table, scope);
				children.add(type_node);

				nodes.add(new Semantic_Node.concrete(parameter, children));
				// TODO nodes.add(new Semantic_Node.of_type(type_node.referenced_type, parameter, children));
			}
			else if parameter.kind == SelfParameter
			{
				// TODO figure out the class type and call new Semantic_Node.of_type
				nodes.add(new Semantic_Node.concrete(parameter, children));
			}
			else
			{
				NOT_IMPLEMENTED("parameter.kind="+parameter.kind);
			}
		}
	}
}
