/// Builds up the tree of `Semantic_Node`s for all the compilation units
/// This class actually builds up the semantic tree for the package
public /*mut*/ class Semantic_Tree_Builder
{
	public build(self,
		package_syntax: Syntax_Node,
		name_table: Name_Table)
		-> System.Collections.List<Compilation_Unit>
	{
		assert(package_syntax.kind == PackageNode, "package_syntax.kind=" + package_syntax.kind);

		let compilation_units: mut System.Collections.List<Compilation_Unit> = new System.Collections.List<Compilation_Unit>();

		for let compilation_unit_syntax: Syntax_Node in package_syntax.children
		{
			compilation_units.add(build_compilation_unit(compilation_unit_syntax, name_table));
		}
		return compilation_units;
	}

	private build_compilation_unit(
		compilation_unit_syntax: Syntax_Node,
		name_table: Name_Table)
		-> Compilation_Unit
	{
		assert(compilation_unit_syntax.kind == CompilationUnit, "compilation_unit_syntax.kind=" + compilation_unit_syntax.kind);

		let scope: Name_Subtable = none; //name_table; // TODO this isn't right, we need to load the correct one
		let declarations: mut System.Collections.List<Semantic_Node> = new System.Collections.List<Semantic_Node>();
		for let declaration_syntax: Syntax_Node in compilation_unit_syntax.children
		{
			declarations.add(build(declaration_syntax, name_table, name_table.any_package));
		}
		return new Compilation_Unit(compilation_unit_syntax.source, declarations);
	}

	private build(
		syntax: Syntax_Node,
		name_table: Name_Table,
		scope: Name_Subtable)
		-> Semantic_Node
	{
		let children: mut System.Collections.List<Semantic_Node> = new System.Collections.List<Semantic_Node>();
		if syntax.kind == FunctionDeclaration
			or syntax.kind == MethodDeclaration
		{
			children.add(build(syntax.access_modifier(), name_table, scope));
			children.add(build(syntax.first_child(Identifier), name_table, scope));
			build_parameters(syntax, name_table, scope, children);

			let return_type: Syntax_Node = syntax.children[4]; // TODO need more reliable way to pick this out
			children.add(build(return_type, name_table, scope));

			let function_scope: Name_Subtable = scope.find(syntax.first_child(Identifier).get_text());
			let body: Syntax_Node = syntax.first_child(Block);
			children.add(build(body, name_table, function_scope));

			NOT_IMPLEMENTED("Return Semantic_Node");
		}
		else if |syntax.children| == 0
		{
			// Create a semantic node to represent the token
			return new Semantic_Node.token(syntax);
		}
		else
		{
			// TODO this is a temporary measure to build up the tree.
			//      replace with specific constructions
			for let child_syntax: Syntax_Node in syntax.children
			{
				children.add(build(child_syntax, name_table, scope));
			}
			return new Semantic_Node.concrete(syntax, children);
		}
	}

	private build_parameters(
		syntax: Syntax_Node,
		name_table: Name_Table,
		scope: Name_Subtable,
		nodes: mut System.Collections.List<Semantic_Node>)
		-> void
	{
		let parameter_list: Syntax_Node = syntax.first_child(ParameterList);
		for let parameter: Syntax_Node in parameter_list.parameters()
		{
			NOT_IMPLEMENTED("add to nodes");
		}
	}
}
