// Long term, the idea is to have a tree that implements the interface of the
// syntax tree, but adds additional methods and functionality
//
// But perhaps it would be better to have a tree that is very different from the
// syntax tree and fully abstracts away the syntax while still being linked to it.
public class Semantic_Node
{
    public let syntax: Syntax_Node;
    public let kind: int;
    public let is_missing: bool;
    public let source: Source_Text;
    public let start: uint;
    public let byte_length: uint;
    public let children: system.collections.List<Semantic_Node>;
    private let node_diagnostics: mut system.collections.List<Diagnostic>;

    /// The type of an expression (or variable) before any implicit conversions
    public let of_type: Type?;

    /// The type of an expression after any implicit conversions
    public let converted_type: Type?;

    /// For declarations, the type that is being declared (created)
    public let declares_type: Type?;

    /// For type names, the type that is being referenced
    public let referenced_type: Type?;

    public new token(syntax: Syntax_Node)
    {
        assert(syntax =/= none, "");
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = new system.collections.List<Semantic_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = none;
        self.referenced_type = none;
    }

    /// Construct a concrete mirror of a `Syntax_Node`
    public new concrete(syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(syntax =/= none, "");
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = none;
        self.referenced_type = none;
    }

    public new of_type(of_type: Type, syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(of_type =/= none, "");
        assert(syntax =/= none, "");
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = of_type;
        self.converted_type = of_type;
        self.declares_type = none;
        self.referenced_type = none;
    }

    public new declares_type(type: Type, syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(type =/= none, "");
        assert(syntax =/= none, "");
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = of_type;
        self.converted_type = none;
        self.declares_type = type;
        self.referenced_type = none;
    }

    public new referencing_type(type: Type, syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(type =/= none, "");
        assert(syntax =/= none, "");
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = none;
        self.referenced_type = type;
    }

    public get_text_span(self) -> Text_Span
    {
        return new Text_Span(start, byte_length);
    }

    public get_text(self) -> string
    {
        if source == none { return "$No Source$"; }
        return source.text.Substring(start, byte_length);
    }

    public first_child(self, kind: int) -> Semantic_Node?
    {
        for let child: Semantic_Node in children
        {
            if child.kind == kind
                { return child; }
        }
        return none;
    }

    public children_of_kind(self, kind: int) -> system.collections.List<Semantic_Node>
    {
        let children: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
        for let child: Semantic_Node in self.children
        {
            if child.kind == kind
            {
                children.add(child);
            }
        }
        return children;
    }

    // TODO this should only be on things like class, struct that have members
    public members(self) -> system.collections.List<Semantic_Node>
    {
        let members: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
        for let child: Semantic_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind == ConstructorDeclaration
                or child.kind == FieldDeclaration
                or child.kind == MethodDeclaration
            {
                members.add(child);
            }
        }
        return members;
    }

    // TODO this should only be on things like block
    public statements(self) -> system.collections.List<Semantic_Node>
    {
        let statements: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
        for let child: Semantic_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind =/= LeftBrace
                and child.kind =/= RightBrace
            {
                statements.add(child);
            }
        }
        return statements;
    }

    // TODO this should only be on things like parameter list and function
    public parameters(self) -> system.collections.List<Semantic_Node>
    {
        let parameters: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
        for let child: Semantic_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind == Parameter
                or child.kind == SelfParameter
            {
                parameters.add(child);
            }
        }
        return parameters;
    }

    // TODO this should only be on things with access modifiers
    public access_modifier(self) -> Semantic_Node?
    {
        for let child: Semantic_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind == PublicKeyword
                or child.kind == ProtectedKeyword
                or child.kind == PrivateKeyword
                or child.kind == InternalKeyword
            {
                return child;
            }
        }

        return none;
    }

    public has_child(self, kind: int) -> bool
    {
        for let child: Semantic_Node in children
        {
            if child.kind == kind
                { return true; }
        }
        return false;
    }

    public add(mut self, diagnostic: Diagnostic) -> void
    {
        node_diagnostics.add(diagnostic);
    }

    public diagnostics(self) -> system.collections.List<Diagnostic>
    {
        return self.node_diagnostics;
    }

    protected collect_diagnostics(self, diagnostics: mut system.collections.List<Diagnostic>) -> void
    {
        for let diagnostic: Diagnostic in node_diagnostics
        {
            diagnostics.add(diagnostic);
        }

        for let child: Semantic_Node in children
        {
            child.collect_diagnostics(diagnostics);
        }
    }
}
