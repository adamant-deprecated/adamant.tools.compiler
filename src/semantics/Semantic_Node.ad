// Long term, the idea is to have a tree that implements the interface of the
// syntax tree, but adds additional methods and functionality

// TODO implement a semantic node that wraps a Syntax_Node

public class Semantic_Node
{
	public let Syntax: Syntax_Node;
	public let Type: int;
	public let IsMissing: bool;
	public let Source: Source_Text;
	public let Start: uint;
	public let Length: uint; // TODO is this ByteLength?
	public let Children: System.Collections.List<mut Semantic_Node>;
	public let Diagnostics: mut System.Collections.List<Diagnostic>;
	public var symbol: Symbol?;

	public new(syntax: Syntax_Node)
	{
		Syntax = syntax;
		Type = syntax.Type;
		IsMissing = syntax.IsMissing;
		Source = syntax.Source;
		Start = syntax.Start;
		Length = syntax.Length;
		let children: mut System.Collections.List<mut Semantic_Node> = new System.Collections.List<mut Semantic_Node>();
		for let childSyntax: Syntax_Node in syntax.Children
		{
			children.Add(new Semantic_Node(childSyntax));
		}
		Children = children;
		let diagnostics: mut System.Collections.List<Diagnostic> = new System.Collections.List<Diagnostic>();
		for let diagnostic: Diagnostic in syntax.Diagnostics
		{
			diagnostics.Add(diagnostic);
		}
		Diagnostics = diagnostics;
		symbol = none;
	}

	public get_text_span(self) -> Text_Span
	{
		return new Text_Span(Start, Length);
	}

	public GetText(self) -> string
	{
		return Source.Text.Substring(Start, Length);
	}

	public BindSymbol(mut self, symbol: Symbol) -> void
	{
		if self.symbol =/= none { THROW_EXCEPTION("`Semantic_Node.BindSymbol(..)` called on node that already has a symbol on `" + GetText() + "`"); }
		if symbol == none { THROW_EXCEPTION("`Semantic_Node.BindSymbol(..)` called without a symbol on `" + GetText() + "`"); }
		self.symbol = symbol;
	}

	public FirstChildOfType(self, type: int) -> mut Semantic_Node?
	{
		for let child: mut Semantic_Node in Children
		{
			if child.Type == type
				{ return child; }
		}
		return none;
	}

	public ChildrenOfType(self, type: int) -> System.Collections.List<mut Semantic_Node>
	{
		let members: mut System.Collections.List<mut Semantic_Node> = new System.Collections.List<mut Semantic_Node>();
		for let child: mut Semantic_Node in Children
		{
			if child.Type == type
			{
				members.Add(child);
			}
		}
		return members;
	}

	// TODO this should only be on things like class, struct that have members
	public Members(self) -> System.Collections.List<mut Semantic_Node>
	{
		let members: mut System.Collections.List<mut Semantic_Node> = new System.Collections.List<mut Semantic_Node>();
		for let child: mut Semantic_Node in Children
		{
			// TODO fix this to a more reliable means of telling what should be visited
			if child.Type == ConstructorDeclaration
				or child.Type == FieldDeclaration
				or child.Type == MethodDeclaration
			{
				members.Add(child);
			}
		}
		return members;
	}

	// TODO this should only be on things like block
	public Statements(self) -> System.Collections.List<mut Semantic_Node>
	{
		let statements: mut System.Collections.List<mut Semantic_Node> = new System.Collections.List<mut Semantic_Node>();
		for let child: mut Semantic_Node in Children
		{
			// TODO fix this to a more reliable means of telling what should be visited
			if child.Type =/= LeftBrace
				and child.Type =/= RightBrace
			{
				statements.Add(child);
			}
		}
		return statements;
	}

	// TODO this should only be on things like parameter list and function
	public Parameters(self) -> System.Collections.List<mut Semantic_Node>
	{
		let parameters: mut System.Collections.List<mut Semantic_Node> = new System.Collections.List<mut Semantic_Node>();
		for let child: mut Semantic_Node in Children
		{
			// TODO fix this to a more reliable means of telling what should be visited
			if child.Type == Parameter
				or child.Type == SelfParameter
			{
				parameters.Add(child);
			}
		}
		return parameters;
	}

	public HasChildOfType(self, type: int) -> bool
	{
		for let child: Semantic_Node in Children
		{
			if child.Type == type
				{ return true; }
		}
		return false;
	}

	public Add(self, diagnostic: Diagnostic) -> void
	{
		Diagnostics.Add(diagnostic);
	}

	public AllDiagnostics(self) -> System.Collections.List<Diagnostic>
	{
		var diagnostics: mut System.Collections.List<Diagnostic> = new System.Collections.List<Diagnostic>();
		CollectDiagnostics(diagnostics);
		return diagnostics;
	}

	protected CollectDiagnostics(self, diagnostics: mut System.Collections.List<Diagnostic>) -> void
	{
		for let diagnostic: Diagnostic in Diagnostics
		{
			diagnostics.Add(diagnostic);
		}

		for let child: Semantic_Node in Children
		{
			child.CollectDiagnostics(diagnostics);
		}
	}
}
