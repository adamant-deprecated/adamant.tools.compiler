// Long term, the idea is to have a tree that implements the interface of the
// syntax tree, but adds additional methods and functionality
//
// But perhaps it would be better to have a tree that is very different from the
// syntax tree and fully abstracts away the syntax while still being linked to it.
public class Semantic_Node
{
    public let syntax: Syntax_Node;
    public let kind: int;
    public let is_missing: bool;
    public let source: Source_Text;
    public let start: int;
    public let byte_length: int;
    public let children: system.collections.List<Semantic_Node>;
    public let node_diagnostics: mut system.collections.List<Diagnostic>;

    /// The type of an expression (or variable) before any implicit conversions
    public let of_type: Type?;

    /// The type of an expression after any implicit conversions
    public let converted_type: Type?;

    /// For declarations, the type that is being declared (created)
    public let declares_type: Type?;

    /// For type names, the type that is being referenced
    public let referenced_type: Type?;

    public new token(syntax: Syntax_Node)
    {
        assert(syntax =/= none);
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = new system.collections.List<Semantic_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = none;
        self.referenced_type = none;
    }

    /// Construct a concrete mirror of a `Syntax_Node`
    public new concrete(syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(syntax =/= none);
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = none;
        self.referenced_type = none;
    }

    public new of_type(of_type: Type, syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(of_type =/= none);
        assert(syntax =/= none);
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = of_type;
        self.converted_type = of_type;
        self.declares_type = none;
        self.referenced_type = none;
    }

    public new declares_type(type: Type, syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(type =/= none);
        assert(syntax =/= none);
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = type;
        self.referenced_type = none;
    }

    public new referencing_type(type: Type, syntax: Syntax_Node, children: system.collections.List<Semantic_Node>)
    {
        assert(type =/= none);
        assert(syntax =/= none);
        self.syntax = syntax;
        self.kind = syntax.kind;
        self.is_missing = syntax.is_missing;
        self.source = syntax.source;
        self.start = syntax.start;
        self.byte_length = syntax.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        self.of_type = none;
        self.converted_type = none;
        self.declares_type = none;
        self.referenced_type = type;
    }
}

public get_text_span(node: Semantic_Node) -> Text_Span
{
    return new Text_Span(node.start, node.byte_length);
}

public get_node_text(node: Semantic_Node) -> string
{
    if node.source == none { return "$No Source$"; }
    return substring(node.source.text, node.start, node.byte_length);
}

public first_child(node: Semantic_Node, kind: int) -> Semantic_Node?
{
    for let child: Semantic_Node in node.children
    {
        if child.kind == kind
            { return child; }
    }
    return none;
}

public children_of_kind(node: Semantic_Node, kind: int) -> system.collections.List<Semantic_Node>
{
    let children: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
    for let child: Semantic_Node in node.children
    {
        if child.kind == kind
        {
            add_item(children, child);
        }
    }
    return children;
}

// TODO this should only be on things like class, struct that have members
public node_members(node: Semantic_Node) -> system.collections.List<Semantic_Node>
{
    let members: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
    for let child: Semantic_Node in node.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind == ConstructorDeclaration
            or child.kind == FieldDeclaration
            or child.kind == MethodDeclaration
        {
            add_item(members, child);
        }
    }
    return members;
}

// TODO this should only be on things like block
public node_statements(node: Semantic_Node) -> system.collections.List<Semantic_Node>
{
    let statements: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
    for let child: Semantic_Node in node.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind =/= LeftBrace
            and child.kind =/= RightBrace
        {
            add_item(statements, child);
        }
    }
    return statements;
}

// TODO this should only be on things like parameter list and function
public node_parameters(node: Semantic_Node) -> system.collections.List<Semantic_Node>
{
    let parameters: mut system.collections.List<Semantic_Node> = new system.collections.List<Semantic_Node>();
    for let child: Semantic_Node in node.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind == Parameter
            or child.kind == SelfParameter
        {
            add_item(parameters, child);
        }
    }
    return parameters;
}

// TODO this should only be on things like parameter list and function
public node_argument_count(node: Semantic_Node) -> int
{
    var count: int = 0;
    for let child: Semantic_Node in node.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind == LeftParen
            or child.kind == RightParen
            or child.kind == Comma
        {
            continue;
        }
        count += 1;
    }
    return count;
}

// TODO this should only be on things with access modifiers
public node_access_modifier(node: Semantic_Node) -> Semantic_Node?
{
    for let child: Semantic_Node in node.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind == PublicKeyword
            or child.kind == ProtectedKeyword
            or child.kind == PrivateKeyword
            or child.kind == InternalKeyword
        {
            return child;
        }
    }

    return none;
}

public node_has_child(node: Semantic_Node, kind: int) -> bool
{
    for let child: Semantic_Node in node.children
    {
        if child.kind == kind
            { return true; }
    }
    return false;
}

public add_diagnostic(node: mut Semantic_Node, diagnostic: Diagnostic) -> void
{
    add_item(node.node_diagnostics, diagnostic);
}

public diagnostics(node: Semantic_Node) -> system.collections.List<Diagnostic>
{
    return node.node_diagnostics;
}

public collect_diagnostics(node: Semantic_Node, diagnostics: mut system.collections.List<Diagnostic>) -> void
{
    for let diagnostic: Diagnostic in node.node_diagnostics
    {
        add_item(diagnostics, diagnostic);
    }

    for let child: Semantic_Node in node.children
    {
        collect_diagnostics(child, diagnostics);
    }
}
