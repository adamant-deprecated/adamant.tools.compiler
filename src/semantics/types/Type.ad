// TODO maybe type should inherit from name
// Base class for types
public /* abstract */ class Type
{
    public let name: Name;
    public let generic_parameters: system.collections.List<Generic_Parameter>; // unused at this level, here for alignment
    public let generic_arguments: system.collections.List<Type>;
    public let is_primitive: bool; // TODO remove
    public let is_value_type: bool;
    public let is_potentially_mutable: bool; // Whether the type being referred to can ever be mutable
    public let is_mutable: bool;
}

public make_mutable_type(type: Type) -> Type
{
    match type
    {
        o: Object_Type =>
        {
            assert(type.is_potentially_mutable, "self.name="+full_name(type.name));
            return object_type_as_type(new Object_Type(o.is_value_type, o.name, o.generic_parameters, o.generic_arguments, o.is_potentially_mutable, true));
        }
    }
    UNREACHABLE();
}

public make_immutable_type(type: Type) -> Type
{
    match type
    {
        ns: Namespace_Type => { return namespace_type_as_type(ns); },
        f: Function_Type => { return function_type_as_type(f); },
        p: Primitive_Type => { return primitive_type_as_type(p); },
        o: Object_Type => { return object_type_as_type(new Object_Type(o.is_value_type, o.name, o.generic_parameters, o.generic_arguments, o.is_potentially_mutable, false)); },
    }
}

public apply_generic_arguments(type: Type, generic_arguments: system.collections.List<Type?>) -> Type
{
    match type
    {
        p: Primitive_Type =>
        {
            return primitive_type_as_type(new Primitive_Type(p.name, p.generic_parameters, apply_generic_arguments(p.generic_parameters, p.generic_arguments, generic_arguments), p.is_potentially_mutable, p.is_mutable));
        },
        o: Object_Type =>
        {
            return object_type_as_type(new Object_Type(o.is_value_type, o.name, o.generic_parameters, apply_generic_arguments(o.generic_parameters, o.generic_arguments, generic_arguments), o.is_potentially_mutable, o.is_mutable));
        }
    }
}

public apply_generic_arguments(
    generic_parameters: system.collections.List<Generic_Parameter>,
    existing_generic_arguments: system.collections.List<Type?>,
    generic_arguments: system.collections.List<Type?>)
    -> system.collections.List<Type?>
{
    // TODO deal with existing arguments
    // for let argument: Type? in existing_generic_arguments
    // {
    //     assert(argument == none);
    // }

    assert(generic_parameters.count == generic_arguments.count);

    return generic_arguments;
}
