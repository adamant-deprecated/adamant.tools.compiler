/// Binds semantic nodes to their referenced symbols and types
public class Old_Semantic_Binder
{
	public bind(self, package: Old_Package) -> void
	{
		// TODO we are assuming there is only the package references we are expecting
		assert(|package.references| == 2, "package=" + package.name.unqualified);

		let primitive_package: Old_Package = package.references[0].package;
		assert(primitive_package.name.unqualified == "$primitives", "package name='" + primitive_package.name.unqualified + "'");

		let runtime_package: Old_Package = package.references[1].package;
		assert(runtime_package.name.unqualified == "$runtime", "package name='" + runtime_package.name.unqualified + "'");

		let primitives: System.Collections.List<Old_Symbol> = primitive_package.symbol.children;
		assert(|primitives| > 0, "|primitives|=" + |primitives|);

		let runtime_symbols: System.Collections.List<Old_Symbol> = runtime_package.symbol.children;
		assert(|runtime_symbols| > 0, "|runtime_symbols|=" + |runtime_symbols|);

		// TODO this is a hacky way to get both the primitives and runtime lib symbols in scope
		var global_scope: Old_Binding_Scope = new Old_Binding_Scope(package.symbol.children, primitives);
		global_scope = new Old_Binding_Scope(global_scope, runtime_symbols);

		for let compilation_unit: mut Old_Semantic_Node in package.compilation_units
		{
			bind(compilation_unit, global_scope);
		}
	}

	private bind(self, node: mut Old_Semantic_Node, scope: Old_Binding_Scope) -> void
	{
		if node.kind == CompilationUnit
		{
			for let child: mut Old_Semantic_Node in node.children
			{
				bind(child, scope);
			}
		}
		else if node.kind == FunctionDeclaration
			or node.kind == MethodDeclaration
		{
			let parameters: mut Old_Semantic_Node = node.first_child(ParameterList);
			bind(parameters, scope);

			let return_type: mut Old_Semantic_Node = node.children[4];
			bind_type_name(return_type, scope);

			let function_scope: Old_Binding_Scope = new Old_Binding_Scope(scope, node.symbol.children);
			let body: mut Old_Semantic_Node = node.first_child(Block);
			bind(body, function_scope);
		}
		else if node.kind == ParameterList
		{
			for let parameter: mut Old_Semantic_Node in node.children_of_kind(Parameter)
			{
				bind(parameter, scope);
			}
		}
		else if node.kind == Parameter
		{
			let type_node: mut Old_Semantic_Node = node.children[|node.children| - 1];
			bind_type_name(type_node, scope);
		}
		else if node.kind == ClassDeclaration
			or node.kind == StructDeclaration
		{
			let type_scope: Old_Binding_Scope = new Old_Binding_Scope(scope, node.symbol.children);
			for let member: mut Old_Semantic_Node in node.members()
			{
				bind(member, type_scope);
			}
		}
		else if node.kind == FieldDeclaration
			or node.kind == GlobalDeclaration
		{
			let variable_declaration: mut Old_Semantic_Node = node.first_child(VariableDeclaration);
			bind(variable_declaration, scope);
		}
		else if node.kind == ConstructorDeclaration
		{
			let parameters: mut Old_Semantic_Node = node.first_child(ParameterList);
			bind(parameters, scope);

			let constructor_scope: Old_Binding_Scope = new Old_Binding_Scope(scope, node.symbol.children);
			let body: mut Old_Semantic_Node = node.first_child(Block);
			bind(body, constructor_scope);
		}
		else if node.kind == VariableDeclaration
		{
			let identifier: mut Old_Semantic_Node = node.first_child(Identifier);
			assert(identifier =/= none, "for '"+node.get_text()+"'");
			let type_name: mut Old_Semantic_Node = node.children[3];
			bind_type_name(type_name, scope);
			if |node.children| == 6
			{
				let initalizer: mut Old_Semantic_Node = node.children[5];
				bind(initalizer, scope);
			}
			if type_name.type == none
			{
				add_could_not_determine_type_error(type_name);
				return;
			}
			identifier.bind_type(type_name.type);
			node.bind_type(type_name.type);
		}
		else if node.kind == EnumDeclaration
		{
			// Haven't yet implemented anything in enums that requires name binding
		}
		else if node.kind == Block
		{
			for let statement: mut Old_Semantic_Node in node.statements()
			{
				bind(statement, scope);
			}
		}
		else if node.kind == LoopStatement
		{
			bind(node.first_child(Block), scope);
		}
		else if node.kind == WhileStatement
		{
			bind(node.children[1], scope); // condition expression
			bind(node.first_child(Block), scope);
		}
		else if node.kind == DoWhileStatement
		{
			bind(node.first_child(Block), scope);
			bind(node.children[3], scope); // condition expression
		}
		else if node.kind == ForStatement
		{
			bind(node.first_child(VariableDeclaration), scope);
			bind(node.first_child(Block), scope);
		}
		else if node.kind == LocalDeclarationStatement
		{
			let variable_declaration: mut Old_Semantic_Node = node.first_child(VariableDeclaration);
			bind(variable_declaration, scope);
			if variable_declaration.type == none
			{
				add_could_not_determine_type_error(variable_declaration);
				return;
			}
			node.bind_type(variable_declaration.type);
		}
		else if node.kind == IfStatement
		{
			bind(node.children[1], scope); // condition expression
			bind(node.first_child(Block), scope);
			let else_clause: mut Old_Semantic_Node? = node.first_child(ElseClause);
			if else_clause =/= none
			{
				bind(else_clause, scope);
			}
		}
		else if node.kind == ElseClause
		{
			// This might be a good place for some kind of coalesce operator
			let block: mut Old_Semantic_Node? = node.first_child(Block);
			if block =/= none
			{
				bind(block, scope);
			}
			else
			{
				bind(node.first_child(IfStatement), scope);
			}
		}
		else if node.kind == ExpressionStatement
		{
			bind(node.children[0], scope);
		}
		else if node.kind == ReturnStatement
		{
			let child: mut Old_Semantic_Node = node.children[1];
			if child.kind =/= Semicolon
				{ bind(child, scope); }
		}
		else if node.kind == NewExpression
		{
			bind_constructor_name(node.children[1], scope); // Type
			bind(node.children[2], scope); // Call Arguments
		}
		else if node.kind == NotExpression
			or node.kind == ParenthesizedExpression
			or node.kind == MagnitudeExpression
			or node.kind == NegateExpression
		{
			bind(node.children[1], scope);
		}
		else if node.kind == AssignmentExpression
			or node.kind == AndExpression
			or node.kind == OrExpression
			or node.kind == EqualExpression
			or node.kind == NotEqualExpression
			or node.kind == ComparisonExpression
			or node.kind == AddExpression
			or node.kind == SubtractExpression
			or node.kind == ElementAccessExpression
			or node.kind == RemainderExpression
			or node.kind == MultiplyExpression
			or node.kind == DivideExpression
		{
			bind(node.children[0], scope); // lhs
			bind(node.children[2], scope); // rhs
		}
		else if node.kind == MemberAccessExpression
		{
			bind(node.children[0], scope); // Before dot
			// TODO bind member, need type of expression to left
		}
		else if node.kind == InvocationExpression
		{
			bind(node.children[0], scope); // Thing Being Invoked
			bind(node.children[1], scope); // Argument List
		}
		else if node.kind == ArgumentList
		{
			for let child: mut Old_Semantic_Node in node.children
			{
				if child.kind =/= LeftParen
					and child.kind =/= Comma
					and child.kind =/= RightParen
				{
					bind(child, scope);
				}
			}
		}
		else if node.kind == IdentifierName
		{
			if node.is_missing { return; }
			let name: string = node.get_text();
			let symbol: Old_Symbol = scope.lookup(name);
			if symbol == none
			{
				add_resolution_error(node);
			}
			else
			{
				node.bind_symbol(symbol);
				var type: Type? = symbol.declares_type;
				if type =/= none
					{ node.bind_type(type); }
				type = symbol.of_type;
				// TODO save this as a different kind of type on the name
				if type =/= none
					{ node.bind_type(type); }
				if |symbol.declarations| > 0
				{
					type = symbol.declarations[0].type;
					if type =/= none
						{ node.bind_type(type); }
				}
			}
		}
		else if node.kind == TrueLiteralExpression
			or node.kind == FalseLiteralExpression
		{
			node.bind_type(scope.lookup_special("bool").declares_type);
		}
		else if node.kind == StringLiteralExpression
		{
			node.bind_type(scope.lookup_special("string").declares_type);
		}
		else if node.kind == CodePointLiteralExpression
		{
			node.bind_type(scope.lookup_special("code_point").declares_type);
		}
		else if node.kind == NumericLiteralExpression
		{
			node.bind_type(scope.lookup_special("int").declares_type);
		}
		else if node.kind == SelfExpression
		{
			// TODO include this
			// node.bind_type(scope.lookup_special("self").declares_type);
		}
		else if node.kind == BreakStatement
			or node.kind == ContinueStatement
			or node.kind == NoneLiteralExpression
			or node.kind == EndOfFileToken
		{
			// Ignore these nodes
		}
		else
		{
			THROW_EXCEPTION("`Semantic_Binder.bind()` unimplemented node type " + node.kind);
		}
	}

	private bind_type_name(self, node: mut Old_Semantic_Node, scope: Old_Binding_Scope) -> void
	{
		if node.kind == PredefinedType
		{
			let primitive_name: string = node.children[0].get_text();
			let symbol: Old_Symbol = scope.lookup_special(primitive_name);
			if symbol == none { THROW_EXCEPTION("`Semantic_Binder.bind_type_name()` no symbol for primitive type " + primitive_name); }
			node.bind_symbol(symbol);
			node.bind_type(symbol.declares_type);
		}
		else if node.kind == MutableType
		{
			let inner_type_node: mut Old_Semantic_Node = node.children[1];
			bind_type_name(inner_type_node, scope);
			if inner_type_node.type == none
			{
				add_could_not_determine_type_error(inner_type_node);
				return;
			}
			node.bind_type(inner_type_node.type.make_mutable());
		}
		else if node.kind == ImmutableType
		{
			let inner_type_node: mut Old_Semantic_Node = node.children[0];
			bind_type_name(inner_type_node, scope);
			if inner_type_node.type == none
			{
				add_could_not_determine_type_error(inner_type_node);
				return;
			}
			node.bind_type(inner_type_node.type.make_immutable());
		}
		else if node.kind == OptionalType
		{
			let inner_type_node: mut Old_Semantic_Node = node.children[0];
			bind_type_name(inner_type_node, scope);
			if inner_type_node.type == none
			{
				add_could_not_determine_type_error(inner_type_node);
				return;
			}
			node.bind_type(inner_type_node.type.make_immutable());
		}
		else if node.kind == QualifiedName
		{
			let qualifier: mut Old_Semantic_Node = node.children[0];
			bind_type_name(qualifier, scope);

			let name_node: mut Old_Semantic_Node = node.children[2];
			if qualifier.type == none
			{
				// Skip because this means we aren't sure about the qualifier (i.e. type unknown)
				//add_could_not_determine_type_error(qualifier);
			}
			else if qualifier.symbol == none
			{
				// Skip because this means we aren't sure about the qualifier (i.e. type unknown)
				//add_resolution_error(name);
			}
			else if name_node.kind == IdentifierName
			{
				let symbol: Old_Symbol = qualifier.symbol.get(name_node.get_text(), IdentifierSymbol);
				if symbol == none
				{
					add_resolution_error(name_node);
				}
				else
				{
					name_node.bind_symbol(symbol);
					// TODO transition away from using symbols at higher levels, use types instead
					node.bind_symbol(symbol); // Set it on the name as a whole, not just the identifier

					let type: Type? = symbol.declares_type;
					assert(type =/= none, "symbol.name="+symbol.name);
					name_node.bind_type(type);
					node.bind_type(type);
				}
			}
			else if name_node.kind == GenericName
			{
				let identifer_name: mut Old_Semantic_Node = name_node.first_child(IdentifierName);
				let symbol: Old_Symbol = qualifier.symbol.get(identifer_name.get_text(), IdentifierSymbol);
				if symbol == none
				{
					add_resolution_error(name_node);
					return;
				}
				identifer_name.bind_symbol(symbol);

				// TODO transition away from using symbols at higher levels, use types instead
				node.bind_symbol(symbol); // Set it on the name as a whole, not just the identifier

				// TODO need way to get the generic type arguments
				var type_arg: bool = false;
				for let type_argument: mut Old_Semantic_Node in name_node.children
				{
					if type_arg
					{
						if type_argument.kind =/= GreaterThan
						{
							bind_type_name(type_argument, scope);
						}
					}
					else if type_argument.kind == LessThan
					{
						type_arg = true;
					}
				}

				let type: Type? = symbol.declares_type;
				assert(type =/= none, "symbol.name="+symbol.name);
				identifer_name.bind_type(type);
				// TODO the type of the node should account for the generic type parameters
				node.bind_type(type); // Set it on the name as a whole, not just the identifier
			}
			else
			{
				THROW_EXCEPTION("Unreachable: `Semantic_Binder.bind(..)` name.kind = " + name_node.kind);
			}
		}
		else if node.kind == IdentifierName
		{
			if node.is_missing { return; }
			let name: string = node.get_text();
			let symbol: Old_Symbol = scope.lookup(name); // TODO this should be lookup type. Types are separate
			if symbol == none
			{
				add_resolution_error(node);
			}
			else
			{
				node.bind_symbol(symbol);
				assert(symbol.declares_type =/= none, "symbol.name="+symbol.name);
				node.bind_type(symbol.declares_type);
			}
		}
		else
		{
			THROW_EXCEPTION("`Semantic_Binder.bind_type_name()` unimplemented node type " + node.kind);
		}
	}


	private bind_constructor_name(self, node: mut Old_Semantic_Node, scope: Old_Binding_Scope) -> void
	{
		if node.kind == QualifiedName
			and node.children[2].kind == IdentifierName
		{
			// It could be a named constructor call
			bind_type_name(node.children[0], scope);
			let qualifier: mut Old_Semantic_Node = node.children[0];
			let name: mut Old_Semantic_Node = node.children[2];
			let constructor_name: string = "new_" + name.get_text();
			let constructor_symbol: Old_Symbol? = qualifier.symbol.get(constructor_name, Old_SpecialSymbol);
			if constructor_symbol =/= none
			{
				name.bind_symbol(constructor_symbol);
				// TODO it doesn't have a type does it?
			}
			else
			{
				// TODO this is duplicated from bind_type_name
				let symbol: Old_Symbol = qualifier.symbol.get(name.get_text(), IdentifierSymbol);
				if symbol == none
				{
					add_resolution_error(name);
				}
				else
				{
					name.bind_symbol(symbol);
					name.bind_type(symbol.declares_type);
					node.bind_type(symbol.declares_type);
					// TODO transition away from using symbols at higher levels, use types instead
					node.bind_symbol(symbol); // Set it on the name as a whole, not just the identifier
				}
			}
		}
		else
			{ bind_type_name(node, scope); }
	}

	private add_resolution_error(node: Old_Semantic_Node) -> void
	{
		node.add(new Diagnostic(FatalCompilationError, Analysis, node.source, node.get_text_span(), "Could not resolve name `" + node.get_text() + "`"));
	}

	private add_could_not_determine_type_error(node: Old_Semantic_Node) -> void
	{
		node.add(new Diagnostic(FatalCompilationError, Analysis, node.source, node.get_text_span(), "Could not determine type for `" + node.get_text() + "`"));
	}
}
