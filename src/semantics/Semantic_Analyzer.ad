public analyze_semantics(package_syntax: Syntax_Node) -> Package
{
    assert(package_syntax.kind == PackageNode, "package_syntax.kind=" + int_to_string(package_syntax.kind));

    // Hard code a stand-in package-name for now
    let name: Package_Name = new Package_Name("default");
    let primitives_package: Package = build_primitives_package();
    let runtime_package: Package = build_runtime_library_package();
    let references: mut system.collections.List<Package_Reference> = new system.collections.List<Package_Reference>();
    add_item(references, new Package_Reference(primitives_package));
    add_item(references, new Package_Reference(runtime_package));

    let annotations: mut Annotations_Dictionary = new Annotations_Dictionary(package_syntax);
    let _package_syntax_symbol: Syntax_Symbol = get_declared_type_symbols(package_syntax, name, annotations);
    let name_table: Name_Table = build_symbol_table(name, package_syntax, references, annotations);
    bind_declaration_types(package_syntax, name_table);
    let semantic_tree_builder: Semantic_Tree_Builder = new Semantic_Tree_Builder();
    let compilation_units: system.collections.List<Compilation_Unit> = build_compilation_units(semantic_tree_builder, package_syntax, name_table);
    let package_symbol: Symbol = build_symbols(name, compilation_units);
    let package: Package = new Package(name, references, compilation_units, package_symbol);

    return package;
}
