public compile(sources: system.collections.List<Source_Text>) -> Package
{
    let parser: Parser = new Parser();
    let package_syntax: Syntax_Node = parser.ParsePackage(sources);
    let semantic_analyzer: Semantic_Analyzer = new Semantic_Analyzer();
    let package: Package = semantic_analyzer.analyze(package_syntax);
    return package;
}

public write(console: mut system.console.Console, diagnostics: system.collections.List<Diagnostic>) -> void
{
    for let diagnostic: Diagnostic in diagnostics
    {
        let position: Text_Position = diagnostic.Position;
        var severity: string;
        if diagnostic.Level == Info
            { severity = "Informational"; }
        else if diagnostic.Level == Warning
            { severity = "Warning"; }
        else
            { severity = "Error"; }

        console.WriteLine(diagnostic.source.Path+":"+position.line+":"+position.column+" "+severity+":");
        console.WriteLine("  "+diagnostic.Message);
    }
}

public has_errors(diagnostics: system.collections.List<Diagnostic>) -> bool
{
    for let diagnostic: Diagnostic in diagnostics
    {
        if diagnostic.Level >= CompilationError
        {
            return true;
        }
    }
    return false;
}

// based on sysexits.h
public let Success: int = 0;
public let UsageError: int = 64;
public let DataError: int = 65;

public main(console: mut system.console.Console, args: system.console.Arguments) -> int
{
    if |args| == 1 and args[0] == "--unit-test"
    {
        run_unit_tests(console);
        return 0;
    }

    let sourceFilePaths: mut system.collections.List<string> = new system.collections.List<string>();
    let resourceFilePaths: mut system.collections.List<string> = new system.collections.List<string>();
    var outputFilePath: string = "";
    var verbose: bool = false;
    var argType: int = 0; // 0=source file, 1=resource file, 2=output file
    for let arg: string in args
    {
        if argType == 0 // Not option value
        {
            if arg == "-r"
            {
                argType = 1;
            }
            else if arg == "-o"
            {
                argType = 2;
            }
            else if arg == "-v" or arg == "--verbose"
            {
                verbose = true;
            }
            else
            {
                sourceFilePaths.add(arg);
            }
        }
        else if argType == 1 // resource file
        {
            resourceFilePaths.add(arg);
            argType = 0;
        }
        else if argType == 2 // output file
        {
            outputFilePath = arg;
            argType = 0;
        }

        // else should be impossible
    }

    if verbose
    {
        console.WriteLine("Adamant Compiler v0.1.0");
    }
    if |sourceFilePaths| == 0 or outputFilePath == ""
    {
        console.WriteLine("Args: <Input File(s)> -o <OutputFile> -r <Resource File>");
        return UsageError;
    }

    // Read Resources
    let resources: mut system.collections.List<Source_Text> = new system.collections.List<Source_Text>();
    if |resourceFilePaths| > 0
    {
        if verbose
        {
            console.WriteLine("Reading Resources:");
        }
        for let resourceFilePath: string in resourceFilePaths
        {
            if verbose
            {
                console.WriteLine("  " + resourceFilePath);
            }
            resources.add(read_source(resourceFilePath));
        }
    }

    // Read Source(s)
    if(verbose)
    {
        console.WriteLine("Compiling:");
    }
    let sources: mut system.collections.List<Source_Text> = new system.collections.List<Source_Text>();
    for let sourceFilePath: string in sourceFilePaths
    {
        if(verbose)
        {
            console.WriteLine("  " + sourceFilePath);
        }
        sources.add(read_source(sourceFilePath));
    }

    let package: Package = compile(sources);

    let diagnostics: system.collections.List<Diagnostic> = package.all_diagnostics();
    write(console, diagnostics);

    if has_errors(diagnostics)
    {
        return DataError;
    }

    var emitter: mut Emitter = new Emitter(package, resources);
    let translated: string = emitter.Emit();

    // Write output
    if verbose
    {
        console.Write("Output: ");
        console.WriteLine(outputFilePath);
    }
    // TODO should be `new mut`
    let outputFile: mut system.io.File_Writer = new system.io.File_Writer(outputFilePath);
    outputFile.Write(translated);
    outputFile.Close();

    // Write RuntimeLibrary
    var outputDirPath: string = outputFilePath;
    var index: int = outputDirPath.LastIndexOf('/');
    if index =/= -1
        { outputDirPath = outputDirPath.Substring(0, index+1); }
    index = outputDirPath.LastIndexOf('\\');
    if index =/= -1
        { outputDirPath = outputDirPath.Substring(0, index+1); }
    if verbose
    {
        console.Write("Outputting RuntimeLibrary to: ");
        console.WriteLine(outputDirPath);
    }
    var resourceFile: mut system.io.File_Writer = new system.io.File_Writer(outputDirPath+"RuntimeLibrary.hpp");
    resourceFile.Write(resource_manager.GetString("RuntimeLibrary.hpp"));
    resourceFile.Close();
    resourceFile = new system.io.File_Writer(outputDirPath+"RuntimeLibrary.cpp");
    resourceFile.Write(resource_manager.GetString("RuntimeLibrary.cpp"));
    resourceFile.Close();

    return Success;
}

public read_source(path: string) -> Source_Text
{
    // TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
    let file: mut system.io.File_Reader = new system.io.File_Reader(path);
    let contents: string = file.ReadToEndSync();
    file.Close(); // TODO this should automatically be handled
    return new Source_Text("<default>", path, contents);
}
