public compile(sources: system.collections.List<Source_Text>) -> Package
{
    let package_syntax: Syntax_Node = parse_package(sources);
    let package: Package = analyze_semantics(package_syntax);
    return package;
}

public write(console: mut system.console.Console, diagnostics: system.collections.List<Diagnostic>) -> void
{
    for let diagnostic: Diagnostic in diagnostics
    {
        let position: Text_Position = diagnostic.position;
        var severity: string;
        if diagnostic.level == Info
            { severity = "Informational"; }
        else if diagnostic.level == Warning
            { severity = "Warning"; }
        else
            { severity = "Error"; }

        console.WriteLine(diagnostic.source.path+":"+int_to_string(position.line)+":"+int_to_string(position.column)+" "+severity+":");
        console.WriteLine("  "+diagnostic.message);
    }
}

public has_errors(diagnostics: system.collections.List<Diagnostic>) -> bool
{
    for let diagnostic: Diagnostic in diagnostics
    {
        if diagnostic.level >= CompilationError
        {
            return true;
        }
    }
    return false;
}

// based on sysexits.h
public let Success: int = 0;
public let UsageError: int = 64;
public let DataError: int = 65;

public main(console: mut system.console.Console, args: system.console.Arguments) -> int
{
    if |args| == 1 and args[0] == "--unit-test"
    {
        run_unit_tests(console);
        return 0;
    }

    let sourceFilePaths: mut Strings = new Strings();
    let resourceFilePaths: mut Strings = new Strings();
    var outputFilePath: string = "";
    var verbose: bool = false;
    var argType: int = 0; // 0=source file, 1=resource file, 2=output file
    for let arg: string in args
    {
        if argType == 0 // Not option value
        {
            if arg == "-r"
            {
                argType = 1;
            }
            else if arg == "-o"
            {
                argType = 2;
            }
            else if arg == "-v" or arg == "--verbose"
            {
                verbose = true;
            }
            else
            {
                add_string(sourceFilePaths, arg);
            }
        }
        else if argType == 1 // resource file
        {
            add_string(resourceFilePaths, arg);
            argType = 0;
        }
        else if argType == 2 // output file
        {
            outputFilePath = arg;
            argType = 0;
        }

        // else should be impossible
    }

    if verbose
    {
        console.WriteLine("Adamant Compiler v0.1.0");
    }
    if sourceFilePaths.count == 0 or outputFilePath == ""
    {
        console.WriteLine("Args: <Input File(s)> -o <OutputFile> -r <Resource File>");
        return UsageError;
    }

    // Read Resources
    let resources: mut system.collections.List<Source_Text> = new system.collections.List<Source_Text>();
    if resourceFilePaths.count > 0
    {
        if verbose
        {
            console.WriteLine("Reading Resources:");
        }
        for let resourceFilePath: string in resourceFilePaths
        {
            if verbose
            {
                console.WriteLine("  " + resourceFilePath);
            }
            resources.add(read_source(resourceFilePath));
        }
    }

    // Read Source(s)
    if(verbose)
    {
        console.WriteLine("Compiling:");
    }
    let sources: mut system.collections.List<Source_Text> = new system.collections.List<Source_Text>();
    for let sourceFilePath: string in sourceFilePaths
    {
        if(verbose)
        {
            console.WriteLine("  " + sourceFilePath);
        }
        sources.add(read_source(sourceFilePath));
    }

    let package: Package = compile(sources);

    let diagnostics: system.collections.List<Diagnostic> = all_diagnostics(package);
    write(console, diagnostics);

    if has_errors(diagnostics)
    {
        return DataError;
    }

    var emitter: mut Emitter = new Emitter(package, resources);
    let translated: string = emit(emitter);

    // Write output
    if verbose
    {
        console.Write("Output: ");
        console.WriteLine(outputFilePath);
    }
    // TODO should be `new mut`
    let outputFile: mut system.io.File_Writer = new system.io.File_Writer(outputFilePath);
    outputFile.Write(translated);
    outputFile.Close();

    // Write RuntimeLibrary
    var outputDirPath: string = outputFilePath;
    var index: int = string_last_index_of(outputDirPath, '/');
    if index =/= -1
        { outputDirPath = substring(outputDirPath, 0, index+1); }
    index = string_last_index_of(outputDirPath, '\\');
    if index =/= -1
        { outputDirPath = substring(outputDirPath, 0, index+1); }
    if verbose
    {
        console.Write("Outputting RuntimeLibrary to: ");
        console.WriteLine(outputDirPath);
    }
    var resourceFile: mut system.io.File_Writer = new system.io.File_Writer(outputDirPath+"RuntimeLibrary.hpp");
    resourceFile.Write(get_resource("RuntimeLibrary.hpp"));
    resourceFile.Close();
    resourceFile = new system.io.File_Writer(outputDirPath+"RuntimeLibrary.cpp");
    resourceFile.Write(get_resource("RuntimeLibrary.cpp"));
    resourceFile.Close();

    return Success;
}

public read_source(path: string) -> Source_Text
{
    // TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
    let file: mut system.io.File_Reader = new system.io.File_Reader(path);
    let contents: string = file.ReadToEndSync();
    file.Close(); // TODO this should automatically be handled
    return new Source_Text("<default>", path, contents);
}
