public Compile(sources: System.Collections.List<Source_Text>) -> Package
{
	let parser: Parser = new Parser();
	let packageSyntax: Syntax_Node = parser.ParsePackage(sources);
	let symbolBuilder: Symbol_Builder = new Symbol_Builder();
	let packageSymbol: Symbol = symbolBuilder.BuildSymbols(packageSyntax);
	let package: Package = new Package(packageSyntax, packageSymbol);
	return package;
}

public Write(console: mut System.Console.Console, diagnostics: System.Collections.List<Diagnostic>) -> void
{
	for let diagnostic: Diagnostic in diagnostics
	{
		let position: Text_Position = diagnostic.Position;
		var severity: string;
		if diagnostic.Level == Info
			{ severity = "Informational"; }
		else if diagnostic.Level == Warning
			{ severity = "Warning"; }
		else
			{ severity = "Error"; }

		console.WriteLine(diagnostic.Source.Path+":"+position.Line+":"+position.Column+" "+severity+":");
		console.WriteLine("  "+diagnostic.Message);
	}
}

public HasErrors(diagnostics: System.Collections.List<Diagnostic>) -> bool
{
	for let diagnostic: Diagnostic in diagnostics
	{
		if diagnostic.Level >= CompilationError
		{
			return true;
		}
	}
	return false;
}

public Emit(package: Package, resources: System.Collections.List<Source_Text>) -> string
{
	EmitPreamble();
	EmitPackage(package);
	EmitEntryPointAdapter(resources);

	return TypeDeclarations.ToString()
		+ FunctionDeclarations.ToString()
		+ ClassDeclarations.ToString()
		+ GlobalDefinitions.ToString()
		+ Definitions.ToString();
}

// based on sysexits.h
public let Success: int = 0;
public let UsageError: int = 64;
public let DataError: int = 65;

public Main(console: mut System.Console.Console, args: System.Console.Arguments) -> int
{
	let sourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	let resourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	var outputFilePath: string = "";
	var verbose: bool = false;
	var argType: int = 0; // 0=source file, 1=resource file, 2=output file
	for let arg: string in args
	{
		if argType == 0 // Not option value
		{
			if arg == "-r"
			{
				argType = 1;
			}
			else if arg == "-o"
			{
				argType = 2;
			}
			else if arg == "-v" or arg == "--verbose"
			{
				verbose = true;
			}
			else
			{
				sourceFilePaths.Add(arg);
			}
		}
		else if argType == 1 // resource file
		{
			resourceFilePaths.Add(arg);
			argType = 0;
		}
		else if argType == 2 // output file
		{
			outputFilePath = arg;
			argType = 0;
		}

		// else should be impossible
	}

	if(verbose)
	{
		console.WriteLine("Adamant Compiler v0.1.0");
	}
	if |sourceFilePaths| == 0 or outputFilePath == ""
	{
		console.WriteLine("Args: <Input File(s)> -o <OutputFile> -r <Resource File>");
		return UsageError;
	}

	// Read Resources
	let resources: mut System.Collections.List<Source_Text> = new System.Collections.List<Source_Text>();
	if |resourceFilePaths| > 0
	{
		if(verbose)
		{
			console.WriteLine("Reading Resources:");
		}
		for let resourceFilePath: string in resourceFilePaths
		{
			if(verbose)
			{
				console.WriteLine("  " + resourceFilePath);
			}
			resources.Add(ReadSource(resourceFilePath));
		}
	}

	// Read Source(s)
	if(verbose)
	{
		console.WriteLine("Compiling:");
	}
	let sources: mut System.Collections.List<Source_Text> = new System.Collections.List<Source_Text>();
	for let sourceFilePath: string in sourceFilePaths
	{
		if(verbose)
		{
			console.WriteLine("  " + sourceFilePath);
		}
		sources.Add(ReadSource(sourceFilePath));
	}

	let package: Package = Compile(sources);

	let diagnostics: System.Collections.List<Diagnostic> = package.AllDiagnostics();
	Write(console, diagnostics);

	if HasErrors(diagnostics)
	{
		return DataError;
	}

	let translated: string = Emit(package, resources);

	// Write output
	if(verbose)
	{
		console.Write("Output: ");
		console.WriteLine(outputFilePath);
	}
	// TODO should be `new mut`
	let outputFile: mut System.IO.File_Writer = new System.IO.File_Writer(outputFilePath);
	outputFile.Write(translated);
	outputFile.Close();

	// Write RuntimeLibrary
	var outputDirPath: string = outputFilePath;
	var index: int = outputDirPath.LastIndexOf('/');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	index = outputDirPath.LastIndexOf('\\');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	if(verbose)
	{
		console.Write("Outputting RuntimeLibrary to: ");
		console.WriteLine(outputDirPath);
	}
	var resourceFile: mut System.IO.File_Writer = new System.IO.File_Writer(outputDirPath+"RuntimeLibrary.h");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.h"));
	resourceFile.Close();
	resourceFile = new System.IO.File_Writer(outputDirPath+"RuntimeLibrary.cpp");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.cpp"));
	resourceFile.Close();

	return Success;
}

public ReadSource(path: string) -> Source_Text
{
	// TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
	let file: mut System.IO.File_Reader = new System.IO.File_Reader(path);
	let contents: string = file.ReadToEndSync();
	file.Close(); // TODO this should automatically be handled
	return new Source_Text("<default>", path, contents);
}
