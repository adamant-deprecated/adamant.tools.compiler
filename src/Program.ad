public var tokenStream: mut Token_Stream = null;
public var Token: Syntax_Node = null;

public let TypeDeclarations: mut Source_File_Builder = new Source_File_Builder();
public let FunctionDeclarations: mut Source_File_Builder = new Source_File_Builder();
public let ClassDeclarations: mut Source_File_Builder= new Source_File_Builder();
public let GlobalDefinitions: mut Source_File_Builder = new Source_File_Builder();
public let Definitions: mut Source_File_Builder = new Source_File_Builder();

public var MainFunctionReturnType: string = "";
public var MainFunctionAcceptsConsole: bool = false;
public var MainFunctionAcceptsArgs: bool = false;

// ----------------------------------------------------------------------------
// Token Handling
// ----------------------------------------------------------------------------

public AcceptToken() -> Syntax_Node
{
	let node: Syntax_Node = Token;
	Token = tokenStream.GetNextToken();
	return node;
}

public ExpectToken(tokenType: int) -> Syntax_Node
{
	if Token.Type <> tokenType
	{
		// TODO the tokenType isn't being properly converted to a string here
		Definitions.Error("Expected token type " + tokenType + ", found `" + Token.GetText() + "` of type " + Token.Type);
		Token = tokenStream.GetNextToken(); // Skip token to advance
		return new Syntax_Node(Error, Token.Source, Token.Start, Token.Length);
	}

	let node: Syntax_Node = Token;
	Token = tokenStream.GetNextToken();
	return node;
}

public Accept(expected: string) -> bool
{
	let accepted: bool = Token.GetText() == expected;
	if accepted { Token = tokenStream.GetNextToken(); }
	return accepted;
}

public Expect(expected: string) -> void
{
	if Token.GetText() <> expected
	{
		Definitions.Error("Expected `" + expected + "` but found `" + Token.GetText() + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
	}
	else
	{
		Token = tokenStream.GetNextToken();
	}
}

// ----------------------------------------------------------------------------
// Emitting C++
// ----------------------------------------------------------------------------

public IsValueType(type: Syntax_Node) -> bool
{
	// Here we assume that they follow convention and value types start lowercase
	if type.Type == PredefinedType
	{
		return true;
	}
	if type.Type == NullableType
	{
		// The first child is the basic type
		return IsValueType(type.Children.Get(0)); // The type that is nullable
	}
	if type.Type == QualifiedName
	{
		// The last child is the real type
		return IsValueType(type.Children.Get(type.Children.Length()-1));
	}
	if type.Type == GenericName
	{
		let firstChar: code_point = type.FirstChildOfType(IdentifierName).FirstChildOfType(Identifier).GetText()[0];
		return firstChar >= 'a' and firstChar <= 'z';
	}
	if type.Type == IdentifierName
	{
		let firstChar: code_point = type.FirstChildOfType(Identifier).GetText()[0];
		return firstChar >= 'a' and firstChar <= 'z';
	}
	if type.Type == MutableType
	{
		return IsValueType(type.Children.Get(1)); // The type that is mutable
	}

	// TODO Error
	return true; // The value true is more likely to cause some kind of compiler error in the emitted source that we will notice
}

// Converts a type to C++
public ConvertType(type: Syntax_Node) -> string
{
	if type.Type == PredefinedType
	{
		let keyword: Syntax_Node = type.Children.Get(0);
		if keyword.Type == CodePoint
			{ return "char"; }
		if keyword.Type == UnsignedInt
			{ return "unsigned int"; }
		// Int, Bool, Void, String
		return keyword.GetText();
	}

	if type.Type == IdentifierName
	{
		return "::" + type.GetText() + "_";
	}
	if type.Type == QualifiedName
	{
		return ConvertType(type.Children.Get(0)) + ConvertType(type.Children.Get(2));
	}
	if type.Type == GenericName
	{
		return ConvertType(type.Children.Get(0)) + "<" + ConvertType(true, type.Children.Get(2)) + ">";
	}

	return FormatError("Unexpected Token of type "+type.Type+" found in CovertType(), `"+type.GetText()+"`");
}

// Converts a type to C++
public ConvertType(mutableBinding: bool, var type: Syntax_Node) -> string
{
	let nullable: bool = type.Type == NullableType;
	if nullable
	{
		type = type.Children.Get(0); // Remove the nullable wrapper
	}

	let mutableValue: bool = type.Type == MutableType;
	if mutableValue
	{
		type = type.Children.Get(1); // Remove the mutable wrapper
	}

	let isValueType: bool = IsValueType(type);
	var cppType: string = ConvertType(type);

	if isValueType
	{
		if nullable
			{ cppType = "::Maybe<" + cppType + ">"; }
		if not mutableBinding and not mutableValue
			{ cppType = cppType + " const"; }
	}
	else
	{
		if not mutableValue { cppType = cppType + " const"; }
		cppType = cppType + " *";
		if not mutableBinding { cppType = cppType + "const" ; }
	}

	return cppType;
}

public ConvertParameterList(parameterList: Syntax_Node, isMainFunction: bool) -> string
{
	let builder: mut System.Text.String_Builder = new System.Text.String_Builder();
	builder.Append("(");
	var firstParameter: bool = true;
	for let parameter: Syntax_Node in parameterList.Children
	{
		if parameter.Type == Parameter
		{
			if not firstParameter
				{ builder.Append(", "); }
			else
				{ firstParameter = false; }

			let mutableBinding: bool = parameter.HasChildOfType(VarKeyword);
			let type: Syntax_Node = parameter.Children.Get(parameter.Children.Length()-1);
			builder.Append(ConvertType(mutableBinding, type));
			builder.Append(" ");
			builder.Append(parameter.FirstChildOfType(Identifier).GetText());
			builder.Append("_");

			if isMainFunction
			{
				var typeString: string;
				if type.Type == MutableType
					{ typeString = type.Children.Get(1).GetText(); }
				else
					{ typeString = type.GetText(); }
				if typeString == "System.Console.Console"
					{ MainFunctionAcceptsConsole = true; }
				if typeString == "System.Console.Arguments"
					{ MainFunctionAcceptsArgs = true; }
			}
		}
	}
	builder.Append(")");
	return builder.ToString();
}

public ConvertParameterList(parameterList: Syntax_Node) -> string
{
	return ConvertParameterList(parameterList, false);
}

public ConvertExpression(syntax: Syntax_Node, builder: mut Source_File_Builder) -> void
{
	if syntax.Type == NewExpression
	{
		let type: Syntax_Node = syntax.Children.Get(1);
		if not IsValueType(type) // place value types on the stack in C++ by not using new
			{ builder.Write("new "); }
		builder.Write(ConvertType(type));
		let argumentList: Syntax_Node = syntax.Children.Get(2);
		ConvertExpression(argumentList, builder);
	}
	else if syntax.Type == ArgumentList
	{
		builder.Write("(");
		var firstExpression: bool = true;
		for let arg: Syntax_Node in syntax.Children
		{
			if arg.Type <> LeftParen
				and arg.Type <> RightParen
				and arg.Type <> Comma
			{
				if firstExpression
					{ firstExpression = false; }
				else
					{ builder.Write(", "); }
				ConvertExpression(arg, builder);
			}
		}
		builder.Write(")");
	}
	else if syntax.Type == NotExpression
	{
		builder.Write("!");
		ConvertExpression(syntax.Children.Get(1), builder);
	}
	else if syntax.Type == ParenthesizedExpression
	{
		builder.Write("(");
		ConvertExpression(syntax.Children.Get(1), builder);
		builder.Write(")");
	}
	else if syntax.Type == UnaryMinusExpression
	{
		builder.Write("-");
		ConvertExpression(syntax.Children.Get(1), builder);
	}
	else if syntax.Type == NullLiteralExpression
	{
		builder.Write("::None");
	}
	else if syntax.Type == SelfExpression
	{
		builder.Write("this");
	}
	else if syntax.Type == TrueLiteralExpression
		or syntax.Type == FalseLiteralExpression
		or syntax.Type == NumericLiteralExpression
		or syntax.Type == CodePointLiteralExpression
	{
		builder.Write(syntax.GetText());
	}
	else if syntax.Type == IdentifierName
	{
		builder.Write(syntax.GetText() + "_");
	}
	else if syntax.Type == StringLiteralExpression
	{
		builder.Write("string(" + syntax.GetText() + ")");
	}
	else if syntax.Type == AssignmentExpression
		or syntax.Type == EqualExpression
		or syntax.Type == ComparisionExpression
		or syntax.Type == AddExpression
		or syntax.Type == SubtractExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		builder.Write(" ");
		builder.Write(syntax.Children.Get(1).GetText());
		builder.Write(" ");
		ConvertExpression(syntax.Children.Get(2), builder);
	}
	else if syntax.Type == OrExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		builder.Write(" || ");
		ConvertExpression(syntax.Children.Get(2), builder);
	}
	else if syntax.Type == AndExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		builder.Write(" && ");
		ConvertExpression(syntax.Children.Get(2), builder);
	}
	else if syntax.Type == NotEqualExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		builder.Write(" != ");
		ConvertExpression(syntax.Children.Get(2), builder);
	}
	else if syntax.Type == InvocationExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		ConvertExpression(syntax.Children.Get(1), builder);
	}
	else if syntax.Type == MemberAccessExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		builder.Write("->");
		ConvertExpression(syntax.Children.Get(2), builder);
	}
	else if syntax.Type == ElementAccessExpression
	{
		ConvertExpression(syntax.Children.Get(0), builder);
		builder.Write("[");
		ConvertExpression(syntax.Children.Get(2), builder);
		builder.Write("]");
	}
	else
	{
		builder.Error("Could not convert expression of type " + syntax.Type);
	}
}

public EmitStatement(statement: Syntax_Node) -> void
{
	Definitions.StatementSeparatorLine();

	if statement.Type == ReturnStatement
	{

		if statement.Children.Length() == 2
			{ Definitions.WriteLine("return;"); }
		else
		{
			Definitions.BeginLine("return ");
			ConvertExpression(statement.Children.Get(1), Definitions);
			Definitions.EndLine(";");
		}
	}
	else if statement.Type == LoopStatement
	{
		Definitions.WriteLine("for (;;)");
		EmitStatement(statement.Children.Get(1)); // Block Statement
	}
	else if statement.Type == Block
	{
		Definitions.BeginBlock();
		for let blockStatement: Syntax_Node in statement.Children
		{
			if blockStatement.Type <> LeftBrace and blockStatement.Type <> RightBrace
			{
				EmitStatement(blockStatement);
			}
		}
		Definitions.EndBlock();
	}
	else if statement.Type == WhileStatement
	{
		Definitions.BeginLine("while (");
		ConvertExpression(statement.Children.Get(1), Definitions);
		Definitions.EndLine(")");
		EmitStatement(statement.Children.Get(2)); // Block Statement
	}
	else if statement.Type == ForStatement
	{
		Definitions.BeginLine("for (");
		//let k: string = Token.GetText();
		//if not Accept("let") and not Accept("var")
		//	{ Definitions.Error("Expected `let` or `var` but found `" + Token.GetText() + "`"); }
		let variableDeclaration: Syntax_Node = statement.Children.Get(1);
		let mutableBinding: bool = variableDeclaration.HasChildOfType(VarKeyword);
		let name: string = variableDeclaration.FirstChildOfType(Identifier).GetText();
		let type: Syntax_Node = variableDeclaration.Children.Get(3);
		Definitions.Write(ConvertType(mutableBinding, type) + " " + name + "_");
		Definitions.Write(" : *(");
		ConvertExpression(statement.Children.Get(3), Definitions); // expression
		Definitions.EndLine("))");
		EmitStatement(statement.Children.Get(4)); // Block Statement
	}
	else if statement.Type == DoWhileStatement
	{
		Definitions.WriteLine("do");
		EmitStatement(statement.Children.Get(1)); // Block Statement
		Definitions.BeginLine("while (");
		ConvertExpression(statement.Children.Get(3), Definitions);
		Definitions.EndLine(");");
	}
	else if statement.Type == IfStatement
	{
		var ifStatement: Syntax_Node = statement;
		Definitions.BeginLine("");
		loop
		{
			Definitions.Write("if (");
			ConvertExpression(ifStatement.Children.Get(1), Definitions);
			Definitions.EndLine(")");
			EmitStatement(ifStatement.Children.Get(2)); // Block Statement
			let elseClause: Syntax_Node = ifStatement.FirstChildOfType(ElseClause);
			if elseClause <> null
			{
				ifStatement = elseClause.FirstChildOfType(IfStatement);
				if ifStatement <> null
				{
					Definitions.BeginLine("else ");
				}
				else
				{
					Definitions.WriteLine("else");
					EmitStatement(elseClause.Children.Get(1)); // Block Statement
					break;
				}
			}
			else
				{ break; }
		}
	}
	else if statement.Type == BreakStatement
	{
		Definitions.WriteLine("break;");
	}
	else if statement.Type == ContinueStatement
	{
		Definitions.WriteLine("continue;");
	}
	else if statement.Type == LocalDeclarationStatement
	{
		let variableDeclaration: Syntax_Node = statement.Children.Get(0);
		let variableName: string = variableDeclaration.FirstChildOfType(Identifier).GetText();
		let variableType: Syntax_Node = variableDeclaration.Children.Get(3);
		let mutableBinding: bool = variableDeclaration.HasChildOfType(VarKeyword);
		Definitions.BeginLine(ConvertType(mutableBinding, variableType));
		Definitions.Write(" " + variableName + "_");
		if variableDeclaration.HasChildOfType(Assign)
		{
			Definitions.Write(" = ");
			ConvertExpression(variableDeclaration.Children.Get(5), Definitions);
		}
		Definitions.EndLine(";");
	}
	else if statement.Type == ExpressionStatement
	{
		Definitions.BeginLine("");
		ConvertExpression(statement.Children.Get(0), Definitions);
		Definitions.EndLine(";");
	}
	else
	{
		Definitions.Error("Could not emit statement of type " + statement.Type);
	}
}

public EmitClassMember(member: Syntax_Node, className: string) -> void
{
	if member.Type == ConstructorDeclaration
	{
		let parameters: string = ConvertParameterList(member.Children.Get(2));
		// Write out the function declaration for C++ so we can call functions defined after others
		ClassDeclarations.WriteLine(className + "_" + parameters + ";");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("::" + className + "_::" + className + "_" + parameters + "");
		EmitStatement(member.Children.Get(3));
	}
	else if member.Type == FieldDeclaration
	{
		let variableDeclaration: Syntax_Node = member.Children.Get(1);
		let fieldName: string = variableDeclaration.Children.Get(1).GetText();
		let fieldType: Syntax_Node = variableDeclaration.Children.Get(3);
		let cppType: string = ConvertType(true, fieldType); // because we need to assign them in constructors don't mark fields const
		ClassDeclarations.WriteLine(cppType + " " + fieldName + "_;");
	}
	else if member.Type == MethodDeclaration
	{
		let methodName: string = member.Children.Get(1).GetText();
		let parameterList: Syntax_Node = member.Children.Get(2);
		let parameters: string = ConvertParameterList(parameterList);
		let selfParameter: Syntax_Node = parameterList.FirstChildOfType(SelfParameter);
		let isAssociatedFuntion: bool = selfParameter == null;
		let mutableSelf: bool = not isAssociatedFuntion and selfParameter.HasChildOfType(MutableKeyword);
		let returnType: Syntax_Node = member.Children.Get(4);
		let cppType: string = ConvertType(true, returnType);
		var staticModifier: string = "";
		if isAssociatedFuntion
			{ staticModifier = "static "; }
		var constModifier: string = "";
		if not mutableSelf and not isAssociatedFuntion
			{ constModifier = "const "; }
		ClassDeclarations.WriteLine(staticModifier + "auto " + methodName + "_" + parameters + " " + constModifier + "-> " + cppType + ";");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("auto ::" + className + "_::" + methodName + "_" + parameters + " " + constModifier + "-> " + cppType);
		let block: Syntax_Node = member.Children.Get(5);
		EmitStatement(block);
	}
	else
	{
		Definitions.Error("Could not emit member of type " + member.Type);
	}
}

public EmitDeclaration(declaration: Syntax_Node) -> void
{
	if declaration.Type == GlobalDeclaration
	{
		let variableDeclaration: Syntax_Node = declaration.Children.Get(1);
		let variableName: string = variableDeclaration.Children.Get(1).GetText();
		let variableType: Syntax_Node = variableDeclaration.Children.Get(3);
		let mutableBinding: bool = variableDeclaration.HasChildOfType(VarKeyword);
		let cppType: string = ConvertType(mutableBinding, variableType);
		GlobalDefinitions.BeginLine(cppType);
		GlobalDefinitions.Write(" " + variableName + "_ = ");
		let expression: Syntax_Node = variableDeclaration.Children.Get(5);
		ConvertExpression(expression, GlobalDefinitions);
		GlobalDefinitions.EndLine(";");
	}
	else if declaration.Type == ClassDeclaration
	{
		let className: string = declaration.Children.Get(2).GetText();
		TypeDeclarations.WriteLine("class " + className + "_;");
		ClassDeclarations.ElementSeparatorLine();
		ClassDeclarations.WriteLine("class " + className + "_");
		ClassDeclarations.BeginBlock();
		ClassDeclarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
		for let member: Syntax_Node in declaration.Children
		{
			// TODO fix this to a more reliable means of telling what should be emitted
			if member.Type == ConstructorDeclaration
				or member.Type == FieldDeclaration
				or member.Type == MethodDeclaration
			{
				EmitClassMember(member, className);
			}
		}
		ClassDeclarations.EndBlockWithSemicolon();
	}
	else if declaration.Type == EnumDeclaration
	{
		let enumName: string = declaration.Children.Get(3).GetText();
		TypeDeclarations.WriteLine("enum class " + enumName + "_;");
		ClassDeclarations.ElementSeparatorLine();
		ClassDeclarations.WriteLine("enum class " + enumName + "_");
		ClassDeclarations.BeginBlock();
		for let member: Syntax_Node in declaration.Children
		{
			if member.Type == EnumMemberDeclaration
			{
				let memberName: string = member.Children.Get(0).GetText();
				ClassDeclarations.BeginLine(memberName + "_");
				let memberValue: Syntax_Node = member.FirstChildOfType(Number);
				if memberValue <> null
				{
					ClassDeclarations.Write(" = ");
					ClassDeclarations.Write(memberValue.GetText());
				}
				ClassDeclarations.EndLine(",");
			}
		}
		ClassDeclarations.EndBlockWithSemicolon();
	}
	else if declaration.Type == FunctionDeclaration
	{
		let name: string = declaration.Children.Get(1).GetText();
		let isMain: bool = name == "Main";
		let parameters: string = ConvertParameterList(declaration.Children.Get(2), isMain);
		let returnType: Syntax_Node = declaration.Children.Get(4);
		let cppType: string = ConvertType(true, returnType);
		// Write out the function declaration for C++ so we can call functions defined after others
		FunctionDeclarations.WriteLine("auto " + name + "_" + parameters + " -> " + cppType + ";");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("auto " + name + "_" + parameters + " -> " + cppType);
		if isMain
		{
			if MainFunctionReturnType <> ""
				{ Definitions.Error("Multiple declarations of main"); }
			MainFunctionReturnType = cppType;
		}
		EmitStatement(declaration.Children.Get(5));
	}
	else
	{
		Definitions.Error("Could not emit declaration of type " + declaration.Type);
	}
}

public EmitCompilationUnit(unit: Syntax_Node) -> void
{
	for let declaration: Syntax_Node in unit.Children
	{
		EmitDeclaration(declaration);
	}
}

public EmitPreamble() -> void
{
	// Setup the beginning of each section
	TypeDeclarations.WriteLine("#include \"RuntimeLibrary.h\"");
	TypeDeclarations.BlankLine();
	TypeDeclarations.WriteLine("// Type Declarations");
	FunctionDeclarations.BlankLine();
	FunctionDeclarations.WriteLine("// Function Declarations");
	ClassDeclarations.BlankLine();
	ClassDeclarations.WriteLine("// Class Declarations");
	GlobalDefinitions.BlankLine();
	GlobalDefinitions.WriteLine("// Global Definitions");
	Definitions.BlankLine();
	Definitions.WriteLine("// Definitions");
}

public EmitEntryPointAdapter(resources: System.Collections.List<Source_Text>) -> void
{
	Definitions.ElementSeparatorLine();
	Definitions.WriteLine("// Entry Point Adapter");
	Definitions.WriteLine("int main(int argc, char const *const * argv)");
	Definitions.BeginBlock();

	for let resource: Source_Text in resources
	{
		Definitions.BeginLine("resource_manager_->AddResource(::string(\"");
		Definitions.Write(resource.Name);
		Definitions.Write("\"), ::string(\"");
		Definitions.Write(resource.Text
								.Replace("\\", "\\\\")
								.Replace("\n", "\\n")
								.Replace("\r", "\\r")
								.Replace("\"", "\\\""));
		Definitions.EndLine("\"));");
	}
	if resources.Length() > 0
	{
		Definitions.EndLine(""); // Use EndLine to avoid having an indent on a blank line
	}

	// TODO should be `new mut`
	let args: mut System.Text.String_Builder = new System.Text.String_Builder();
	if MainFunctionAcceptsConsole
		{ args.Append("new ::System_::Console_::Console_()"); }
	if MainFunctionAcceptsArgs
	{
		if MainFunctionAcceptsConsole
			{ args.Append(", "); }
		args.Append("new ::System_::Console_::Arguments_(argc, argv)");
	}

	if MainFunctionReturnType == "void"
	{
		Definitions.WriteLine("Main_(" + args.ToString() + ");");
		Definitions.WriteLine("return 0;");
	}
	else
	{
		Definitions.WriteLine("return Main_(" + args.ToString() + ");");
	}

	Definitions.EndBlock();
}

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------

public ParseType() -> Syntax_Node
{
	if Token.Type == MutableKeyword
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(ExpectToken(MutableKeyword));
		children.Add(ParseType());
		return new Syntax_Node(MutableType, children);
	}

	var type: Syntax_Node;

	if Token.Type == CodePoint
		or Token.Type == String
		or Token.Type == Int
		or Token.Type == Bool
		or Token.Type == Void
		or Token.Type == UnsignedInt
	{
		type = new Syntax_Node(PredefinedType, AcceptToken());
	}
	else
	{
		type = new Syntax_Node(IdentifierName, ExpectToken(Identifier));

		while Token.Type == Dot
		{
			let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			children.Add(type);
			children.Add(ExpectToken(Dot));
			let identifier: Syntax_Node = ExpectToken(Identifier);
			if Token.Type == LessThan
			{
				// Generic Name
				let genericNameChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
				genericNameChildren.Add(new Syntax_Node(IdentifierName, identifier));
				genericNameChildren.Add(ExpectToken(LessThan));
				genericNameChildren.Add(ParseType());
				genericNameChildren.Add(ExpectToken(GreaterThan));
				children.Add(new Syntax_Node(GenericName, genericNameChildren));
			}
			else
			{
				children.Add(new Syntax_Node(IdentifierName, identifier));
			}

			type = new Syntax_Node(QualifiedName, children);
		}
	}

	if Token.Type == Question
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(type);
		children.Add(ExpectToken(Question));
		type = new Syntax_Node(NullableType, children);
	}

	return type;
}

// An Atom is the unit of an expression that occurs between infix operators, i.e. an identifier, literal, group, or new
public ParseAtom() -> Syntax_Node?
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	// This should be a match on the token type
	if Token.Type == NewKeyword
	{
		// Constructor Call
		children.Add(ExpectToken(NewKeyword));
		children.Add(ParseType());
		children.Add(ParseCallArguments());
		return new Syntax_Node(NewExpression, children);
	}
	if Token.Type == NotOperator
	{
		children.Add(ExpectToken(NotOperator));
		children.Add(ParseExpression());
		return new Syntax_Node(NotExpression, children);
	}
	if Token.Type == LeftParen
	{
		children.Add(ExpectToken(LeftParen));
		children.Add(ParseExpression());
		children.Add(ExpectToken(RightParen));
		return new Syntax_Node(ParenthesizedExpression, children);
	}
	if Token.Type == Sub
	{
		// Unary Minus
		children.Add(ExpectToken(Sub));
		children.Add(ParseExpression(7));
		return new Syntax_Node(UnaryMinusExpression, children);
	}
	if Token.Type == NullKeyword
	{
		children.Add(ExpectToken(NullKeyword));
		return new Syntax_Node(NullLiteralExpression, children);
	}
	if Token.Type == SelfKeyword
	{
		children.Add(ExpectToken(SelfKeyword));
		return new Syntax_Node(SelfExpression, children);
	}
	if Token.Type == TrueKeyword
	{
		children.Add(ExpectToken(TrueKeyword));
		return new Syntax_Node(TrueLiteralExpression, children);
	}
	if Token.Type == FalseKeyword
	{
		children.Add(ExpectToken(FalseKeyword));
		return new Syntax_Node(FalseLiteralExpression, children);
	}
	if Token.Type == Number
	{
		children.Add(ExpectToken(Number));
		return new Syntax_Node(NumericLiteralExpression, children);
	}
	if Token.Type == Identifier
	{
		children.Add(ExpectToken(Identifier));
		return new Syntax_Node(IdentifierName, children);
	}
	if Token.Type == StringLiteral
	{
		children.Add(ExpectToken(StringLiteral));
		return new Syntax_Node(StringLiteralExpression, children);
	}
	if Token.Type == CodePointLiteral
	{
		children.Add(ExpectToken(CodePointLiteral));
		return new Syntax_Node(CodePointLiteralExpression, children);
	}

	return null;
}

public ParseCallArguments() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	children.Add(ExpectToken(LeftParen));
	if Token.Type <> RightParen
	{
		loop
		{
			children.Add(ParseExpression());
			if Token.Type == Comma
				{ children.Add(ExpectToken(Comma)); }
			else
				{ break; }
		}
	}
	children.Add(ExpectToken(RightParen));
	return new Syntax_Node(ArgumentList, children);
}

// Operator Precedence
// 1 Assignment: = += -=
// 2 Logical Or: or
// 3 Logical And: and
// 4 Equality: == <>
// 5 Relational: < <= > >=
// 6 Additive: + -
// 7 Unary: -
// 8 Primary: f() . []
public ParseExpression(minPrecedence: int) -> Syntax_Node
{
	var expression: Syntax_Node = ParseAtom();
	if expression == null
		{ return null; }

	loop
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(expression);

		var precedence: int;
		var leftAssociative: bool;
		var suffixOperator: bool = false;
		var expressionType: int;
		if (Token.Type == Assign or Token.Type == AddAssign or Token.Type == SubAssign) and minPrecedence <= 1
		{
			// Assignment
			precedence = 1;
			leftAssociative = false;
			children.Add(AcceptToken());
			expressionType = AssignmentExpression;
		}
		else if Token.Type == OrKeyword and minPrecedence <= 2
		{
			// logical or
			precedence = 2;
			leftAssociative = true;
			children.Add(ExpectToken(OrKeyword));
			expressionType = OrExpression;
		}
		else if Token.Type == AndKeyword and minPrecedence <= 3
		{
			// logical and
			precedence = 3;
			leftAssociative = true;
			children.Add(ExpectToken(AndKeyword));
			expressionType = AndExpression;
		}
		else if Token.Type == Equal and minPrecedence <= 4
		{
			// equal
			precedence = 4;
			leftAssociative = true;
			children.Add(ExpectToken(Equal));
			expressionType = EqualExpression;
		}
		else if Token.Type == NotEqual and minPrecedence <= 4
		{
			// not equal
			precedence = 4;
			leftAssociative = true;
			children.Add(ExpectToken(NotEqual));
			expressionType = NotEqualExpression;
		}
		else if (Token.Type == LessThan or Token.Type == LessThanOrEqual or Token.Type == GreaterThan or Token.Type == GreaterThanOrEqual) and minPrecedence <= 5
		{
			// relational operators
			precedence = 5;
			leftAssociative = true;
			children.Add(AcceptToken());
			expressionType = ComparisionExpression;
		}
		else if Token.Type == Add and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			children.Add(ExpectToken(Add));
			expressionType = AddExpression;
		}
		else if Token.Type == Sub and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			children.Add(ExpectToken(Sub));
			expressionType = SubtractExpression;
		}
		else if Token.Type == LeftParen and minPrecedence <= 8
		{
			// Invocation Expression
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;

			children.Add(ParseCallArguments());
			expressionType = InvocationExpression;
		}
		else if Token.Type == Dot and minPrecedence <= 8
		{
			// Member Access
			precedence = 8;
			leftAssociative = true;
			children.Add(ExpectToken(Dot));
			expressionType = MemberAccessExpression;
		}
		else if Token.Type == LeftBracket and minPrecedence <= 8
		{
			// Element Access
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;

			children.Add(ExpectToken(LeftBracket));
			children.Add(ParseExpression());
			children.Add(ExpectToken(RightBracket));
			expressionType = ElementAccessExpression;
		}
		else
		{
			return expression;
		}

		if not suffixOperator
		{
			if leftAssociative
				{ precedence += 1; }
			let rhs: Syntax_Node = ParseExpression(precedence);
			children.Add(rhs);
			expression = new Syntax_Node(expressionType, children);
		}
		else
		{
			expression = new Syntax_Node(expressionType, children);
		}
	}
}

public ParseExpression() -> Syntax_Node
{
	return ParseExpression(1);
}

public ParseStatement() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == ReturnKeyword
	{
		children.Add(ExpectToken(ReturnKeyword));
		if Token.Type <> Semicolon
		{
			children.Add(ParseExpression());
		}
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(ReturnStatement, children);
	}
	if Token.Type == LoopKeyword
	{
		children.Add(ExpectToken(LoopKeyword));
		children.Add(ParseBlock());
		return new Syntax_Node(LoopStatement, children);
	}
	if Token.Type == WhileKeyword
	{
		children.Add(ExpectToken(WhileKeyword));
		children.Add(ParseExpression());
		children.Add(ParseBlock());
		return new Syntax_Node(WhileStatement, children);
	}
	if Token.Type == ForKeyword
	{
		children.Add(ExpectToken(ForKeyword));
		children.Add(ParseVariableDeclaration(false));
		children.Add(ExpectToken(InKeyword));
		children.Add(ParseExpression());
		children.Add(ParseBlock());
		return new Syntax_Node(ForStatement, children);
	}
	if Token.Type == DoKeyword
	{
		children.Add(ExpectToken(DoKeyword));
		children.Add(ParseBlock());
		children.Add(ExpectToken(WhileKeyword));
		children.Add(ParseExpression());
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(DoWhileStatement, children);
	}
	if Token.Type == IfKeyword
	{
		return ParseIfStatement();
	}
	if Token.Type == BreakKeyword
	{
		children.Add(ExpectToken(BreakKeyword));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(BreakStatement, children);
	}
	if Token.Type == ContinueKeyword
	{
		children.Add(ExpectToken(ContinueKeyword));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(ContinueStatement, children);
	}
	if Token.Type == VarKeyword or Token.Type == LetKeyword
	{
		children.Add(ParseVariableDeclaration(true));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(LocalDeclarationStatement, children);
	}

	// Assume it is an expression statement
	children.Add(ParseExpression());
	children.Add(ExpectToken(Semicolon));
	return new Syntax_Node(ExpressionStatement, children);
}

public ParseIfStatement() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	children.Add(ExpectToken(IfKeyword));
	children.Add(ParseExpression());
	children.Add(ParseBlock());
	if Token.Type == ElseKeyword
	{
		let elseChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		elseChildren.Add(ExpectToken(ElseKeyword));
		if Token.Type == IfKeyword
			{ elseChildren.Add(ParseIfStatement()); }
		else
			{ elseChildren.Add(ParseBlock());}
		children.Add(new Syntax_Node(ElseClause, elseChildren));
	}

	return new Syntax_Node(IfStatement, children);
}

public ParseVariableDeclaration(allowInitializer: bool) -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == LetKeyword and Token.Type <> VarKeyword
		{ children.Add(ExpectToken(LetKeyword)); }
	else
		{ children.Add(ExpectToken(VarKeyword)); }

	children.Add(ExpectToken(Identifier));
	children.Add(ExpectToken(Colon));
	children.Add(ParseType());

	if allowInitializer and Token.Type == Assign
	{
		children.Add(ExpectToken(Assign));
		children.Add(ParseExpression());
	}

	return new Syntax_Node(VariableDeclaration, children);
}

public ParseBlock() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	children.Add(ExpectToken(LeftBrace));
	while Token.Type <> RightBrace
	{
		children.Add(ParseStatement());
	}
	children.Add(ExpectToken(RightBrace));
	return new Syntax_Node(Block, children);
}

public ParseParameterList() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	children.Add(ExpectToken(LeftParen));

	if Token.Type <> RightParen
	{
		loop
		{
			let parameterChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			if Token.Type == MutableKeyword
				or Token.Type == SelfKeyword
			{
				// SelfParameter
				if Token.Type == MutableKeyword
					{ parameterChildren.Add(ExpectToken(MutableKeyword)); }

				parameterChildren.Add(ExpectToken(SelfKeyword));
				children.Add(new Syntax_Node(SelfParameter, parameterChildren));
			}
			else
			{
				let mutableBinding: bool = Token.Type == VarKeyword;
				if Token.Type == VarKeyword
					{ parameterChildren.Add(ExpectToken(VarKeyword)); }
				parameterChildren.Add(ExpectToken(Identifier));
				parameterChildren.Add(ExpectToken(Colon));
				let type: Syntax_Node = ParseType();
				parameterChildren.Add(type);
				children.Add(new Syntax_Node(Parameter, parameterChildren));
			}

			if Token.Type == Comma
				{ children.Add(ExpectToken(Comma)); }
			else
				{ break; }
		}
	}
	children.Add(ExpectToken(RightParen));
	return new Syntax_Node(ParameterList, children);
}

public ParseClassMember() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == PublicKeyword
		or Token.Type == ProtectedKeyword
		or Token.Type == InternalKeyword
		or Token.Type == PrivateKeyword
	{
		children.Add(AcceptToken());
	}
	else
	{
		// Really we expect an access modifier
		ExpectToken(PublicKeyword);
	}

	if Token.Type == NewKeyword
	{
		// Constructor
		children.Add(ExpectToken(NewKeyword));
		children.Add(ParseParameterList());
		children.Add(ParseBlock());
		return new Syntax_Node(ConstructorDeclaration, children);
	}

	if Token.Type == VarKeyword
		or Token.Type == LetKeyword
	{
		children.Add(ParseVariableDeclaration(false));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(FieldDeclaration, children);
	}

	// Method Declaration
	children.Add(ExpectToken(Identifier));
	children.Add(ParseParameterList());
	children.Add(ExpectToken(Arrow));
	children.Add(ParseType());
	children.Add(ParseBlock());
	return new Syntax_Node(MethodDeclaration, children);
}

public ParseDeclaration() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == PublicKeyword
		or Token.Type == ProtectedKeyword
		or Token.Type == InternalKeyword
		or Token.Type == PrivateKeyword
	{
		children.Add(AcceptToken());
	}
	else
	{
		// Really we expect an access modifier
		ExpectToken(PublicKeyword);
	}

	if Token.Type == VarKeyword
		or Token.Type == LetKeyword
	{
		children.Add(ParseVariableDeclaration(true));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(GlobalDeclaration, children);
	}

	if Token.Type == ClassKeyword
	{
		children.Add(ExpectToken(ClassKeyword));
		children.Add(ExpectToken(Identifier));
		children.Add(ExpectToken(LeftBrace));
		while Token.Type <> RightBrace
		{
			children.Add(ParseClassMember());
		}
		children.Add(ExpectToken(RightBrace));
		return new Syntax_Node(ClassDeclaration, children);
	}

	if Token.Type == EnumKeyword
	{
		children.Add(ExpectToken(EnumKeyword));
		children.Add(ExpectToken(StructKeyword));
		children.Add(ExpectToken(Identifier));
		children.Add(ExpectToken(LeftBrace));

		while Token.Type <> RightBrace
		{
			let memberChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			memberChildren.Add(ExpectToken(Identifier));
			if Token.Type == Assign
			{
				memberChildren.Add(ExpectToken(Assign));
				memberChildren.Add(ExpectToken(Number));
			}
			if Token.Type <> RightBrace
			{
				memberChildren.Add(ExpectToken(Comma));
			}
			children.Add(new Syntax_Node(EnumMemberDeclaration, memberChildren));
		}

		children.Add(ExpectToken(RightBrace));
		return new Syntax_Node(EnumDeclaration, children);
	}

	// Function Declaration
	children.Add(ExpectToken(Identifier));
	children.Add(ParseParameterList());
	children.Add(ExpectToken(Arrow));
	children.Add(ParseType());
	children.Add(ParseBlock());
	return new Syntax_Node(FunctionDeclaration, children);
}

public ParseCompilationUnit() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	while Token <> null
	{
		children.Add(ParseDeclaration());
	}
	return new Syntax_Node(CompilationUnit, children);
}

// ----------------------------------------------------------------------------
// Compiler
// ----------------------------------------------------------------------------

public Compile(sources: System.Collections.List<Source_Text>, resources: System.Collections.List<Source_Text>) -> string
{
	EmitPreamble();
	let lexer: Lexer = new Lexer();
	for let source: Source_Text in sources
	{
		tokenStream = lexer.Analyze(source);
		Token = tokenStream.GetNextToken();
		EmitCompilationUnit(ParseCompilationUnit());
	}
	EmitEntryPointAdapter(resources);
	return TypeDeclarations.ToString()
		+ FunctionDeclarations.ToString()
		+ ClassDeclarations.ToString()
		+ GlobalDefinitions.ToString()
		+ Definitions.ToString();
}

public Main(console: mut System.Console.Console, args: System.Console.Arguments) -> void
{
	console.WriteLine("Adamant Compiler v0.1.0");
	let sourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	let resourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	var outputFilePath: string = "";
	var argType: int = 0; // 0=source file, 1=resource file, 2=output file
	for let arg: string in args
	{
		if argType == 1 // resource file
		{
			resourceFilePaths.Add(arg);
			argType = 0;
		}
		else if argType == 2 // output file
		{
			outputFilePath = arg;
			argType = 0;
		}
		else // source file TODO check argType == 0
		{
			if arg == "-r"
			{
				argType = 1;
			}
			else if arg == "-o"
			{
				argType = 2;
			}
			else
			{
				sourceFilePaths.Add(arg);
			}
		}
	}

	if sourceFilePaths.Length() == 0 or outputFilePath == ""
	{
		console.WriteLine("Args: <Input File(s)> -o <OutputFile> -r <Resource File>");
		return;
	}

	// Read Resources
	let resources: mut System.Collections.List<Source_Text> = new System.Collections.List<Source_Text>();
	if resourceFilePaths.Length() > 0
	{
		console.WriteLine("Reading Resources:");
		for let resourceFilePath: string in resourceFilePaths
		{
			console.WriteLine("  " + resourceFilePath);
			resources.Add(ReadSource(resourceFilePath));
		}
	}

	// Read Source(s)
	console.WriteLine("Compiling:");
	let sources: mut System.Collections.List<Source_Text> = new System.Collections.List<Source_Text>();
	for let sourceFilePath: string in sourceFilePaths
	{
		console.WriteLine("  " + sourceFilePath);
		sources.Add(ReadSource(sourceFilePath));
	}

	let translated: string = Compile(sources, resources);

	// Write output
	console.Write("Output: ");
	console.WriteLine(outputFilePath);
	// TODO should be `new mut`
	let outputFile: mut System.IO.File_Writer = new System.IO.File_Writer(outputFilePath);
	outputFile.Write(translated);
	outputFile.Close();

	// Write RuntimeLibrary
	console.Write("Outputting RuntimeLibrary to: ");
	var outputDirPath: string = outputFilePath;
	var index: int = outputDirPath.LastIndexOf('/');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	index = outputDirPath.LastIndexOf('\\');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	console.WriteLine(outputDirPath);
	var resourceFile: mut System.IO.File_Writer = new System.IO.File_Writer(outputDirPath+"RuntimeLibrary.h");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.h"));
	resourceFile.Close();
	resourceFile = new System.IO.File_Writer(outputDirPath+"RuntimeLibrary.cpp");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.cpp"));
	resourceFile.Close();
}

public ReadSource(path: string) -> Source_Text
{
	// TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
	let file: mut System.IO.File_Reader = new System.IO.File_Reader(path);
	let contents: string = file.ReadToEndSync();
	file.Close(); // TODO this should automatically be handled
	var name: string = path;
	var index: int = name.LastIndexOf('/');
	if index <> -1
		{ name = name.Substring(index+1); }
	index = name.LastIndexOf('\\');
	if index <> -1
		{ name = name.Substring(index+1); }
	return new Source_Text("<default>", name, contents);
}
