public var tokenStream: mut Token_Stream = null;
public var Token: Syntax_Node = null;

public let TypeDeclarations: mut Source_File_Builder = new Source_File_Builder();
public let FunctionDeclarations: mut Source_File_Builder = new Source_File_Builder();
public let ClassDeclarations: mut Source_File_Builder= new Source_File_Builder();
public let GlobalDefinitions: mut Source_File_Builder = new Source_File_Builder();
public let Definitions: mut Source_File_Builder = new Source_File_Builder();

public var MainFunctionReturnType: string = "";
public var MainFunctionAcceptsConsole: bool = false;
public var MainFunctionAcceptsArgs: bool = false;

// ----------------------------------------------------------------------------
// Token Handling
// ----------------------------------------------------------------------------

public AcceptToken() -> Syntax_Node
{
	let node: Syntax_Node = Token;
	Token = tokenStream.GetNextToken();
	return node;
}

public ExpectToken(tokenType: int) -> Syntax_Node
{
	if Token.Type <> tokenType
	{
		Definitions.Error("Expected token type " + tokenType + ", found `" + Token.GetText() + "` of type " + Token.Type);
		Token = tokenStream.GetNextToken(); // Skip token to advance
		return new Syntax_Node(Error, Token.Source, Token.Start, Token.Length);
	}

	let node: Syntax_Node = Token;
	Token = tokenStream.GetNextToken();
	return node;
}

public Accept(expected: string) -> bool
{
	let accepted: bool = Token.GetText() == expected;
	if accepted { Token = tokenStream.GetNextToken(); }
	return accepted;
}

public Expect(expected: string) -> void
{
	if Token.GetText() <> expected
	{
		Definitions.Error("Expected `" + expected + "` but found `" + Token.GetText() + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
	}
	else
	{
		Token = tokenStream.GetNextToken();
	}
}

// ----------------------------------------------------------------------------
// Emitting C++
// ----------------------------------------------------------------------------

public IsValueType(type: Syntax_Node) -> bool
{
	// Here we assume that they follow convention and value types start lowercase
	if type.Type == PredefinedType
	{
		return true;
	}
	if type.Type == NullableType
	{
		// The first child is the basic type
		return IsValueType(type.Children.Get(0)); // The type that is nullable
	}
	if type.Type == QualifiedName
	{
		// The last child is the real type
		return IsValueType(type.Children.Get(type.Children.Length()-1));
	}
	if type.Type == GenericName
	{
		let firstChar: code_point = type.FirstChildOfType(IdentifierName).FirstChildOfType(Identifier).GetText()[0];
		return firstChar >= 'a' and firstChar <= 'z';
	}
	if type.Type == IdentifierName
	{
		let firstChar: code_point = type.FirstChildOfType(Identifier).GetText()[0];
		return firstChar >= 'a' and firstChar <= 'z';
	}

	// TODO Error
	return true; // The value true is more likely to cause some kind of compiler error in the emitted source that we will notice
}

// Converts a type to C++
public ConvertType(type: Syntax_Node) -> string
{
	if type.Type == PredefinedType
	{
		let keyword: Syntax_Node = type.Children.Get(0);
		if keyword.Type == CodePoint
			{ return "char"; }
		if keyword.Type == UnsignedInt
			{ return "unsigned int"; }
		// Int, Bool, Void, String
		return keyword.GetText();
	}

	if type.Type == IdentifierName
	{
		return "::" + type.GetText() + "_";
	}
	if type.Type == QualifiedName
	{
		return ConvertType(type.Children.Get(0)) + ConvertType(type.Children.Get(2));
	}
	if type.Type == GenericName
	{
		if type.Children.Get(2).Type == MutableKeyword
		{
			return ConvertType(type.Children.Get(0)) + "<" + ConvertType(true, true, type.Children.Get(3)) + ">";
		}
		return ConvertType(type.Children.Get(0)) + "<" + ConvertType(true, false, type.Children.Get(2)) + ">";
	}

	// TODO what about the leading `::`?
	return FormatError("Unexpected Token of type "+type.Type+" found in CovertType(), `"+type.GetText()+"`");
}

// Converts a type to C++
public ConvertType(mutableBinding: bool, mutableValue: bool, var type: Syntax_Node) -> string
{
	let nullable: bool = type.Type == NullableType;
	if nullable
	{
		type = type.Children.Get(0); // Remove the nullable wrapper
	}


	let isValueType: bool = IsValueType(type);
	var cppType: string = ConvertType(type);

	if isValueType
	{
		if nullable
			{ cppType = "::Maybe<" + cppType + ">"; }
		if not mutableBinding and not mutableValue
			{ cppType = cppType + " const"; }
	}
	else
	{
		if not mutableValue { cppType = cppType + " const"; }
		cppType = cppType + " *";
		if not mutableBinding { cppType = cppType + "const" ; }
	}

	return cppType;
}

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------

public ParseType() -> Syntax_Node
{
	if Token.Type == CodePoint
		or Token.Type == String
		or Token.Type == Int
		or Token.Type == Bool
		or Token.Type == Void
		or Token.Type == UnsignedInt
	{
		return new Syntax_Node(PredefinedType, AcceptToken());
	}

	// TODO should be `new mut`
	var type: Syntax_Node = new Syntax_Node(IdentifierName, ExpectToken(Identifier));

	while Token.Type == Dot
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(type);
		children.Add(ExpectToken(Dot));
		let identifier: Syntax_Node = ExpectToken(Identifier);
		if Token.Type == LessThan
		{
			// Generic Name
			let genericNameChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			genericNameChildren.Add(new Syntax_Node(IdentifierName, identifier));
			genericNameChildren.Add(ExpectToken(LessThan));
			if Token.Type == MutableKeyword
			{
				genericNameChildren.Add(ExpectToken(MutableKeyword));
			}
			genericNameChildren.Add(ParseType());
			genericNameChildren.Add(ExpectToken(GreaterThan));
			children.Add(new Syntax_Node(GenericName, genericNameChildren));
		}
		else
		{
			children.Add(new Syntax_Node(IdentifierName, identifier));
		}

		type = new Syntax_Node(QualifiedName, children);
	}

	if Token.Type == Question
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(type);
		children.Add(ExpectToken(Question));
		type = new Syntax_Node(NullableType, children);
	}

	return type;
}

// An Atom is the unit of an expression that occurs between infix operators, i.e. an identifier, literal, group, or new
public ParseAtom(builder: mut Source_File_Builder) -> bool
{
	// This should be a match on the token type
	if Token.Type == NewKeyword
	{
		// Constructor Call
		AcceptToken();
		let type: Syntax_Node = ParseType();
		if not IsValueType(type) // place value types on the stack in C++ by not using new
			{ builder.Write("new "); }
		builder.Write(ConvertType(type));
		ExpectToken(LeftParen);
		builder.Write("(");
		ParseCallArguments(builder);
		ExpectToken(RightParen);
		builder.Write(")");
		return true;
	}
	if Token.Type == NotOperator
	{
		AcceptToken();
		builder.Write("!");
		ParseExpression(builder);
		return true;
	}
	if Token.Type == LeftParen // Order of operations parens
	{
		AcceptToken();
		builder.Write("(");
		ParseExpression(builder);
		ExpectToken(RightParen);
		builder.Write(")");
		return true;
	}
	if Token.Type == Sub
	{
		// Unary Minus
		AcceptToken();
		builder.Write("-");
		ParseExpression(builder, 7);
		return true;
	}
	if Token.Type == NullKeyword
	{
		AcceptToken();
		builder.Write("::None");
		return true;
	}
	if Token.Type == SelfKeyword
	{
		AcceptToken();
		builder.Write("this");
		return true;
	}

	let token: string = Token.GetText();
	if Token.Type == TrueKeyword
		or Token.Type == FalseKeyword
	{
		AcceptToken();
		builder.Write(token);
		return true;
	}
	if Token.Type == Number
	{
		builder.Write(token);
		AcceptToken();
		return true;
	}
	if Token.Type == Identifier
	{
		builder.Write(token + "_");
		AcceptToken();
		return true;
	}
	if Token.Type == StringLiteral
	{
		builder.Write("string(" + token + ")");
		AcceptToken();
		return true;
	}
	if Token.Type == CodePointLiteral
	{
		builder.Write(token);
		AcceptToken();
		return true;
	}

	return false;
}

public ParseCallArguments(builder: mut Source_File_Builder) -> void
{
	var first: bool = true;
	do
	{
		if first { first = false; }
		else { builder.Write(", "); }
		ParseExpression(builder);
	} while Accept(",");
}

// Operator Precedence
// 1 Assignment: = += -=
// 2 Logical Or: or
// 3 Logical And: and
// 4 Equality: == <>
// 5 Relational: < <= > >=
// 6 Additive: + -
// 7 Unary: -
// 8 Primary: f() . []
public ParseExpression(builder: mut Source_File_Builder, minPrecedence: int) -> void
{
	if not ParseAtom(builder) { return; }

	loop
	{
		let token: string = Token.GetText();
		var precedence: int;
		var leftAssociative: bool;
		var suffixOperator: bool = false;
		if (token == "=" or token == "+=" or token == "-=") and minPrecedence <= 1
		{
			// Assignment
			precedence = 1;
			leftAssociative = false;
			builder.Write(" " + token + " ");
		}
		else if token == "or" and minPrecedence <= 2
		{
			// logical or
			precedence = 2;
			leftAssociative = true;
			builder.Write(" || ");
		}
		else if token == "and" and minPrecedence <= 3
		{
			// logical and
			precedence = 3;
			leftAssociative = true;
			builder.Write(" && ");
		}
		else if token == "==" and minPrecedence <= 4
		{
			// equal
			precedence = 4;
			leftAssociative = true;
			builder.Write(" == ");
		}
		else if token == "<>" and minPrecedence <= 4
		{
			// not equal
			precedence = 4;
			leftAssociative = true;
			builder.Write(" != ");
		}
		else if (token == "<" or token == "<=" or token == ">" or token == ">=") and minPrecedence <= 5
		{
			// relational operators
			precedence = 5;
			leftAssociative = true;
			builder.Write(" " + token + " ");
		}
		else if (token == "+" or token == "-") and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			builder.Write(" " + token + " ");
		}
		else if token == "(" and minPrecedence <= 8
		{
			// Call Expression
			Token = tokenStream.GetNextToken();
			builder.Write("(");
			ParseCallArguments(builder);
			if Token.GetText() <> ")"
			{
				builder.Error("Expected `)` found `" + Token.GetText() + "`");
			}
			builder.Write(")");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else if token == "." and minPrecedence <= 8
		{
			// Member Access
			precedence = 8;
			leftAssociative = true;
			builder.Write("->");
		}
		else if token == "[" and minPrecedence <= 8
		{
			// Element Access
			Token = tokenStream.GetNextToken();
			builder.Write("[");
			ParseExpression(builder);
			if Token.GetText() <> "]"
			{
				builder.Error("Expected `]` found `" + Token.GetText() + "`");
			}
			builder.Write("]");
			precedence = 8;
			leftAssociative = true;
			suffixOperator = true;
		}
		else
		{
			break;
		}

		Token = tokenStream.GetNextToken();
		if not suffixOperator
		{
			if leftAssociative { precedence += 1; }
			ParseExpression(builder, precedence);
		}
	}
}

public ParseExpression(builder: mut Source_File_Builder) -> void
{
	ParseExpression(builder, 1);
}

public ParseStatement() -> bool
{
	if Token.GetText() == "}" { return false; }

	Definitions.StatementSeparatorLine();

	if Accept("return")
	{
		if  Accept(";")
			{ Definitions.WriteLine("return;"); }
		else
		{
			Definitions.BeginLine("return ");
			ParseExpression(Definitions);
			Expect(";");
			Definitions.EndLine(";");
		}
		return true;
	}
	if Accept("loop")
	{
		Definitions.WriteLine("for (;;)");
		ParseBlock();
		return true;
	}
	if Accept("while")
	{
		Definitions.BeginLine("while (");
		ParseExpression(Definitions);
		Definitions.EndLine(")");
		ParseBlock();
		return true;
	}
	if Accept("for")
	{
		Definitions.BeginLine("for (");
		let k: string = Token.GetText();
		if not Accept("let") and not Accept("var")
			{ Definitions.Error("Expected `let` or `var` but found `" + Token.GetText() + "`"); }
		let name: string = ExpectToken(Identifier).GetText();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: Syntax_Node = ParseType();
		Definitions.Write(ConvertType(k == "var", mutableValue, type) + " " + name + "_");
		Expect("in");
		Definitions.Write(" : *(");
		ParseExpression(Definitions);
		Definitions.EndLine("))");
		ParseBlock();
		return true;
	}
	if Accept("do")
	{
		Definitions.WriteLine("do");
		ParseBlock();
		Expect("while");
		Definitions.BeginLine("while (");
		ParseExpression(Definitions);
		Expect(";");
		Definitions.EndLine(");");
		return true;
	}

	if Accept("if")
	{
		Definitions.BeginLine("if (");
		ParseExpression(Definitions);
		Definitions.EndLine(")");
		ParseBlock();
		while Accept("else")
		{
			if Accept("if")
			{
				Definitions.BeginLine("else if (");
				ParseExpression(Definitions);
				Definitions.EndLine(")");
				ParseBlock();
			}
			else
			{
				Definitions.WriteLine("else");
				ParseBlock();
				return true;
			}
		}
		return true;
	}
	if Accept("break")
	{
		Expect(";");
		Definitions.WriteLine("break;");
		return true;
	}
	if Accept("continue")
	{
		Expect(";");
		Definitions.WriteLine("continue;");
		return true;
	}

	let kind: string = Token.GetText();
	if Accept("let") or Accept("var")
	{
		let variableName: string = ExpectToken(Identifier).GetText();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let variableType: Syntax_Node = ParseType();
		let cppType: string = ConvertType(kind == "var", mutableValue, variableType);
		Definitions.BeginLine(cppType);
		Definitions.Write(" " + variableName + "_");
		if Accept("=")
		{
			Definitions.Write(" = ");
			ParseExpression(Definitions);
		}
		Expect(";");
		Definitions.EndLine(";");
		return true;
	}

	// Assume it is an expression statement
	Definitions.BeginLine("");
	ParseExpression(Definitions);
	Expect(";");
	Definitions.EndLine(";");
	return true;
}

public ParseBlock() -> void
{
	Expect("{");
	Definitions.BeginBlock();
	while ParseStatement() {}
	Expect("}");
	Definitions.EndBlock();
}

public ParseParameters(isMainFunction: bool, isMethod: bool) -> string
{
	// For methods, this is already consumed becuase of the self param
	if not isMethod { Expect("("); }
	if Accept(")") { return ""; }

	// TODO should be `new mut`
	let arguments: mut System.Text.String_Builder = new System.Text.String_Builder();
	do
	{
		let mutableBinding: bool = Accept("var");
		let name: string = ExpectToken(Identifier).GetText();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let type: Syntax_Node = ParseType();
		if isMainFunction
		{
			let typeString: string = type.GetText();
			if typeString == "System.Console.Console"
				{ MainFunctionAcceptsConsole = true; }
			if typeString == "System.Console.Arguments"
				{ MainFunctionAcceptsArgs = true; }
		}
		arguments.Append(ConvertType(mutableBinding, mutableValue, type) + " " + name + "_, ");
	} while Accept(",");
	Expect(")");
	// TODO Should String_Builder have a Length property?
	arguments.Remove(arguments.ToString().Length - 2); // remove the trailing comma and space
	return arguments.ToString();
}

public ParseConstructorParameters() -> string
{
	return ParseParameters(false, false);
}

public ParseFunctionParameters(isMainFunction: bool) -> string
{
	return ParseParameters(isMainFunction, false);
}

public ParseMethodParameters() -> string
{
	return ParseParameters(false, true);
}

public ParseClassMember(className: string) -> void
{
	let accessModifier: string = Token.GetText();
	if Accept("public") or Accept("internal") or Accept("protected") or Accept("private")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Definitions.Error("Expected access modifier, found `" + accessModifier + "`");
	}

	if Accept("new")
	{
		// Constructor
		let arguments: string = ParseConstructorParameters();
		// Write out the function declaration for C++ so we can call functions defined after others
		ClassDeclarations.WriteLine(className + "_(" + arguments + ");");
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("::" + className + "_::" + className + "_(" + arguments + ")");
		ParseBlock();
		return;
	}

	let kind: string = Token.GetText();
	if Accept("var") or Accept("let")
	{
		let fieldName: string = ExpectToken(Identifier).GetText();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let fieldType: Syntax_Node = ParseType();
		let cppType: string = ConvertType(true, mutableValue, fieldType); // because we need to assign them in constructors don't mark fields const
		Expect(";");
		ClassDeclarations.WriteLine(cppType + " " + fieldName + "_;");
		return;
	}

	// Method Declaration
	let methodName: string = ExpectToken(Identifier).GetText();
	Expect("(");
	let mutableSelf: bool = Accept("mut");
	var isAssociatedFuntion: bool = not mutableSelf;
	if mutableSelf
	{
		Expect("self");
		if Token.GetText() <> ")"
			{ Expect(","); }
	}
	else
	{
		if Accept("self")
		{
			isAssociatedFuntion = false;
			if Token.GetText() <> ")"
				{ Expect(","); }
		}
	}
	let arguments: string = ParseMethodParameters();
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: Syntax_Node = ParseType();
	let cppType: string = ConvertType(true, mutableValue, returnType);
	var staticModifier: string = "";
	if isAssociatedFuntion
		{ staticModifier = "static "; }
	var constModifier: string = "";
	if not mutableSelf and not isAssociatedFuntion
		{ constModifier = "const "; }
	ClassDeclarations.WriteLine(staticModifier + "auto " + methodName + "_(" + arguments + ") " + constModifier + "-> " + cppType + ";");
	Definitions.ElementSeparatorLine();
	Definitions.WriteLine("auto ::" + className + "_::" + methodName + "_(" + arguments + ") " + constModifier + "-> " + cppType);
	ParseBlock();
}

public ParseDeclaration() -> void
{
	let accessModifier: string = Token.GetText();
	if Accept("public") or Accept("internal")
	{
		// TODO currently not doing anything with the access modifier
	}
	else
	{
		Definitions.Error("Expected access modifier, found `" + accessModifier + "`");
	}

	// Static Variable Declaration
	let kind: string = Token.GetText();
	if Accept("var") or Accept("let")
	{
		let variableName: string = ExpectToken(Identifier).GetText();
		Expect(":");
		let mutableValue: bool = Accept("mut");
		let variableType: Syntax_Node = ParseType();
		Expect("=");
		let cppType: string = ConvertType(kind == "var", mutableValue, variableType);
		GlobalDefinitions.BeginLine(cppType);
		GlobalDefinitions.Write(" " + variableName + "_ = ");
		ParseExpression(GlobalDefinitions);
		Expect(";");
		GlobalDefinitions.EndLine(";");
		return;
	}

	if Accept("class")
	{
		let className: string = ExpectToken(Identifier).GetText();
		TypeDeclarations.WriteLine("class " + className + "_;");
		ClassDeclarations.ElementSeparatorLine();
		ClassDeclarations.WriteLine("class " + className + "_");
		Expect("{");
		ClassDeclarations.BeginBlock();
		ClassDeclarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
		while not Accept("}")
		{
			ParseClassMember(className);
		}
		ClassDeclarations.EndBlockWithSemicolon();
		return;
	}

	if Accept("enum")
	{
		Expect("struct");
		let enumName: string = ExpectToken(Identifier).GetText();
		TypeDeclarations.WriteLine("enum class " + enumName + "_;");
		ClassDeclarations.ElementSeparatorLine();
		ClassDeclarations.WriteLine("enum class " + enumName + "_");
		Expect("{");
		ClassDeclarations.BeginBlock();
		do
		{
			let enumValue: string = ExpectToken(Identifier).GetText();
			ClassDeclarations.BeginLine(enumValue + "_");
			if Accept("=")
			{
				ClassDeclarations.Write(" = ");
				let token: Syntax_Node = ExpectToken(Number);
				if token <> null
					{ ClassDeclarations.Write(token.GetText()); }
			}
			ClassDeclarations.EndLine(",");
		} while Accept(",");
		Expect("}");
		ClassDeclarations.EndBlockWithSemicolon();
		return;
	}

	// Function Declaration
	let name: string = ExpectToken(Identifier).GetText();
	let arguments: string = ParseFunctionParameters(name == "Main");
	Expect("->");
	let mutableValue: bool = Accept("mut");
	let returnType: Syntax_Node = ParseType();
	let cppType: string = ConvertType(true, mutableValue, returnType);
	// Write out the function declaration for C++ so we can call functions defined after others
	FunctionDeclarations.WriteLine("auto " + name + "_(" + arguments + ") -> " + cppType + ";");
	Definitions.ElementSeparatorLine();
	Definitions.WriteLine("auto " + name + "_(" + arguments + ") -> " + cppType);
	if name == "Main"
	{
		if MainFunctionReturnType <> ""
			{ Definitions.Error("Multiple declarations of main"); }
		MainFunctionReturnType = cppType;
	}
	ParseBlock();
}

public ParseCompilationUnit() -> void
{
	while Token <> null and Token.Type == Identifier
	{
		ParseDeclaration();
	}
}

public EmitPreamble() -> void
{
	// Setup the beginning of each section
	TypeDeclarations.WriteLine("#include \"RuntimeLibrary.h\"");
	TypeDeclarations.BlankLine();
	TypeDeclarations.WriteLine("// Type Declarations");
	FunctionDeclarations.BlankLine();
	FunctionDeclarations.WriteLine("// Function Declarations");
	ClassDeclarations.BlankLine();
	ClassDeclarations.WriteLine("// Class Declarations");
	GlobalDefinitions.BlankLine();
	GlobalDefinitions.WriteLine("// Global Definitions");
	Definitions.BlankLine();
	Definitions.WriteLine("// Definitions");
}

public EmitEntryPointAdapter(resources: System.Collections.List<Source_Text>) -> void
{
	Definitions.ElementSeparatorLine();
	Definitions.WriteLine("// Entry Point Adapter");
	Definitions.WriteLine("int main(int argc, char const *const * argv)");
	Definitions.BeginBlock();

	for let resource: Source_Text in resources
	{
		Definitions.BeginLine("resource_manager_->AddResource(::string(\"");
		Definitions.Write(resource.Name);
		Definitions.Write("\"), ::string(\"");
		Definitions.Write(resource.Text
								.Replace("\\", "\\\\")
								.Replace("\n", "\\n")
								.Replace("\r", "\\r")
								.Replace("\"", "\\\""));
		Definitions.EndLine("\"));");
	}
	if resources.Length() > 0
	{
		Definitions.EndLine(""); // Use EndLine to avoid having an indent on a blank line
	}

	// TODO should be `new mut`
	let args: mut System.Text.String_Builder = new System.Text.String_Builder();
	if MainFunctionAcceptsConsole
		{ args.Append("new ::System_::Console_::Console_()"); }
	if MainFunctionAcceptsArgs
	{
		if MainFunctionAcceptsConsole
			{ args.Append(", "); }
		args.Append("new ::System_::Console_::Arguments_(argc, argv)");
	}

	if MainFunctionReturnType == "void"
	{
		Definitions.WriteLine("Main_(" + args.ToString() + ");");
		Definitions.WriteLine("return 0;");
	}
	else
	{
		Definitions.WriteLine("return Main_(" + args.ToString() + ");");
	}

	Definitions.EndBlock();
}

// ----------------------------------------------------------------------------
// Compiler
// ----------------------------------------------------------------------------

public Compile(sources: System.Collections.List<Source_Text>, resources: System.Collections.List<Source_Text>) -> string
{
	EmitPreamble();
	let lexer: Lexer = new Lexer();
	for let source: Source_Text in sources
	{
		tokenStream = lexer.Analyze(source);
		Token = tokenStream.GetNextToken();
		ParseCompilationUnit();
	}
	EmitEntryPointAdapter(resources);
	return TypeDeclarations.ToString()
		+ FunctionDeclarations.ToString()
		+ ClassDeclarations.ToString()
		+ GlobalDefinitions.ToString()
		+ Definitions.ToString();
}

public Main(console: mut System.Console.Console, args: System.Console.Arguments) -> void
{
	console.WriteLine("Adamant Compiler v0.1.0");
	let sourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	let resourceFilePaths: mut System.Collections.List<string> = new System.Collections.List<string>();
	var outputFilePath: string = "";
	var argType: int = 0; // 0=source file, 1=resource file, 2=output file
	for let arg: string in args
	{
		if argType == 1 // resource file
		{
			resourceFilePaths.Add(arg);
			argType = 0;
		}
		else if argType == 2 // output file
		{
			outputFilePath = arg;
			argType = 0;
		}
		else // source file TODO check argType == 0
		{
			if arg == "-r"
			{
				argType = 1;
			}
			else if arg == "-o"
			{
				argType = 2;
			}
			else
			{
				sourceFilePaths.Add(arg);
			}
		}
	}

	if sourceFilePaths.Length() == 0 or outputFilePath == ""
	{
		console.WriteLine("Args: <Input File(s)> -o <OutputFile> -r <Resource File>");
		return;
	}

	// Read Resources
	let resources: mut System.Collections.List<Source_Text> = new System.Collections.List<Source_Text>();
	if resourceFilePaths.Length() > 0
	{
		console.WriteLine("Reading Resources:");
		for let resourceFilePath: string in resourceFilePaths
		{
			console.WriteLine("  " + resourceFilePath);
			resources.Add(ReadSource(resourceFilePath));
		}
	}

	// Read Source(s)
	console.WriteLine("Compiling:");
	let sources: mut System.Collections.List<Source_Text> = new System.Collections.List<Source_Text>();
	for let sourceFilePath: string in sourceFilePaths
	{
		console.WriteLine("  " + sourceFilePath);
		sources.Add(ReadSource(sourceFilePath));
	}

	let translated: string = Compile(sources, resources);

	// Write output
	console.Write("Output: ");
	console.WriteLine(outputFilePath);
	// TODO should be `new mut`
	let outputFile: mut System.IO.File_Writer = new System.IO.File_Writer(outputFilePath);
	outputFile.Write(translated);
	outputFile.Close();

	// Write RuntimeLibrary
	console.Write("Outputting RuntimeLibrary to: ");
	var outputDirPath: string = outputFilePath;
	var index: int = outputDirPath.LastIndexOf('/');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	index = outputDirPath.LastIndexOf('\\');
	if index <> -1
		{ outputDirPath = outputDirPath.Substring(0, index+1); }
	console.WriteLine(outputDirPath);
	var resourceFile: mut System.IO.File_Writer = new System.IO.File_Writer(outputDirPath+"RuntimeLibrary.h");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.h"));
	resourceFile.Close();
	resourceFile = new System.IO.File_Writer(outputDirPath+"RuntimeLibrary.cpp");
	resourceFile.Write(resource_manager.GetString("RuntimeLibrary.cpp"));
	resourceFile.Close();
}

public ReadSource(path: string) -> Source_Text
{
	// TODO should be `mut new` or `new mut`, whichever is decided to be the correct syntax
	let file: mut System.IO.File_Reader = new System.IO.File_Reader(path);
	let contents: string = file.ReadToEndSync();
	file.Close(); // TODO this should automatically be handled
	var name: string = path;
	var index: int = name.LastIndexOf('/');
	if index <> -1
		{ name = name.Substring(index+1); }
	index = name.LastIndexOf('\\');
	if index <> -1
		{ name = name.Substring(index+1); }
	return new Source_Text("<default>", name, contents);
}
