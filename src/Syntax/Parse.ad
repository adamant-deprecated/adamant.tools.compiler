public var tokenStream: mut Token_Stream = null;
public var Token: Syntax_Node? = null;

// ----------------------------------------------------------------------------
// Token Handling
// ----------------------------------------------------------------------------

public AcceptToken() -> Syntax_Node
{
	let node: Syntax_Node = Token;
	Token = tokenStream.GetNextToken();
	return node;
}

public ExpectToken(tokenType: int) -> Syntax_Node
{
	if Token.Type <> tokenType
	{
		// TODO the tokenType isn't being properly converted to a string here
		Definitions.Error("Expected token type " + tokenType + ", found `" + Token.GetText() + "` of type " + Token.Type);
		Token = tokenStream.GetNextToken(); // Skip token to advance
		return new Syntax_Node(Error, Token.Source, Token.Start, Token.Length);
	}

	let node: Syntax_Node = Token;
	Token = tokenStream.GetNextToken();
	return node;
}

public Accept(expected: string) -> bool
{
	let accepted: bool = Token.GetText() == expected;
	if accepted { Token = tokenStream.GetNextToken(); }
	return accepted;
}

public Expect(expected: string) -> void
{
	if Token.GetText() <> expected
	{
		Definitions.Error("Expected `" + expected + "` but found `" + Token.GetText() + "`");
		Token = tokenStream.GetNextToken(); // Skip token to advance
	}
	else
	{
		Token = tokenStream.GetNextToken();
	}
}

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------

public ParseNonNullableType() -> Syntax_Node
{
	if Token.Type == MutableKeyword
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(ExpectToken(MutableKeyword));
		children.Add(ParseNonNullableType());
		return new Syntax_Node(MutableType, children);
	}

	if Token.Type == CodePoint
		or Token.Type == String
		or Token.Type == Int
		or Token.Type == Bool
		or Token.Type == Void
		or Token.Type == UnsignedInt
	{
		return new Syntax_Node(PredefinedType, AcceptToken());
	}
	else
	{
		var type: Syntax_Node = new Syntax_Node(IdentifierName, ExpectToken(Identifier));

		while Token.Type == Dot
		{
			let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			children.Add(type);
			children.Add(ExpectToken(Dot));
			let identifier: Syntax_Node = ExpectToken(Identifier);
			if Token.Type == LessThan
			{
				// Generic Name
				let genericNameChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
				genericNameChildren.Add(new Syntax_Node(IdentifierName, identifier));
				genericNameChildren.Add(ExpectToken(LessThan));
				genericNameChildren.Add(ParseType());
				genericNameChildren.Add(ExpectToken(GreaterThan));
				children.Add(new Syntax_Node(GenericName, genericNameChildren));
			}
			else
			{
				children.Add(new Syntax_Node(IdentifierName, identifier));
			}

			type = new Syntax_Node(QualifiedName, children);
		}

		return type;
	}
}

public ParseType() -> Syntax_Node
{
	var type: Syntax_Node = ParseNonNullableType();

	while Token.Type == Question
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(type);
		children.Add(ExpectToken(Question));
		type = new Syntax_Node(NullableType, children);
	}

	return type;
}

// An Atom is the unit of an expression that occurs between infix operators, i.e. an identifier, literal, group, or new
public ParseAtom() -> Syntax_Node?
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	// This should be a match on the token type
	if Token.Type == NewKeyword
	{
		// Constructor Call
		children.Add(ExpectToken(NewKeyword));
		children.Add(ParseType());
		children.Add(ParseCallArguments());
		return new Syntax_Node(NewExpression, children);
	}
	if Token.Type == NotOperator
	{
		children.Add(ExpectToken(NotOperator));
		children.Add(ParseExpression(8));
		return new Syntax_Node(NotExpression, children);
	}
	if Token.Type == LeftParen
	{
		children.Add(ExpectToken(LeftParen));
		children.Add(ParseExpression());
		children.Add(ExpectToken(RightParen));
		return new Syntax_Node(ParenthesizedExpression, children);
	}
	if Token.Type == Pipe
	{
		children.Add(ExpectToken(Pipe));
		children.Add(ParseExpression());
		children.Add(ExpectToken(Pipe));
		return new Syntax_Node(MagnitudeExpression, children);
	}
	if Token.Type == Sub
	{
		// Unary Minus
		children.Add(ExpectToken(Sub));
		children.Add(ParseExpression(8));
		return new Syntax_Node(UnaryMinusExpression, children);
	}
	if Token.Type == NullKeyword
	{
		children.Add(ExpectToken(NullKeyword));
		return new Syntax_Node(NullLiteralExpression, children);
	}
	if Token.Type == SelfKeyword
	{
		children.Add(ExpectToken(SelfKeyword));
		return new Syntax_Node(SelfExpression, children);
	}
	if Token.Type == TrueKeyword
	{
		children.Add(ExpectToken(TrueKeyword));
		return new Syntax_Node(TrueLiteralExpression, children);
	}
	if Token.Type == FalseKeyword
	{
		children.Add(ExpectToken(FalseKeyword));
		return new Syntax_Node(FalseLiteralExpression, children);
	}
	if Token.Type == Number
	{
		children.Add(ExpectToken(Number));
		return new Syntax_Node(NumericLiteralExpression, children);
	}
	if Token.Type == Identifier
	{
		children.Add(ExpectToken(Identifier));
		return new Syntax_Node(IdentifierName, children);
	}
	if Token.Type == StringLiteral
	{
		children.Add(ExpectToken(StringLiteral));
		return new Syntax_Node(StringLiteralExpression, children);
	}
	if Token.Type == CodePointLiteral
	{
		children.Add(ExpectToken(CodePointLiteral));
		return new Syntax_Node(CodePointLiteralExpression, children);
	}

	return null;
}

public ParseCallArguments() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	children.Add(ExpectToken(LeftParen));
	if Token.Type <> RightParen
	{
		loop
		{
			children.Add(ParseExpression());
			if Token.Type == Comma
				{ children.Add(ExpectToken(Comma)); }
			else
				{ break; }
		}
	}
	children.Add(ExpectToken(RightParen));
	return new Syntax_Node(ArgumentList, children);
}

// Operator Precedence
// 1 Assignment: = += -=
// 2 Logical Or: or
// 3 Logical And: and
// 4 Equality: == <>
// 5 Relational: < <= > >=
// 6 Additive: + -
// 7 Multiplicative: * / %
// 8 Unary: - not
// 9 Primary: f() . []
public ParseExpression(minPrecedence: int) -> Syntax_Node
{
	var expression: Syntax_Node? = ParseAtom();
	if expression == null
		{ return null; }

	loop
	{
		let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		children.Add(expression);

		var precedence: int;
		var leftAssociative: bool;
		var suffixOperator: bool = false;
		var expressionType: int;
		if (Token.Type == Assign or Token.Type == AddAssign or Token.Type == SubAssign) and minPrecedence <= 1
		{
			// Assignment
			precedence = 1;
			leftAssociative = false;
			children.Add(AcceptToken());
			expressionType = AssignmentExpression;
		}
		else if Token.Type == OrKeyword and minPrecedence <= 2
		{
			// logical or
			precedence = 2;
			leftAssociative = true;
			children.Add(ExpectToken(OrKeyword));
			expressionType = OrExpression;
		}
		else if Token.Type == AndKeyword and minPrecedence <= 3
		{
			// logical and
			precedence = 3;
			leftAssociative = true;
			children.Add(ExpectToken(AndKeyword));
			expressionType = AndExpression;
		}
		else if Token.Type == Equal and minPrecedence <= 4
		{
			// equal
			precedence = 4;
			leftAssociative = true;
			children.Add(ExpectToken(Equal));
			expressionType = EqualExpression;
		}
		else if Token.Type == NotEqual and minPrecedence <= 4
		{
			// not equal
			precedence = 4;
			leftAssociative = true;
			children.Add(ExpectToken(NotEqual));
			expressionType = NotEqualExpression;
		}
		else if (Token.Type == LessThan or Token.Type == LessThanOrEqual or Token.Type == GreaterThan or Token.Type == GreaterThanOrEqual) and minPrecedence <= 5
		{
			// relational operators
			precedence = 5;
			leftAssociative = true;
			children.Add(AcceptToken());
			expressionType = ComparisionExpression;
		}
		else if Token.Type == Add and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			children.Add(ExpectToken(Add));
			expressionType = AddExpression;
		}
		else if Token.Type == Sub and minPrecedence <= 6
		{
			// Additive
			precedence = 6;
			leftAssociative = true;
			children.Add(ExpectToken(Sub));
			expressionType = SubtractExpression;
		}
		else if Token.Type == Percent and minPrecedence <= 7
		{
			// Multiplicative
			precedence = 7;
			leftAssociative = true;
			children.Add(ExpectToken(Percent));
			expressionType = ModuloExpression;
		}
		else if Token.Type == LeftParen and minPrecedence <= 9
		{
			// Invocation Expression
			precedence = 9;
			leftAssociative = true;
			suffixOperator = true;

			children.Add(ParseCallArguments());
			expressionType = InvocationExpression;
		}
		else if Token.Type == Dot and minPrecedence <= 9
		{
			// Member Access
			precedence = 9;
			leftAssociative = true;
			children.Add(ExpectToken(Dot));
			expressionType = MemberAccessExpression;
		}
		else if Token.Type == LeftBracket and minPrecedence <= 9
		{
			// Element Access
			precedence = 9;
			leftAssociative = true;
			suffixOperator = true;

			children.Add(ExpectToken(LeftBracket));
			children.Add(ParseExpression());
			children.Add(ExpectToken(RightBracket));
			expressionType = ElementAccessExpression;
		}
		else
		{
			return expression;
		}

		if not suffixOperator
		{
			if leftAssociative
				{ precedence += 1; }
			let rhs: Syntax_Node = ParseExpression(precedence);
			children.Add(rhs);
			expression = new Syntax_Node(expressionType, children);
		}
		else
		{
			expression = new Syntax_Node(expressionType, children);
		}
	}
}

public ParseExpression() -> Syntax_Node
{
	return ParseExpression(1);
}

public ParseStatement() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == ReturnKeyword
	{
		children.Add(ExpectToken(ReturnKeyword));
		if Token.Type <> Semicolon
		{
			children.Add(ParseExpression());
		}
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(ReturnStatement, children);
	}
	if Token.Type == LoopKeyword
	{
		children.Add(ExpectToken(LoopKeyword));
		children.Add(ParseBlock());
		return new Syntax_Node(LoopStatement, children);
	}
	if Token.Type == WhileKeyword
	{
		children.Add(ExpectToken(WhileKeyword));
		children.Add(ParseExpression());
		children.Add(ParseBlock());
		return new Syntax_Node(WhileStatement, children);
	}
	if Token.Type == ForKeyword
	{
		children.Add(ExpectToken(ForKeyword));
		children.Add(ParseVariableDeclaration(false));
		children.Add(ExpectToken(InKeyword));
		children.Add(ParseExpression());
		children.Add(ParseBlock());
		return new Syntax_Node(ForStatement, children);
	}
	if Token.Type == DoKeyword
	{
		children.Add(ExpectToken(DoKeyword));
		children.Add(ParseBlock());
		children.Add(ExpectToken(WhileKeyword));
		children.Add(ParseExpression());
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(DoWhileStatement, children);
	}
	if Token.Type == IfKeyword
	{
		return ParseIfStatement();
	}
	if Token.Type == BreakKeyword
	{
		children.Add(ExpectToken(BreakKeyword));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(BreakStatement, children);
	}
	if Token.Type == ContinueKeyword
	{
		children.Add(ExpectToken(ContinueKeyword));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(ContinueStatement, children);
	}
	if Token.Type == VarKeyword or Token.Type == LetKeyword
	{
		children.Add(ParseVariableDeclaration(true));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(LocalDeclarationStatement, children);
	}

	// Assume it is an expression statement
	children.Add(ParseExpression());
	children.Add(ExpectToken(Semicolon));
	return new Syntax_Node(ExpressionStatement, children);
}

public ParseIfStatement() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	children.Add(ExpectToken(IfKeyword));
	children.Add(ParseExpression());
	children.Add(ParseBlock());
	if Token.Type == ElseKeyword
	{
		let elseChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
		elseChildren.Add(ExpectToken(ElseKeyword));
		if Token.Type == IfKeyword
			{ elseChildren.Add(ParseIfStatement()); }
		else
			{ elseChildren.Add(ParseBlock());}
		children.Add(new Syntax_Node(ElseClause, elseChildren));
	}

	return new Syntax_Node(IfStatement, children);
}

public ParseVariableDeclaration(allowInitializer: bool) -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == LetKeyword and Token.Type <> VarKeyword
		{ children.Add(ExpectToken(LetKeyword)); }
	else
		{ children.Add(ExpectToken(VarKeyword)); }

	children.Add(ExpectToken(Identifier));
	children.Add(ExpectToken(Colon));
	children.Add(ParseType());

	if allowInitializer and Token.Type == Assign
	{
		children.Add(ExpectToken(Assign));
		children.Add(ParseExpression());
	}

	return new Syntax_Node(VariableDeclaration, children);
}

public ParseBlock() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	children.Add(ExpectToken(LeftBrace));
	while Token.Type <> RightBrace
	{
		children.Add(ParseStatement());
	}
	children.Add(ExpectToken(RightBrace));
	return new Syntax_Node(Block, children);
}

public ParseParameterList() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	children.Add(ExpectToken(LeftParen));

	if Token.Type <> RightParen
	{
		loop
		{
			let parameterChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			if Token.Type == MutableKeyword
				or Token.Type == SelfKeyword
			{
				// SelfParameter
				if Token.Type == MutableKeyword
					{ parameterChildren.Add(ExpectToken(MutableKeyword)); }

				parameterChildren.Add(ExpectToken(SelfKeyword));
				children.Add(new Syntax_Node(SelfParameter, parameterChildren));
			}
			else
			{
				let mutableBinding: bool = Token.Type == VarKeyword;
				if Token.Type == VarKeyword
					{ parameterChildren.Add(ExpectToken(VarKeyword)); }
				parameterChildren.Add(ExpectToken(Identifier));
				parameterChildren.Add(ExpectToken(Colon));
				let type: Syntax_Node = ParseType();
				parameterChildren.Add(type);
				children.Add(new Syntax_Node(Parameter, parameterChildren));
			}

			if Token.Type == Comma
				{ children.Add(ExpectToken(Comma)); }
			else
				{ break; }
		}
	}
	children.Add(ExpectToken(RightParen));
	return new Syntax_Node(ParameterList, children);
}

public ParseClassMember() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == PublicKeyword
		or Token.Type == ProtectedKeyword
		or Token.Type == InternalKeyword
		or Token.Type == PrivateKeyword
	{
		children.Add(AcceptToken());
	}
	else
	{
		// Really we expect an access modifier
		ExpectToken(PublicKeyword);
	}

	if Token.Type == NewKeyword
	{
		// Constructor
		children.Add(ExpectToken(NewKeyword));
		children.Add(ParseParameterList());
		children.Add(ParseBlock());
		return new Syntax_Node(ConstructorDeclaration, children);
	}

	if Token.Type == VarKeyword
		or Token.Type == LetKeyword
	{
		children.Add(ParseVariableDeclaration(false));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(FieldDeclaration, children);
	}

	// Method Declaration
	children.Add(ExpectToken(Identifier));
	children.Add(ParseParameterList());
	children.Add(ExpectToken(Arrow));
	children.Add(ParseType());
	children.Add(ParseBlock());
	return new Syntax_Node(MethodDeclaration, children);
}

public ParseDeclaration() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();

	if Token.Type == PublicKeyword
		or Token.Type == ProtectedKeyword
		or Token.Type == InternalKeyword
		or Token.Type == PrivateKeyword
	{
		children.Add(AcceptToken());
	}
	else
	{
		// Really we expect an access modifier
		ExpectToken(PublicKeyword);
	}

	if Token.Type == VarKeyword
		or Token.Type == LetKeyword
	{
		children.Add(ParseVariableDeclaration(true));
		children.Add(ExpectToken(Semicolon));
		return new Syntax_Node(GlobalDeclaration, children);
	}

	if Token.Type == ClassKeyword
	{
		children.Add(ExpectToken(ClassKeyword));
		children.Add(ExpectToken(Identifier));
		children.Add(ExpectToken(LeftBrace));
		while Token.Type <> RightBrace
		{
			children.Add(ParseClassMember());
		}
		children.Add(ExpectToken(RightBrace));
		return new Syntax_Node(ClassDeclaration, children);
	}

	if Token.Type == EnumKeyword
	{
		children.Add(ExpectToken(EnumKeyword));
		children.Add(ExpectToken(StructKeyword));
		children.Add(ExpectToken(Identifier));
		children.Add(ExpectToken(LeftBrace));

		while Token.Type <> RightBrace
		{
			let memberChildren: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
			memberChildren.Add(ExpectToken(Identifier));
			if Token.Type == Assign
			{
				memberChildren.Add(ExpectToken(Assign));
				memberChildren.Add(ExpectToken(Number));
			}
			if Token.Type <> RightBrace
			{
				memberChildren.Add(ExpectToken(Comma));
			}
			children.Add(new Syntax_Node(EnumMemberDeclaration, memberChildren));
		}

		children.Add(ExpectToken(RightBrace));
		return new Syntax_Node(EnumDeclaration, children);
	}

	// Function Declaration
	children.Add(ExpectToken(Identifier));
	children.Add(ParseParameterList());
	children.Add(ExpectToken(Arrow));
	children.Add(ParseType());
	children.Add(ParseBlock());
	return new Syntax_Node(FunctionDeclaration, children);
}

public ParseCompilationUnit() -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	while Token <> null
	{
		children.Add(ParseDeclaration());
	}
	return new Syntax_Node(CompilationUnit, children);
}

public ParsePackage(sources: System.Collections.List<Source_Text>) -> Syntax_Node
{
	let children: mut System.Collections.List<Syntax_Node> = new System.Collections.List<Syntax_Node>();
	let lexer: Lexer = new Lexer();
	for let source: Source_Text in sources
	{
		tokenStream = lexer.Analyze(source);
		Token = tokenStream.GetNextToken();
		children.Add(ParseCompilationUnit());
	}
	return new Syntax_Node(Package, children);
}
