public class Token_Stream
{
	public let Source: Source_Text;
	private var position: uint;

	public new(source: Source_Text)
	{
		Source = source;
		position = 0; // TODO have to assign this zero for now because we don't have default values working
	}

	public GetNextToken(mut self) -> Syntax_Node
	{
		var end: uint = -1;
		while position < Source.Text.Length
		{
			let curChar: code_point = Source.Text[position];
			if curChar == ' '
				or curChar == '\t'
				or curChar == '\n'
				or curChar == '\r'
			{
				position += 1;
				continue;
			}
			else if curChar == '{'
				{ return NewOperator(LeftBrace); }
			else if curChar == '}'
				{ return NewOperator(RightBrace); }
			else if curChar == '('
				{ return NewOperator(LeftParen); }
			else if curChar == ')'
				{ return NewOperator(RightParen); }
			else if curChar == ';'
				{ return NewOperator(Semicolon); }
			else if curChar == ','
				{ return NewOperator(Comma); }
			else if curChar == '.'
				{ return NewOperator(Dot); }
			else if curChar == ':'
				{ return NewOperator(Colon); }
			else if curChar == '['
				{ return NewOperator(LeftBracket); }
			else if curChar == ']'
				{ return NewOperator(RightBracket); }
			else if curChar == '?'
				{ return NewOperator(Question); }
			else if curChar == '='
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `==`
					return NewOperator(Equal, 2);
				}

				// it is `=`
				return NewOperator(Assign);
			}
			else if curChar == '+'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `+=`
					return NewOperator(AddAssign, 2);
				}

				// it is `+`
				return NewOperator(Add);
			}
			else if curChar == '-'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '>'
				{
					// it is `->`
					return NewOperator(Arrow, 2);
				}
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `-=`
					return NewOperator(SubAssign, 2);
				}
				// it is `-`
				return NewOperator(Sub);
			}
			else if curChar == '/'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '/'
				{
					// it is a line comment `//`
					while position < Source.Text.Length and Source.Text[position] <> '\r' and Source.Text[position] <> '\n'
					{
						position += 1;
					}

					continue;
				}
				// it is `/`
				return NewOperator(Slash);
			}
			else if curChar == '<'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '>'
				{
					// it is `<>`
					return NewOperator(NotEqual, 2);
				}
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `<=`
					return NewOperator(LessThanOrEqual, 2);
				}
				// it is `<`
				return NewOperator(LessThan);
			}
			else if curChar == '>'
			{
				if position + 1 < Source.Text.Length and Source.Text[position + 1] == '='
				{
					// it is `>=`
					return NewOperator(GreaterThanOrEqual, 2);
				}
				// it is `>`
				return NewOperator(GreaterThan);
			}
			else if curChar == '"'
			{
				end = position + 1;
				var escaped: bool = false;
				while end < Source.Text.Length and (Source.Text[end] <> '"' or escaped)
				{
					escaped = Source.Text[end] == '\\' and not escaped;
					end += 1;
				}

				end += 1; // To include the close quote
				return NewToken(StringLiteral, end);
			}
			else if curChar == '\''
			{
				end = position + 1;
				var escaped: bool = false;
				while end < Source.Text.Length and (Source.Text[end] <> '\'' or escaped)
				{
					escaped = Source.Text[end] == '\\' and not escaped;
					end += 1;
				}

				end += 1; // To include the close quote
				return NewToken(CodePointLiteral, end);
			}
			else
			{
				if IsIdentifierChar(curChar)
				{
					end = position + 1;
					while IsIdentifierChar(Source.Text[end])
					{
						end += 1;
					}
					return NewIdentifierOrKeyword(end);
				}
				if(IsNumberChar(curChar))
				{
					end = position + 1;
					while IsNumberChar(Source.Text[end])
					{
						end += 1;
					}
					return NewToken(Number, end);
				}
				return NewToken(Error, position + 1);
				//TODO Definitions.Error("Lexer: Invalid character `" + curChar + "`");
			}
		}

		return null;
	}

	private NewIdentifierOrKeyword(mut self, end: uint) -> Syntax_Node
	{
		let length: uint = end-position;
		let value: string = Source.Text.Substring(position, length);
		var type: int;
		if value == "new"
			{ type = NewKeyword; }
		else if value == "not"
			{ type = NotOperator; }
		else if value == "null"
			{ type = NullKeyword; }
		else if value == "self"
			{ type = SelfKeyword; }
		else if value == "true"
			{ type = TrueKeyword; }
		else if value == "false"
			{ type = FalseKeyword; }
		else if value == "mut"
			{ type = MutableKeyword; }
		else if value == "code_point"
			{ type = CodePoint; }
		else if value == "string"
			{ type = String; }
		else if value == "int"
			{ type = Int; }
		else if value == "bool"
			{ type = Bool; }
		else if value == "void"
			{ type = Void; }
		else if value == "uint"
			{ type = UnsignedInt; }
		else if value == "var"
			{ type = VarKeyword; }
		else if value == "and"
			{ type = AndKeyword; }
		else if value == "or"
			{ type = OrKeyword; }
		else if value == "return"
			{ type = ReturnKeyword; }
		else if value == "loop"
			{ type = LoopKeyword; }
		else if value == "while"
			{ type = WhileKeyword; }
		else if value == "for"
			{ type = ForKeyword; }
		else if value == "let"
			{ type = LetKeyword; }
		else if value == "in"
			{ type = InKeyword; }
		else if value == "do"
			{ type = DoKeyword; }
		else if value == "if"
			{ type = IfKeyword; }
		else if value == "else"
			{ type = ElseKeyword; }
		else if value == "break"
			{ type = BreakKeyword; }
		else if value == "continue"
			{ type = ContinueKeyword; }
		else
			{ type = Identifier; }

		return NewToken(type, end);
	}

	private NewOperator(mut self, type: int) -> Syntax_Node
	{
		return NewToken(type, position + 1);
	}

	private NewOperator(mut self, type: int, length: uint) -> Syntax_Node
	{
		return NewToken(type, position + length);
	}

	private NewToken(mut self, type: int, end: uint) -> Syntax_Node
	{
		let token: Syntax_Node = new Syntax_Node(type, Source, position, end-position);
		position = end;
		return token;
	}

	private IsIdentifierChar(c: code_point) -> bool
	{
		return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == '_';
	}

	private IsNumberChar(c: code_point) -> bool
	{
		return c >= '0' and c <= '9';
	}
}
