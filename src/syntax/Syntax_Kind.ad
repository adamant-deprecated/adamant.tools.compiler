public let SkippedTokens: int = 99999; // Problem with -1 around const in C
public let IdentifierName: int = 35; // A name that is just an Identifier
public let GenericName: int = 36; // An identifier with type arguments
public let QualifiedName: int = 37; // A name that is qualified by a name and a dot
public let PackageQualifiedName: int = 38; // `⧼QualifiedName⧽::⧼QualifiedName⧽`
public let OptionalType: int = 40; // `⧼Type⧽?`
public let ParameterList: int = 48; // `(Parameter, ⧼...⧽)` may include a SelfParameter
public let Parameter: int = 49; // `⧼VarKeyword⧽ ⧼Identifier⧽: ⧼Type⧽` A parameter in a ParameterList
public let SelfParameter: int = 50; // `self` or `mut self`
public let MutableType: int = 52; // `mut ⧼Type⧽`
public let NewExpression: int = 53; // `new ⧼Type⧽⧼ParameterList⧽`
public let ArgumentList: int = 54; // `(⧼Expression⧽, ⧼...⧽)` may include a SelfParameter
public let NotExpression: int = 55; // `not ⧼Expression⧽`
public let ParenthesizedExpression: int = 56; // `(⧼Expression⧽)`
public let NoneLiteralExpression: int = 57; // `none`
public let SelfExpression: int = 58; // `self`
public let TrueLiteralExpression: int = 59; // `true`
public let FalseLiteralExpression: int = 60; // `false`
public let StringLiteralExpression: int = 61;
public let CodePointLiteralExpression: int = 62;
public let NumericLiteralExpression: int = 63;
public let AssignmentExpression: int = 64;
public let OrExpression: int = 65;
public let AndExpression: int = 66;
public let EqualExpression: int = 67;
public let NotEqualExpression: int = 68;
public let AndKeyword: int = 69; // `and`
public let OrKeyword: int = 70; // `or`
public let ComparisonExpression: int = 71;
public let AddExpression: int = 72;
public let SubtractExpression: int = 73;
public let InvocationExpression: int = 74;
public let MemberAccessExpression: int = 75;
public let ElementAccessExpression: int = 76;
public let NegateExpression: int = 77; // `-⧼Expression⧽`
public let ReturnStatement: int = 79; // `return ⧼Expression⧽;` or `return;`
public let LoopStatement: int = 81; // `loop ⧼Block⧽`
public let Block: int = 82; // `{ ⧼Statement⧽ ⧼...⧽ }`
public let WhileStatement: int = 84; // `while ⧼Expression⧽ ⧼Block⧽`
public let ForStatement: int = 86; // `for  ⧼Block⧽`
public let VariableDeclaration: int = 88; // `⧼LetKeyword|VarKeyword⧽ ⧼Identifier⧽ = ⧼Expression⧽`
public let LocalDeclarationStatement: int = 89; // `⧼VariableDeclaration⧽;`
public let DoWhileStatement: int = 92; // `do ⧼Block⧽ while ⧼Expression⧽;`
public let IfStatement: int = 95; // `if ⧼Expression⧽ ⧼Block⧽ ⧼ElseClause?⧽`
public let ElseClause: int = 96; // `else ⧼Block⧽` or `else ⧼IfStatement⧽`
public let BreakStatement: int = 98; // `break;`
public let ContinueStatement: int = 100; // `continue;`
public let ExpressionStatement: int = 101; // `⧼Expression⧽;`
public let ConstructorDeclaration: int = 106;
public let FieldDeclaration: int = 107;
public let MethodDeclaration: int = 108;
public let GlobalDeclaration: int = 109;
public let ClassDeclaration: int = 111;
public let EnumDeclaration: int = 114;
public let EnumMemberDeclaration: int = 115;
public let FunctionDeclaration: int = 116;
public let CompilationUnit: int = 117;
public let PackageNode: int = 118;
public let RemainderExpression: int = 120; // `⧼Expression⧽ % ⧼Expression⧽`
public let MultiplyExpression: int = 124; // `⧼Expression⧽ * ⧼Expression⧽`
public let DivideExpression: int = 125; // `⧼Expression⧽ / ⧼Expression⧽`
public let StructDeclaration: int = 127;
public let ImmutableType: int = 128; // `⧼Type⧽` without `mut` before it
public let NamespaceDeclaration: int = 129;
public let MatchStatement: int = 131;
public let MatchArm: int = 134;
public let MatchPattern: int = 135;
