public class Syntax_Node
{
    public let kind: int;
    public let is_missing: bool;
    public let source: Source_Text;
    public let start: int;
    public let byte_length: int; // TODO is this ByteLength?
    public let children: system.collections.List<Syntax_Node>;
    public let node_diagnostics: mut system.collections.List<Diagnostic>;

    public new(type: int, source: Source_Text, start: int, length: int)
    {
        self.kind = type;
        self.is_missing = false;
        self.source = source;
        self.start = start;
        self.byte_length = length;
        self.children = new system.collections.List<Syntax_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    public new(type: int, isMissing: bool, source: Source_Text, start: int, length: int)
    {
        self.kind = type;
        self.is_missing = isMissing;
        self.source = source;
        self.start = start;
        self.byte_length = length;
        self.children = new system.collections.List<Syntax_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    public new(type: int, child: Syntax_Node)
    {
        self.kind = type;
        self.is_missing = child.is_missing;
        self.source = child.source;
        self.start = child.start;
        self.byte_length = child.byte_length;
        let children: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
        add_item(children, child);
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    // TODO we want to take ownership of the child list
    public new(type: int, children: system.collections.List<Syntax_Node>)
    {
        self.kind = type;
        self.is_missing = false;
        // TODO enforce that list is not empty, for now we rely on `children[0]` failing
        let first_child: Syntax_Node = children[0];
        self.source = first_child.source;
        self.start = first_child.start;
        let last_child: Syntax_Node = children[children.count - 1];
        self.byte_length = last_child.start - self.start + last_child.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    public new missing(type: int, source: Source_Text, start: int)
    {
        self.kind = type;
        self.is_missing = true;
        self.source = source;
        self.start = start;
        self.byte_length = 0;
        self.children = new system.collections.List<Syntax_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        let span: Text_Span = new Text_Span(start, 0);
        add_item(self.node_diagnostics, new Diagnostic(CompilationError, Parsing, source, span, "Missing token of type " + int_to_string(type)));
    }

    public new skipped(skipped_node: Syntax_Node)
    {
        self.kind = SkippedTokens;
        self.is_missing = skipped_node.is_missing;
        self.source = skipped_node.source;
        self.start = skipped_node.start;
        self.byte_length = skipped_node.byte_length;
        let children: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
        add_item(children, skipped_node);
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        let span: Text_Span = new Text_Span(skipped_node.start, skipped_node.byte_length);
        add_item(self.node_diagnostics, new Diagnostic(CompilationError, Parsing, skipped_node.source, span, "Skipped unexpected token of type " + int_to_string(skipped_node.kind)));
    }

    public new skipped(skipped_nodes: system.collections.List<Syntax_Node>)
    {
        self.kind = SkippedTokens;
        self.is_missing = false;
        // TODO enforce that list is not empty, for now we rely on `children[0]` failing
        let first_child: Syntax_Node = skipped_nodes[0];
        self.source = first_child.source;
        self.start = first_child.start;
        let last_child: Syntax_Node = skipped_nodes[skipped_nodes.count - 1];
        self.byte_length = last_child.start - self.start + last_child.byte_length;
        self.children = new system.collections.List<Syntax_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
        let span: Text_Span = new Text_Span(self.start, self.byte_length);
        add_item(self.node_diagnostics, new Diagnostic(CompilationError, Parsing, self.source, span, "Skipped " + int_to_string(skipped_nodes.count) + " unexpected token(s)"));
    }
}

public get_syntax_text(syntax: Syntax_Node) -> string
{
    return substring(syntax.source.text, syntax.start, syntax.byte_length);
}

public first_child_syntax(syntax: Syntax_Node, type: int) -> Syntax_Node?
{
    for let child: Syntax_Node in syntax.children
    {
        if child.kind == type
            { return child; }
    }
    return none;
}

public has_child(syntax: Syntax_Node, type: int) -> bool
{
    for let child: Syntax_Node in syntax.children
    {
        if child.kind == type
            { return true; }
    }
    return false;
}

public add(syntax: Syntax_Node, diagnostic: Diagnostic) -> void
{
    add_item(syntax.node_diagnostics, diagnostic);
}

// We are returning ownership of the list, so they can mutate it if wanted
public all_diagnostics(syntax: Syntax_Node) -> mut system.collections.List<Diagnostic>
{
    var diagnostics: mut system.collections.List<Diagnostic> = new system.collections.List<Diagnostic>();
    collect_syntax_diagnostics(syntax, diagnostics);
    return diagnostics;
}

public collect_syntax_diagnostics(syntax: Syntax_Node, diagnostics: mut system.collections.List<Diagnostic>) -> void
{
    for let diagnostic: Diagnostic in syntax.node_diagnostics
    {
        add_item(diagnostics, diagnostic);
    }

    for let child: Syntax_Node in syntax.children
    {
        collect_syntax_diagnostics(child, diagnostics);
    }
}

// TODO this should only be on things like class, struct that have members
public members(syntax: Syntax_Node) -> system.collections.List<Syntax_Node>
{
    let members: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
    for let child: Syntax_Node in syntax.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind == ConstructorDeclaration
            or child.kind == FieldDeclaration
            or child.kind == MethodDeclaration
        {
            add_item(members, child);
        }
    }
    return members;
}

// TODO this should only be on things like parameter list and function
public parameters(syntax: Syntax_Node) -> system.collections.List<Syntax_Node>
{
    let parameters: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
    for let child: Syntax_Node in syntax.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind == Parameter
            or child.kind == SelfParameter
        {
            add_item(parameters, child);
        }
    }
    return parameters;
}

// TODO this should only be on things like block
public statements(syntax: Syntax_Node) -> system.collections.List<Syntax_Node>
{
    let statements: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
    for let child: Syntax_Node in syntax.children
    {
        // TODO fix this to a more reliable means of telling what should be visited
        if child.kind =/= LeftBrace
            and child.kind =/= RightBrace
        {
            add_item(statements, child);
        }
    }
    return statements;
}

// TODO this should only be on things that would have access modifiers
public access_modifier(syntax: Syntax_Node) -> Syntax_Node?
{
    for let child: Syntax_Node in syntax.children
    {
        if child.kind == PublicKeyword
            or child.kind == ProtectedKeyword
            or child.kind == InternalKeyword
            or child.kind == PrivateKeyword
        {
            return child;
        }
    }
    return none;
}
