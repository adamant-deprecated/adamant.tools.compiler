public class Syntax_Node
{
    public let kind: int;
    public let is_missing: bool;
    public let source: Source_Text;
    public let start: uint;
    public let byte_length: uint; // TODO is this ByteLength?
    public let children: system.collections.List<Syntax_Node>;
    public let node_diagnostics: mut system.collections.List<Diagnostic>;

    public new(type: int, source: Source_Text, start: uint, length: uint)
    {
        self.kind = type;
        self.is_missing = false;
        self.source = source;
        self.start = start;
        self.byte_length = length;
        self.children = new system.collections.List<Syntax_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    public new(type: int, isMissing: bool, source: Source_Text, start: uint, length: uint)
    {
        self.kind = type;
        self.is_missing = isMissing;
        self.source = source;
        self.start = start;
        self.byte_length = length;
        self.children = new system.collections.List<Syntax_Node>();
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    public new(type: int, child: Syntax_Node)
    {
        self.kind = type;
        self.is_missing = child.is_missing;
        self.source = child.source;
        self.start = child.start;
        self.byte_length = child.byte_length;
        let children: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
        children.add(child);
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    // TODO we want to take ownership of the child list
    public new(type: int, children: system.collections.List<Syntax_Node>)
    {
        self.kind = type;
        self.is_missing = false;
        // TODO enforce that list is not empty, for now we rely on `children[0]` failing
        self.source = children[0].source;
        self.start = children[0].start;
        let lastChild: Syntax_Node = children[|children| - 1];
        self.byte_length = lastChild.start - start + lastChild.byte_length;
        self.children = children;
        self.node_diagnostics = new system.collections.List<Diagnostic>();
    }

    public get_text(self) -> string
    {
        return source.text.Substring(start, byte_length);
    }

    public first_child(self, type: int) -> Syntax_Node?
    {
        for let child: Syntax_Node in children
        {
            if child.kind == type
                { return child; }
        }
        return none;
    }

    public has_child(self, type: int) -> bool
    {
        for let child: Syntax_Node in children
        {
            if child.kind == type
                { return true; }
        }
        return false;
    }

    public add(self, diagnostic: Diagnostic) -> void
    {
        node_diagnostics.add(diagnostic);
    }

    // We are returning ownership of the list, so they can mutate it if wanted
    public all_diagnostics(self) -> mut system.collections.List<Diagnostic>
    {
        var diagnostics: mut system.collections.List<Diagnostic> = new system.collections.List<Diagnostic>();
        collect_diagnostics(diagnostics);
        return diagnostics;
    }

    public collect_diagnostics(self, diagnostics: mut system.collections.List<Diagnostic>) -> void
    {
        for let diagnostic: Diagnostic in node_diagnostics
        {
            diagnostics.add(diagnostic);
        }

        for let child: Syntax_Node in children
        {
            child.collect_diagnostics(diagnostics);
        }
    }

    // TODO this should only be on things like class, struct that have members
    public members(self) -> system.collections.List<Syntax_Node>
    {
        let members: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
        for let child: Syntax_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind == ConstructorDeclaration
                or child.kind == FieldDeclaration
                or child.kind == MethodDeclaration
            {
                members.add(child);
            }
        }
        return members;
    }

    // TODO this should only be on things like parameter list and function
    public parameters(self) -> system.collections.List<Syntax_Node>
    {
        let parameters: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
        for let child: Syntax_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind == Parameter
                or child.kind == SelfParameter
            {
                parameters.add(child);
            }
        }
        return parameters;
    }

    // TODO this should only be on things like block
    public statements(self) -> system.collections.List<Syntax_Node>
    {
        let statements: mut system.collections.List<Syntax_Node> = new system.collections.List<Syntax_Node>();
        for let child: Syntax_Node in children
        {
            // TODO fix this to a more reliable means of telling what should be visited
            if child.kind =/= LeftBrace
                and child.kind =/= RightBrace
            {
                statements.add(child);
            }
        }
        return statements;
    }

    // TODO this should only be on things that would have access modifiers
    public access_modifier(self) -> Syntax_Node?
    {
        for let child: Syntax_Node in children
        {
            if child.kind == PublicKeyword
                or child.kind == ProtectedKeyword
                or child.kind == InternalKeyword
                or child.kind == PrivateKeyword
            {
                return child;
            }
        }
        return none;
    }
}

// TODO make this a named constructor
public new_syntax_node_missing(type: int, source: Source_Text, start: uint) -> Syntax_Node
{
    let node: mut Syntax_Node = new Syntax_Node(type, true, source, start, 0);
    let span: Text_Span = new Text_Span(start, 0);
    node.add(new Diagnostic(CompilationError, Parsing, source, span, "Missing token of type " + type));
    return node;
}

// TODO make this a named constructor
public new_Syntax_Node_Skipped(skipped_node: Syntax_Node) -> Syntax_Node
{
    let node: mut Syntax_Node = new Syntax_Node(SkippedTokens, skipped_node);
    let span: Text_Span = new Text_Span(skipped_node.start, skipped_node.byte_length);
    node.add(new Diagnostic(CompilationError, Parsing, skipped_node.source, span, "Skipped unexpected token of type " + skipped_node.kind));
    return node;
}

// TODO make this a named constructor
public new_Syntax_Node_Skipped(skipped_nodes: system.collections.List<Syntax_Node>) -> Syntax_Node
{
    let node: mut Syntax_Node = new Syntax_Node(SkippedTokens, skipped_nodes);
    let span: Text_Span = new Text_Span(node.start, node.byte_length);
    node.add(new Diagnostic(CompilationError, Parsing, node.source, span, "Skipped " + |skipped_nodes| + " unexpected token(s)"));
    return node;
}
