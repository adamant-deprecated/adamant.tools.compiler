public class Symbol_Builder // TODO change immutable class name to snake_case when supported
{
	// Takes a package and builds the symbols for it
	public BuildSymbols(self, compilationUnits: System.Collections.List<mut Semantic_Node>) -> Symbol
	{
		// TODO eventually the package symbol should have a name so that we can look up names in front of the package qualifier
		let packageSymbol: mut Symbol = new Symbol(none, "");
		for let compilationUnit: mut Semantic_Node in compilationUnits
		{
			if compilationUnit.Type <> CompilationUnit
				{ ThrowException("`Symbol_Builder.BuildSymbols(...)` called with node of type " + compilationUnit.Type); }

			BuildSymbols(packageSymbol, compilationUnit);
		}

		BuildRuntimeLibrarySymbols(packageSymbol);

		return packageSymbol;
	}

	// Because a single call could produce multiple symbols, we pass the symbol collection in and add symbols to it.
	// Once we have generators, this would be a good place to use them.
	private BuildSymbols(self, parent: Symbol, node: mut Semantic_Node) -> void
	{
		if node.Type == CompilationUnit
		{
			for let declaration: mut Semantic_Node in node.Children
			{
				BuildSymbols(parent, declaration);
			}
		}
		else if node.Type == FunctionDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let functionSymbol: Symbol = new Symbol(parent, name);
			functionSymbol.Declarations.Add(node);

			// TODO add parameter symbols
			// TODO figure out how to handle body

			parent.Children.Add(functionSymbol);
			node.BindSymbol(functionSymbol);
		}
		else if node.Type == ClassDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let classSymbol: Symbol = new Symbol(parent, name);
			classSymbol.Declarations.Add(node);
			for let member: mut Semantic_Node in node.Members()
			{
				BuildSymbols(classSymbol, member);
			}

			parent.Children.Add(classSymbol);
			node.BindSymbol(classSymbol);
		}
		else if node.Type == StructDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let structSymbol: Symbol = new Symbol(parent, name);
			structSymbol.Declarations.Add(node);
			for let member: mut Semantic_Node in node.Members()
			{
				BuildSymbols(structSymbol, member);
			}

			parent.Children.Add(structSymbol);
			node.BindSymbol(structSymbol);
		}
		else if node.Type == ConstructorDeclaration
		{
			// TODO how do we distinguish this from a symbol someone could get to by using `new ?
			let constructorSymbol: Symbol = new Symbol(none, "new");
			constructorSymbol.Declarations.Add(node);
			parent.Children.Add(constructorSymbol);
			node.BindSymbol(constructorSymbol);
		}
		else if node.Type == FieldDeclaration
		{
			let name: string = node.FirstChildOfType(VariableDeclaration).FirstChildOfType(Identifier).GetText();
			let fieldSymbol: Symbol = new Symbol(none, name);
			fieldSymbol.Declarations.Add(node);
			parent.Children.Add(fieldSymbol);
			node.BindSymbol(fieldSymbol);
		}
		else if node.Type == MethodDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let methodSymbol: Symbol = new Symbol(parent, name);
			methodSymbol.Declarations.Add(node);

			// TODO add parameter symbols
			// TODO figure out how to handle body

			parent.Children.Add(methodSymbol);
			node.BindSymbol(methodSymbol);
		}
		else if node.Type == EnumDeclaration
		{
			let name: string = node.FirstChildOfType(Identifier).GetText();
			let enumSymbol: Symbol = new Symbol(parent, name);
			enumSymbol.Declarations.Add(node);
			// TODO add enum member symbols
			parent.Children.Add(enumSymbol);
			node.BindSymbol(enumSymbol);
		}
		else if node.Type == GlobalDeclaration
		{
			let name: string = node.FirstChildOfType(VariableDeclaration).FirstChildOfType(Identifier).GetText();
			let globalDeclarationSymbol: Symbol = new Symbol(none, name);
			globalDeclarationSymbol.Declarations.Add(node);
			parent.Children.Add(globalDeclarationSymbol);
			node.BindSymbol(globalDeclarationSymbol);
		}
		else if node.Type == EndOfFileToken
		{
			// Ignore these nodes
		}
		else
		{
			ThrowException("`Symbol_Builder.Build()` unimplemented node type " + node.Type);
		}
	}

	/// This builds up a set of symbols that are actually in the Runtime Library
	/// as if they were part of the current package.
	///
	/// TODO this should actually be a separate package
	private BuildRuntimeLibrarySymbols(self, package: Symbol) -> void
	{
		package.Children.Add(new Symbol(package, "resource_manager"));

		let system: Symbol = new Symbol(package, "System");
		package.Children.Add(system);

		let collections: Symbol = new Symbol(system, "Collections");
		system.Children.Add(collections);
		collections.Children.Add(new Symbol(collections, "List"));

		let console: Symbol = new Symbol(system, "Console");
		system.Children.Add(console);
		console.Children.Add(new Symbol(console, "Console"));
		console.Children.Add(new Symbol(console, "Arguments"));

		let io: Symbol = new Symbol(system, "IO");
		system.Children.Add(io);
		io.Children.Add(new Symbol(system, "File_Reader"));
		io.Children.Add(new Symbol(system, "File_Writer"));

		let text: Symbol = new Symbol(system, "Text");
		system.Children.Add(text);
		text.Children.Add(new Symbol(text, "String_Builder"));
	}
}
