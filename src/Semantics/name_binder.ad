public class Name_Binder // TODO change immutable class name to snake_case when supported
{
	public Bind(self, package: Package) -> void
	{
		let globalScope: Binding_Scope = new Binding_Scope(none, package.Symbol.Children, package.PrimitiveTypes);
		for let compilationUnit: mut Semantic_Node in package.CompilationUnits
		{
			Bind(compilationUnit, globalScope);
		}
	}

	private Bind(self, node: mut Semantic_Node, scope: Binding_Scope) -> void
	{
		if node.Type == CompilationUnit
		{
			for let child: mut Semantic_Node in node.Children
			{
				Bind(child, scope);
			}
		}
		else if node.Type == FunctionDeclaration
			or node.Type == MethodDeclaration
		{
			let parameters: mut Semantic_Node = node.FirstChildOfType(ParameterList);
			Bind(parameters, scope);
			let returnType: mut Semantic_Node = node.Children[4];
			BindType(returnType, scope);
			// TODO make a new scope with the parameters in it
			let body: mut Semantic_Node = node.FirstChildOfType(Block);
			Bind(body, scope);
		}
		else if node.Type == ParameterList
		{
			for let parameter: mut Semantic_Node in node.ChildrenOfType(Parameter)
			{
				Bind(parameter, scope);
			}
		}
		else if node.Type == Parameter
		{
			let type: mut Semantic_Node = node.Children[|node.Children| - 1];
			BindType(type, scope);
		}
		else if node.Type == ClassDeclaration
			or node.Type == StructDeclaration
		{
			for let member: mut Semantic_Node in node.Members()
			{
				Bind(member, scope);
			}
		}
		else if node.Type == FieldDeclaration
			or node.Type == GlobalDeclaration
		{
			let variableDeclaration: mut Semantic_Node = node.FirstChildOfType(VariableDeclaration);
			Bind(variableDeclaration, scope);

		}
		else if node.Type == ConstructorDeclaration
		{
			let parameters: mut Semantic_Node = node.FirstChildOfType(ParameterList);
			Bind(parameters, scope);
			// TODO make a new scope with the parameters in it
			let body: mut Semantic_Node = node.FirstChildOfType(Block);
			Bind(body, scope);
		}
		else if node.Type == VariableDeclaration
		{
			let type: mut Semantic_Node = node.Children[3];
			BindType(type, scope);
			if |node.Children| == 6
			{
				let initalizer: mut Semantic_Node = node.Children[5];
				Bind(initalizer, scope);
			}
		}
		else if node.Type == EnumDeclaration
		{
			// Haven't yet implemented anything in enums that requires name binding
		}

		else if node.Type == Block
		{
			for let statement: mut Semantic_Node in node.Statements()
			{
				Bind(statement, scope);
			}
		}
		else if node.Type == LoopStatement
		{
			Bind(node.FirstChildOfType(Block), scope);
		}
		else if node.Type == WhileStatement
		{
			Bind(node.Children[1], scope); // condition expression
			Bind(node.FirstChildOfType(Block), scope);
		}
		else if node.Type == DoWhileStatement
		{
			Bind(node.FirstChildOfType(Block), scope);
			Bind(node.Children[3], scope); // condition expression
		}
		else if node.Type == ForStatement
		{
			Bind(node.FirstChildOfType(VariableDeclaration), scope);
			Bind(node.FirstChildOfType(Block), scope);
		}
		else if node.Type == LocalDeclarationStatement
		{
			Bind(node.FirstChildOfType(VariableDeclaration), scope);
		}
		else if node.Type == IfStatement
		{
			Bind(node.Children[1], scope); // condition expression
			Bind(node.FirstChildOfType(Block), scope);
			let elseClause: mut Semantic_Node? = node.FirstChildOfType(ElseClause);
			if elseClause <> none
			{
				Bind(elseClause, scope);
			}
		}
		else if node.Type == ElseClause
		{
			// This might be a good place for some kind of coalesce operator
			let block: mut Semantic_Node? = node.FirstChildOfType(Block);
			if block <> none
			{
				Bind(block, scope);
			}
			else
			{
				Bind(node.FirstChildOfType(IfStatement), scope);
			}
		}
		else if node.Type == ExpressionStatement
		{
			Bind(node.Children[0], scope);
		}
		else if node.Type == ReturnStatement
		{
			let child: mut Semantic_Node = node.Children[1];
			if child.Type <> Semicolon
				{ Bind(child, scope); }
		}
		else if node.Type == NewExpression
		{
			BindType(node.Children[1], scope); // Type
			Bind(node.Children[2], scope); // Call Arguments
		}
		else if node.Type == NotExpression
			or node.Type == ParenthesizedExpression
			or node.Type == MagnitudeExpression
			or node.Type == NegateExpression
		{
			Bind(node.Children[1], scope);
		}
		else if node.Type == AssignmentExpression
			or node.Type == AndExpression
			or node.Type == OrExpression
			or node.Type == EqualExpression
			or node.Type == NotEqualExpression
			or node.Type == ComparisonExpression
			or node.Type == AddExpression
			or node.Type == SubtractExpression
			or node.Type == ElementAccessExpression
			or node.Type == RemainderExpression
			or node.Type == MultiplyExpression
			or node.Type == DivideExpression
		{
			Bind(node.Children[0], scope); // lhs
			Bind(node.Children[2], scope); // rhs
		}
		else if node.Type == MemberAccessExpression
		{
			Bind(node.Children[0], scope); // Before dot
			// TODO bind member, need type of expression to left
		}
		else if node.Type == InvocationExpression
		{
			Bind(node.Children[0], scope); // Thing Being Invoked
			Bind(node.Children[1], scope); // Argument List
		}
		else if node.Type == ArgumentList
		{
			for let child: mut Semantic_Node in node.Children
			{
				if child.Type <> LeftParen
					and child.Type <> Comma
					and child.Type <> RightParen
				{
					Bind(child, scope);
				}
			}
		}
		else if node.Type == NumericLiteralExpression
			or node.Type == BreakStatement
			or node.Type == ContinueStatement
			or node.Type == NoneLiteralExpression
			or node.Type == SelfExpression
			or node.Type == TrueLiteralExpression
			or node.Type == FalseLiteralExpression
			or node.Type == StringLiteralExpression
			or node.Type == CodePointLiteralExpression
			or node.Type == IdentifierName // For now, ignore variable references outside known types
			or node.Type == EndOfFileToken
		{
			// Ignore these nodes
		}
		else
		{
			ThrowException("`Name_Binder.Bind()` unimplemented node type " + node.Type);
		}
	}

	private BindType(self, node: mut Semantic_Node, scope: Binding_Scope) -> void
	{
		if node.Type == PredefinedType
		{
			let name: string = node.Children[0].GetText();
			let symbol: Symbol = scope.GetPrimitive(name);
			if symbol == none { ThrowException("`Name_Binder.BindType()` no symbol for primitive type " + name); }
			node.BindSymbol(symbol);
		}
		else if node.Type == MutableType
		{
			let innerType: mut Semantic_Node = node.Children[1];
			BindType(innerType, scope);
		}
		else if node.Type == OptionalType
		{
			let innerType: mut Semantic_Node = node.Children[0];
			BindType(innerType, scope);
		}
		else if node.Type == QualifiedName
		{
			let qualifier: mut Semantic_Node = node.Children[0];
			BindType(qualifier, scope);
			// TODO rather than throwing an exception. We should say we can't resolve the subsequent identifiers
			if qualifier.Symbol == none { ThrowException("`Name_Binder.BindType()` no symbol for qualifier " + qualifier.GetText()); }
			let name: mut Semantic_Node = node.Children[2];
			if name.Type == IdentifierName
			{
				let symbol: Symbol = qualifier.Symbol.Get(name.GetText(), IdentifierSymbol);
				name.BindSymbol(symbol);
				node.BindSymbol(symbol); // Set it on the name as a whole, not just the identifier
			}
			else if name.Type == GenericName
			{
				let identiferName: mut Semantic_Node = name.FirstChildOfType(IdentifierName);
				let symbol: Symbol = qualifier.Symbol.Get(identiferName.GetText(), IdentifierSymbol);
				identiferName.BindSymbol(symbol);
				node.BindSymbol(symbol); // Set it on the name as a whole, not just the identifier

				// TODO need way to get the generic arguments
				var typeArg: bool = false;
				for let typeArgument: mut Semantic_Node in name.Children
				{
					if typeArg
					{
						if typeArgument.Type <> GreaterThan
						{
							BindType(typeArgument, scope);
						}
					}
					else if typeArgument.Type == LessThan
					{
						typeArg = true;
					}
				}
			}
			else
			{
				ThrowException("Unreachable: `Name_Binder.Bind(..)` name.Type = " + name.Type);
			}
		}
		else if node.Type == IdentifierName
		{
			let name: string = node.GetText();
			let symbol: Symbol = scope.Lookup(name);
			if symbol == none
			{
				node.Add(new Diagnostic(FatalCompilationError, Analysis, node.Source, node.GetTextSpan(), "Could not resolve name `" + name + "`"));
			}
			else
			{
				node.BindSymbol(symbol);
			}
		}
		else
		{
			ThrowException("`Name_Binder.BindType()` unimplemented node type " + node.Type);
		}
	}
}
