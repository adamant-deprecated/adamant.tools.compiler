public class Emitter
{
	private let package: Package;
	private let resources: System.Collections.List<Source_Text>;
	// TODO fix casing on these field names
	private var TypeDeclarations: mut Source_File_Builder;
	private var FunctionDeclarations: mut Source_File_Builder;
	private var ClassDeclarations: mut Source_File_Builder;
	private var GlobalDefinitions: mut Source_File_Builder;
	private var Definitions: mut Source_File_Builder;

	// TODO compute these in a semantic analysis phase
	private var MainFunctionReturnType: string;
	private var MainFunctionAcceptsConsole: bool;
	private var MainFunctionAcceptsArgs: bool;

	public new(package: Package, resources: System.Collections.List<Source_Text>)
	{
		self.package = package;
		self.resources = resources;
	}

	public Emit(mut self) -> string
	{
		TypeDeclarations = new Source_File_Builder();
		FunctionDeclarations = new Source_File_Builder();
		ClassDeclarations = new Source_File_Builder();
		GlobalDefinitions = new Source_File_Builder();
		Definitions = new Source_File_Builder();
		MainFunctionReturnType = "";
		MainFunctionAcceptsConsole = false;
		MainFunctionAcceptsArgs = false;

		EmitPreamble();

		for let compilationUnit: Semantic_Node in package.CompilationUnits
		{
			EmitCompilationUnit(compilationUnit);
		}

		EmitEntryPointAdapter();

		return TypeDeclarations.ToString()
			+ FunctionDeclarations.ToString()
			+ ClassDeclarations.ToString()
			+ GlobalDefinitions.ToString()
			+ Definitions.ToString();
	}

	// Converts a type to C++
	private convert_type_name(type: Semantic_Node) -> string
	{
		if type.Type == PredefinedType
		{
			let keyword: Semantic_Node = type.children[0];
			// void we still use the C++ keyword
			if keyword.Type == Void
				{ return keyword.get_text(); }
			// `int`, `bool`, `string`, `code_point`, `uint``
			return "p_" + keyword.get_text();
		}

		if type.Type == IdentifierName
		{
			return "::" + type.get_text() + "_";
		}
		if type.Type == QualifiedName
		{
			return convert_type_name(type.children[0]) + convert_type_name(type.children[2]);
		}
		if type.Type == GenericName
		{
			return convert_type_name(type.children[0]) + "<" + convert_type(true, type.children[2]) + ">";
		}

		return format_error("Unexpected Token of type "+type.Type+" found in convert_type_name(), `"+type.get_text()+"`");
	}

	private convert_reference_type(mutable_binding: bool, var type: Semantic_Node, nullable: bool, mutable_value: bool) -> string
	{
		var cpp_type: string = convert_type_name(type);
		if not mutable_value { cpp_type = cpp_type + " const"; }
		cpp_type = cpp_type + " *";
		if nullable
			{ cpp_type = cpp_type + "_Nullable"; }
		else
			{ cpp_type = cpp_type + "_Nonnull"; }
		if not mutable_binding { cpp_type = cpp_type + " const" ; }
		return cpp_type;
	}

	// Converts a type to C++
	private convert_type(mutable_binding: bool, var type: Semantic_Node, optional: bool) -> string
	{
		let mutable_value: bool = type.Type == MutableType;
		if mutable_value
		{
			type = type.children[1]; // Remove the mutable wrapper
		}
		else if type.Type == ImmutableType
		{
			type = type.children[0]; // Remove the immutable wrapper
		}
		else
		{
			return format_error("Expected mutable or immutable type in convert_type(). Found token `"+type.get_text()+"` of type "+type.Type);
		}

		if type.Type == OptionalType
		{
			let optional_type: Semantic_Node = type.children[0];
			assert(optional_type.Type == MutableType or optional_type.Type == ImmutableType);
			if optional_type.is_value_type()
			{
				// Optional<T> is a const struct
				return "p_optional<" + convert_type(true, optional_type, true) + "> const";
			}
			else
			{
				return convert_type(mutable_binding, optional_type, true);
			}
		}
		else
		{
			if type.is_value_type()
			{
				var cpp_type: string = convert_type_name(type);
				if not mutable_binding and not mutable_value
					{ cpp_type = cpp_type + " const"; }
				return cpp_type;
			}
			else
			{
				return convert_reference_type(mutable_binding, type, optional, mutable_value);
			}
		}
	}

	private convert_type(mutable_binding: bool, type: Semantic_Node) -> string
	{
		return convert_type(mutable_binding, type, false); // not optional
	}

	private ConvertParameterList(mut self, parameterList: Semantic_Node, isMainFunction: bool) -> string
	{
		let builder: mut System.Text.String_Builder = new System.Text.String_Builder();
		builder.Append("(");
		var firstParameter: bool = true;
		for let parameter: Semantic_Node in parameterList.children_of_kind(Parameter)
		{
			if not firstParameter
				{ builder.Append(", "); }
			else
				{ firstParameter = false; }

			let mutable_binding: bool = parameter.has_child(VarKeyword);
			let type: Semantic_Node = parameter.children[|parameter.children| - 1];
			builder.Append(convert_type(mutable_binding, type));
			builder.Append(" ");
			builder.Append(parameter.first_child(Identifier).get_text());
			builder.Append("_");

			if isMainFunction
			{
				var typeString: string;
				if type.Type == MutableType
					{ typeString = type.children[1].get_text(); }
				else
					{ typeString = type.get_text(); }
				if typeString == "System.Console.Console"
					{ MainFunctionAcceptsConsole = true; }
				if typeString == "System.Console.Arguments"
					{ MainFunctionAcceptsArgs = true; }
			}
		}
		builder.Append(")");
		return builder.ToString();
	}

	private ConvertParameterList(mut self, parameterList: Semantic_Node) -> string
	{
		return ConvertParameterList(parameterList, false);
	}

	private ConvertExpression(syntax: Semantic_Node, builder: mut Source_File_Builder) -> void
	{
		if syntax.Type == NewExpression
		{
			let type: Semantic_Node = syntax.children[1];
			let isValueType: bool = type.is_value_type();
			if not isValueType // place value types on the stack in C++ by not using new
				{ builder.Write("(new "); }
			builder.Write(convert_type_name(type));
			let argumentList: Semantic_Node = syntax.children[2];
			ConvertExpression(argumentList, builder);
			if not isValueType
				{ builder.Write(")"); }
		}
		else if syntax.Type == ArgumentList
		{
			builder.Write("(");
			var firstExpression: bool = true;
			for let arg: Semantic_Node in syntax.children
			{
				if arg.Type =/= LeftParen
					and arg.Type =/= RightParen
					and arg.Type =/= Comma
				{
					if firstExpression
						{ firstExpression = false; }
					else
						{ builder.Write(", "); }
					ConvertExpression(arg, builder);
				}
			}
			builder.Write(")");
		}
		else if syntax.Type == NotExpression
		{
			ConvertExpression(syntax.children[1], builder);
			builder.Write("->op_Not()");
		}
		else if syntax.Type == MagnitudeExpression
		{
			ConvertExpression(syntax.children[1], builder);
			builder.Write("->op_Magnitude()");
		}
		else if syntax.Type == ParenthesizedExpression
		{
			ConvertExpression(syntax.children[1], builder);
		}
		else if syntax.Type == NegateExpression
		{
			ConvertExpression(syntax.children[1], builder);
			builder.Write("->op_Negate()");
		}
		else if syntax.Type == NoneLiteralExpression
		{
			builder.Write("::None");
		}
		else if syntax.Type == SelfExpression
		{
			builder.Write("this");
		}
		else if syntax.Type == NumericLiteralExpression
		{
			builder.Write("p_int(" + syntax.get_text() + ")");
		}
		else if syntax.Type == TrueLiteralExpression
			or syntax.Type == FalseLiteralExpression
		{
			builder.Write("p_bool(" + syntax.get_text() + ")");
		}
		else if syntax.Type == CodePointLiteralExpression
		{
			builder.Write("p_code_point(" + syntax.get_text() + ")");
		}
		else if syntax.Type == IdentifierName
		{
			builder.Write(syntax.get_text() + "_");
		}
		else if syntax.Type == StringLiteralExpression
		{
			builder.Write("p_string(" + syntax.get_text() + ")");
		}
		else if syntax.Type == AssignmentExpression
		{
			let operator: int = syntax.children[1].Type;
			if operator == Equals
			{
				ConvertExpression(syntax.children[0], builder);
				builder.Write(" ");
				builder.Write(syntax.children[1].get_text());
				builder.Write(" ");
				ConvertExpression(syntax.children[2], builder);
			}
			else
			{
				ConvertExpression(syntax.children[0], builder);
				builder.Write("->op_");
				if operator == PlusEquals
				{
					builder.Write("AddAssign");
				}
				else if operator == MinusEquals
				{
					builder.Write("SubtractAssign");
				}
				else
				{
					builder.Error("Unsupported assignment operator " + operator);
				}
				builder.Write("(");
				ConvertExpression(syntax.children[2], builder);
				builder.Write(")");
			}
		}
		else if syntax.Type == EqualExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Equal(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == NotEqualExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_NotEqual(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == ComparisonExpression
		{
			let operator: int = syntax.children[1].Type;
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_");
			if operator == LessThan
			{
				builder.Write("LessThan");
			}
			else if operator == LessThanEquals
			{
				builder.Write("LessThanOrEqual");
			}
			else if operator == GreaterThan
			{
				builder.Write("GreaterThan");
			}
			else if operator == GreaterThanEquals
			{
				builder.Write("GreaterThanOrEqual");
			}
			else
			{
				builder.Error("Unsupported comparison operator " + operator);
			}
			builder.Write("(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == AddExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Add(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == SubtractExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Subtract(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == MultiplyExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Multiply(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == DivideExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Divide(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == RemainderExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Remainder(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else if syntax.Type == OrExpression
		{
			// TODO based on types decide how to translate
			builder.Write("LogicalOr(");
			ConvertExpression(syntax.children[0], builder);
			builder.Write(", [&] { return ");
			ConvertExpression(syntax.children[2], builder);
			builder.Write("; })");
		}
		else if syntax.Type == AndExpression
		{
			// TODO based on types decide how to translate
			builder.Write("LogicalAnd(");
			ConvertExpression(syntax.children[0], builder);
			builder.Write(", [&] { return ");
			ConvertExpression(syntax.children[2], builder);
			builder.Write("; })");
		}
		else if syntax.Type == InvocationExpression
		{
			ConvertExpression(syntax.children[0], builder);
			ConvertExpression(syntax.children[1], builder);
		}
		else if syntax.Type == MemberAccessExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->");
			ConvertExpression(syntax.children[2], builder);
		}
		else if syntax.Type == ElementAccessExpression
		{
			ConvertExpression(syntax.children[0], builder);
			builder.Write("->op_Element(");
			ConvertExpression(syntax.children[2], builder);
			builder.Write(")");
		}
		else
		{
			builder.Error("Could not convert expression of type " + syntax.Type);
		}
	}

	private EmitStatement(mut self, statement: Semantic_Node) -> void
	{
		Definitions.StatementSeparatorLine();

		if statement.Type == ReturnStatement
		{

			if |statement.children| == 2
				{ Definitions.WriteLine("return;"); }
			else
			{
				Definitions.BeginLine("return ");
				ConvertExpression(statement.children[1], Definitions);
				Definitions.EndLine(";");
			}
		}
		else if statement.Type == LoopStatement
		{
			Definitions.WriteLine("for (;;)");
			EmitStatement(statement.children[1]); // Block Statement
		}
		else if statement.Type == Block
		{
			Definitions.BeginBlock();
			for let blockStatement: Semantic_Node in statement.Statements()
			{
				EmitStatement(blockStatement);
			}
			Definitions.EndBlock();
		}
		else if statement.Type == WhileStatement
		{
			Definitions.BeginLine("while (");
			ConvertExpression(statement.children[1], Definitions);
			Definitions.EndLine(".Value)"); // if the type isn't just bool, we need op_true() etc.
			EmitStatement(statement.children[2]); // Block Statement
		}
		else if statement.Type == ForStatement
		{
			Definitions.BeginLine("for (");
			let variableDeclaration: Semantic_Node = statement.children[1];
			let mutable_binding: bool = variableDeclaration.has_child(VarKeyword);
			let name: string = variableDeclaration.first_child(Identifier).get_text();
			let type: Semantic_Node = variableDeclaration.children[3];
			Definitions.Write(convert_type(mutable_binding, type) + " " + name + "_");
			Definitions.Write(" : *(");
			ConvertExpression(statement.children[3], Definitions); // expression
			Definitions.EndLine("))");
			EmitStatement(statement.children[4]); // Block Statement
		}
		else if statement.Type == DoWhileStatement
		{
			Definitions.WriteLine("do");
			EmitStatement(statement.children[1]); // Block Statement
			Definitions.BeginLine("while (");
			ConvertExpression(statement.children[3], Definitions);
			Definitions.EndLine(".Value);"); // if the type isn't just bool, we need op_true() etc.
		}
		else if statement.Type == IfStatement
		{
			var ifStatement: Semantic_Node? = statement;
			Definitions.BeginLine("");
			loop
			{
				Definitions.Write("if (");
				ConvertExpression(ifStatement.children[1], Definitions);
				Definitions.EndLine(".Value)"); // if the type isn't just bool, we need op_true() etc.
				EmitStatement(ifStatement.children[2]); // Block Statement
				let elseClause: Semantic_Node? = ifStatement.first_child(ElseClause);
				if elseClause =/= none
				{
					ifStatement = elseClause.first_child(IfStatement);
					if ifStatement =/= none
					{
						Definitions.BeginLine("else ");
					}
					else
					{
						Definitions.WriteLine("else");
						EmitStatement(elseClause.children[1]); // Block Statement
						break;
					}
				}
				else
					{ break; }
			}
		}
		else if statement.Type == BreakStatement
		{
			Definitions.WriteLine("break;");
		}
		else if statement.Type == ContinueStatement
		{
			Definitions.WriteLine("continue;");
		}
		else if statement.Type == LocalDeclarationStatement
		{
			let variableDeclaration: Semantic_Node = statement.children[0];
			let variableName: string = variableDeclaration.first_child(Identifier).get_text();
			let variableType: Semantic_Node = variableDeclaration.children[3];
			let mutable_binding: bool = variableDeclaration.has_child(VarKeyword);
			Definitions.BeginLine(convert_type(mutable_binding, variableType));
			Definitions.Write(" " + variableName + "_");
			if variableDeclaration.has_child(Equals)
			{
				Definitions.Write(" = ");
				ConvertExpression(variableDeclaration.children[5], Definitions);
			}
			Definitions.EndLine(";");
		}
		else if statement.Type == ExpressionStatement
		{
			Definitions.BeginLine("");
			ConvertExpression(statement.children[0], Definitions);
			Definitions.EndLine(";");
		}
		else
		{
			Definitions.Error("Could not emit statement of type " + statement.Type);
		}
	}

	private EmitMemberDeclaration(mut self, member: Semantic_Node, className: string) -> void
	{
		if member.Type == ConstructorDeclaration
		{
			let parameters: string = ConvertParameterList(member.children[2]);
			// Write out the function declaration for C++ so we can call functions defined after others
			ClassDeclarations.WriteLine(className + "_" + parameters + ";");
			Definitions.ElementSeparatorLine();
			Definitions.WriteLine("::" + className + "_::" + className + "_" + parameters + "");
			EmitStatement(member.children[3]);
		}
		else if member.Type == FieldDeclaration
		{
			let variableDeclaration: Semantic_Node = member.first_child(VariableDeclaration);
			let fieldName: string = variableDeclaration.children[1].get_text();
			let fieldType: Semantic_Node = variableDeclaration.children[3];
			let cppType: string = convert_type(true, fieldType); // because we need to assign them in constructors don't mark fields const
			ClassDeclarations.WriteLine(cppType + " " + fieldName + "_;");
		}
		else if member.Type == MethodDeclaration
		{
			let methodName: string = member.children[1].get_text();
			let parameterList: Semantic_Node = member.children[2];
			let parameters: string = ConvertParameterList(parameterList);
			let selfParameter: Semantic_Node? = parameterList.first_child(SelfParameter);
			let isAssociatedFunction: bool = selfParameter == none;
			let mutableSelf: bool = not isAssociatedFunction and selfParameter.has_child(MutableKeyword);
			let returnType: Semantic_Node = member.children[4];
			let cppType: string = convert_type(true, returnType);
			var staticModifier: string = "";
			if isAssociatedFunction
				{ staticModifier = "static "; }
			var constModifier: string = "";
			if not mutableSelf and not isAssociatedFunction
				{ constModifier = "const "; }
			ClassDeclarations.WriteLine(staticModifier + "auto " + methodName + "_" + parameters + " " + constModifier + "-> " + cppType + ";");
			Definitions.ElementSeparatorLine();
			Definitions.WriteLine("auto ::" + className + "_::" + methodName + "_" + parameters + " " + constModifier + "-> " + cppType);
			let block: Semantic_Node = member.children[5];
			EmitStatement(block);
		}
		else
		{
			Definitions.Error("Could not emit member of type " + member.Type);
		}
	}

	private EmitDeclaration(mut self, declaration: Semantic_Node) -> void
	{
		if declaration.Type == GlobalDeclaration
		{
			let variableDeclaration: Semantic_Node = declaration.children[1];
			let variableName: string = variableDeclaration.children[1].get_text();
			let variableType: Semantic_Node = variableDeclaration.children[3];
			let mutable_binding: bool = variableDeclaration.has_child(VarKeyword);
			let cppType: string = convert_type(mutable_binding, variableType);
			GlobalDefinitions.BeginLine(cppType);
			GlobalDefinitions.Write(" " + variableName + "_ = ");
			let expression: Semantic_Node = variableDeclaration.children[5];
			ConvertExpression(expression, GlobalDefinitions);
			GlobalDefinitions.EndLine(";");
		}
		else if declaration.Type == ClassDeclaration
		{
			let className: string = declaration.children[2].get_text();
			TypeDeclarations.WriteLine("class " + className + "_;");
			ClassDeclarations.ElementSeparatorLine();
			ClassDeclarations.WriteLine("class " + className + "_");
			ClassDeclarations.BeginBlock();
			ClassDeclarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
			// Write out basic reference equality comparisons
			ClassDeclarations.WriteLine("p_bool op_Equal(" + className + "_ const * other) const { return this == other; }");
			ClassDeclarations.WriteLine("p_bool op_NotEqual(" + className + "_ const * other) const { return this != other; }");
			for let member: Semantic_Node in declaration.Members()
			{
				EmitMemberDeclaration(member, className);
			}
			ClassDeclarations.EndBlockWithSemicolon();
		}
		else if declaration.Type == StructDeclaration
		{
			let structName: string = declaration.children[2].get_text();
			TypeDeclarations.WriteLine("struct " + structName + "_;");
			ClassDeclarations.ElementSeparatorLine();
			ClassDeclarations.WriteLine("struct " + structName + "_");
			ClassDeclarations.BeginBlock();
			ClassDeclarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
			// Write out arrow and dereference operators for using value types like reference types
			// TODO Emit correct code to use value types as value types rather than reference types and drop this code
			ClassDeclarations.WriteLine(structName + "_ * operator->() { return this; }");
			ClassDeclarations.WriteLine(structName + "_ const * operator->() const { return this; }");
			ClassDeclarations.WriteLine(structName + "_ & operator* () { return *this; }");
			ClassDeclarations.WriteLine(structName + "_ const & operator* () const { return *this; }");

			for let member: Semantic_Node in declaration.Members()
			{
				EmitMemberDeclaration(member, structName);
			}
			ClassDeclarations.EndBlockWithSemicolon();
		}
		else if declaration.Type == EnumDeclaration
		{
			let enumName: string = declaration.children[3].get_text();
			TypeDeclarations.WriteLine("enum class " + enumName + "_;");
			ClassDeclarations.ElementSeparatorLine();
			ClassDeclarations.WriteLine("enum class " + enumName + "_");
			ClassDeclarations.BeginBlock();
			for let member: Semantic_Node in declaration.children
			{
				if member.Type == EnumMemberDeclaration
				{
					let memberName: string = member.children[0].get_text();
					ClassDeclarations.BeginLine(memberName + "_");
					let memberValue: Semantic_Node? = member.first_child(Number);
					if memberValue =/= none
					{
						ClassDeclarations.Write(" = ");
						ClassDeclarations.Write(memberValue.get_text());
					}
					ClassDeclarations.EndLine(",");
				}
			}
			ClassDeclarations.EndBlockWithSemicolon();
		}
		else if declaration.Type == FunctionDeclaration
		{
			let name: string = declaration.children[1].get_text();
			let isMain: bool = name == "Main";
			let parameters: string = ConvertParameterList(declaration.children[2], isMain);
			let returnType: Semantic_Node = declaration.children[4];
			let cppType: string = convert_type(true, returnType);
			// Write out the function declaration for C++ so we can call functions defined after others
			FunctionDeclarations.WriteLine("auto " + name + "_" + parameters + " -> " + cppType + ";");
			Definitions.ElementSeparatorLine();
			Definitions.WriteLine("auto " + name + "_" + parameters + " -> " + cppType);
			if isMain
			{
				if MainFunctionReturnType =/= ""
					{ Definitions.Error("Multiple declarations of main"); }
				MainFunctionReturnType = cppType;
			}
			EmitStatement(declaration.children[5]);
		}
		else if declaration.Type == EndOfFileToken
		{
			// Ignore the end of file
		}
		else
		{
			Definitions.Error("Could not emit declaration of type " + declaration.Type);
		}
	}

	private EmitCompilationUnit(mut self, unit: Semantic_Node) -> void
	{
		for let declaration: Semantic_Node in unit.children
		{
			EmitDeclaration(declaration);
		}
	}

	private EmitPreamble(mut self) -> void
	{
		// Setup the beginning of each section
		TypeDeclarations.WriteLine("#include \"RuntimeLibrary.h\"");
		TypeDeclarations.BlankLine();
		TypeDeclarations.WriteLine("// Type Declarations");
		FunctionDeclarations.BlankLine();
		FunctionDeclarations.WriteLine("// Function Declarations");
		ClassDeclarations.BlankLine();
		ClassDeclarations.WriteLine("// Class Declarations");
		GlobalDefinitions.BlankLine();
		GlobalDefinitions.WriteLine("// Global Definitions");
		Definitions.BlankLine();
		Definitions.WriteLine("// Definitions");
	}

	private EmitEntryPointAdapter(mut self) -> void
	{
		Definitions.ElementSeparatorLine();
		Definitions.WriteLine("// Entry Point Adapter");
		Definitions.WriteLine("std::int32_t main(int argc, char const *const * argv)");
		Definitions.BeginBlock();

		Definitions.WriteLine("try");
		Definitions.BeginBlock();

		for let resource: Source_Text in resources
		{
			Definitions.BeginLine("resource_manager_->AddResource(p_string(\"");
			Definitions.Write(resource.Name);
			Definitions.Write("\"), p_string(\"");
			Definitions.Write(resource.Text
									.Replace("\\", "\\\\")
									.Replace("\n", "\\n")
									.Replace("\r", "\\r")
									.Replace("\"", "\\\""));
			Definitions.EndLine("\"));");
		}
		if |resources| > 0
		{
			Definitions.EndLine(""); // Use EndLine to avoid having an indent on a blank line
		}

		// TODO should be `new mut`
		let args: mut System.Text.String_Builder = new System.Text.String_Builder();
		if MainFunctionAcceptsConsole
			{ args.Append("new ::System_::Console_::Console_()"); }
		if MainFunctionAcceptsArgs
		{
			if MainFunctionAcceptsConsole
				{ args.Append(", "); }
			args.Append("new ::System_::Console_::Arguments_(argc, argv)");
		}

		if MainFunctionReturnType == "void"
		{
			Definitions.WriteLine("Main_(" + args.ToString() + ");");
			Definitions.WriteLine("return 0;");
		}
		else
		{
			Definitions.WriteLine("return Main_(" + args.ToString() + ").Value;");
		}

		Definitions.EndBlock(); // try
		Definitions.WriteLine("catch(std::exception &ex)");
		Definitions.BeginBlock();
		Definitions.WriteLine("std::printf(\"Program exited due to error:\\n\");");
		Definitions.WriteLine("std::printf(\"%s\", ex.what());");
		Definitions.WriteLine("return 70;"); // Defined by sysexits.h as EX_SOFTWARE
		Definitions.EndBlock();

		Definitions.EndBlock();
	}
}
