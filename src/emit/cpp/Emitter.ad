public class Emitter
{
    public let package: Package;
    public let resources: system.collections.List<Source_Text>;

    public var type_declarations: mut Source_File_Builder;
    public var function_declarations: mut Source_File_Builder;
    public var class_declarations: mut Source_File_Builder;
    public var global_definitions: mut Source_File_Builder;
    public var definitions: mut Source_File_Builder;

    // TODO compute these in a semantic analysis phase
    public var main_function_name: string;
    public var main_function_return_type: string;
    public var main_function_accepts_console: bool;
    public var main_function_accepts_args: bool;

    public new(package: Package, resources: system.collections.List<Source_Text>)
    {
        self.package = package;
        self.resources = resources;
    }
}

public emit(emitter: mut Emitter) -> string
{
    emitter.type_declarations = new Source_File_Builder();
    emitter.function_declarations = new Source_File_Builder();
    emitter.class_declarations = new Source_File_Builder();
    emitter.global_definitions = new Source_File_Builder();
    emitter.definitions = new Source_File_Builder();
    emitter.main_function_return_type = "";
    emitter.main_function_accepts_console = false;
    emitter.main_function_accepts_args = false;

    emit_preamble(emitter);

    for let compilation_unit: Compilation_Unit in emitter.package.compilation_units
    {
        emit_compilation_unit(emitter, compilation_unit);
    }

    emit_entry_point_adapter(emitter);

    // TODO all of this should be `string.join()`
    // TODO the `string.join()` call should be optimized into existence by the compiler from addition
    let total_size: int
        = byte_length(emitter.type_declarations)
        + byte_length(emitter.function_declarations)
        + byte_length(emitter.class_declarations)
        + byte_length(emitter.global_definitions)
        + byte_length(emitter.definitions);
    let cpp_code: mut system.text.String_Builder = new system.text.String_Builder()/*.with_capacity(total_size)*/;
    cpp_code.Append(to_string(emitter.type_declarations));
    cpp_code.Append(to_string(emitter.function_declarations));
    cpp_code.Append(to_string(emitter.class_declarations));
    cpp_code.Append(to_string(emitter.global_definitions));
    cpp_code.Append(to_string(emitter.definitions));
    return cpp_code.ToString();
}

public mangle_name(type: Type) -> string
{
    // TODO what about name.is_special == true?
    let builder: mut system.text.String_Builder = new system.text.String_Builder();

    var first_segment: bool = true;
    for let segment: string in type.name.segments
    {
        if first_segment
            { first_segment = false; }
        else
            { builder.Append("__"); }

        if not contains_multi_underscore_runs(segment)
            { builder.Append(segment); }
        else
            { append_fixing_underscores(builder, segment); }
    }

    builder.Append("__");
    builder.Append(|type.type_parameters|);

    return builder.ToString();
}

public mangle_function_name(name: string, parameter_count: int) -> string
{
    let builder: mut system.text.String_Builder = new system.text.String_Builder();
    if not contains_multi_underscore_runs(name)
        { builder.Append(name); }
    else
        { append_fixing_underscores(builder, name); }
    builder.Append("__");
    builder.Append(parameter_count);
    return builder.ToString();
}

public mangle_field_name(name: string) -> string
{
      if not contains_multi_underscore_runs(name)
        { return name + "__"; }
    else
    {
        let builder: mut system.text.String_Builder = new system.text.String_Builder();
        append_fixing_underscores(builder, name);
        builder.Append("__");
        return builder.ToString();
    }
}

public contains_multi_underscore_runs(value: string) -> bool
{
    // Due to limitations with strings and loops, do the equivalent
    // of a for loop
    var i: int = 0;
    var last_char_underscore: bool = false;
    while i < value.ByteLength()
    {
        if value[i] == '_'
        {
            if last_char_underscore
                { return true; }
            last_char_underscore = true;
        }
        else
            { last_char_underscore = false; }
        i += 1;
    }
    return false;
}

public append_fixing_underscores(builder: mut system.text.String_Builder, value: string) -> void
{
    // Due to limitations with strings and loops, do the equivalent
    // of a for loop
    var underscores: int = 0;
    var i: int = 0;
    while i < value.ByteLength()
    {
        if value[i] == '_'
            { underscores += 1; }
        else if underscores > 0
        {
            if underscores >= 2
            {
                builder.Append("_");
            }
            underscores = 0;
        }
        builder.Append(new string(value[i], 1)); // really bad memory use
        i += 1;
    }
}

public convert_primitive_type_name(type: Type) -> string
{
    let name: string = unqualified_name(type.name);
    assert(type.is_primitive, name);
    if name == "bool"
    {
        return "BOOL";
    }
    else if name == "int"
    {
        return "int32";
    }
    else if name == "uint"
    {
        return "uint32";
    }
    else
    {
        return name;
    }
}

// Converts a type to C++
public convert_type_name(type_node: Semantic_Node) -> mut system.text.String_Builder
{
    assert(type_node.referenced_type =/= none, get_text(type_node));
    return convert_type_name(type_node.referenced_type);
}

public convert_type_name(type: Type) -> mut system.text.String_Builder
{
    return convert_type_name(type, true);
}

public convert_type_name(type: Type, include_type_parameters: bool) -> mut system.text.String_Builder
{
    let cpp_type: mut system.text.String_Builder = new system.text.String_Builder();
    if type.is_primitive
    {
        cpp_type.Append(convert_primitive_type_name(type));
    }
    else
    {
        cpp_type.Append(mangle_name(type));
    }

    if |type.type_parameters| > 0 and include_type_parameters
    {
        convert_type_parameters(cpp_type, type);
    }
    return cpp_type;
}

public convert_type_parameters(builder: mut system.text.String_Builder, type: Type) -> void
{
    builder.Append("<");
    var first: bool = true;
    for let type_parameter: Type in type.type_parameters
    {
        if first { first = false; }
        else { builder.Append(", "); }
        builder.Append(convert_type(true, type_parameter, false));
    }
    builder.Append(">");
}

public convert_reference_type(mutable_binding: bool, var type: Type, nullable: bool) -> string
{
    let cpp_type: mut system.text.String_Builder = convert_type_name(type);
    if not type.is_mutable { cpp_type.Append(" const"); }
    cpp_type.Append(" *");
    if nullable
        { cpp_type.Append("_Nullable"); }
    else
        { cpp_type.Append("_Nonnull"); }
    if not mutable_binding { cpp_type.Append(" const") ; }
    return cpp_type.ToString();
}

// Converts a type to C++
public convert_type(mutable_binding: bool, var type: Type, optional: bool) -> string
{
    assert(type =/= none, "");

    if type.is_primitive and unqualified_name(type.name) == "optional"
    {
        let optional_type: Type = type.type_parameters[0];
        if optional_type.is_value_type
        {
            // optional<T> is a const struct
            let cpp_type: mut system.text.String_Builder = new system.text.String_Builder("p_optional<");
            cpp_type.Append(convert_type(true, optional_type, true));
            cpp_type.Append(">");
            if not mutable_binding and not type.is_mutable
                { cpp_type.Append(" const"); }
            return  cpp_type.ToString();
        }
        else
        {
            return convert_type(mutable_binding, optional_type, true);
        }
    }
    else
    {
        if type.is_value_type
        {
            let cpp_type: mut system.text.String_Builder = convert_type_name(type);
            if not mutable_binding and not type.is_mutable
                { cpp_type.Append(" const"); }
            return cpp_type.ToString();
        }
        else
        {
            return convert_reference_type(mutable_binding, type, optional);
        }
    }
}

public convert_type(mutable_binding: bool, type_node: Semantic_Node) -> string
{
    assert(type_node.referenced_type =/= none, get_text(type_node));
    return convert_type(mutable_binding, type_node.referenced_type, false); // not optional
}

// TODO can't have `self_type` be a nullable string because comparision not implemented yet
public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, self_type: string, is_main_function: bool) -> string
{
    assert(parameters.kind == ParameterList, "parameters.kind=" + parameters.kind);
    let builder: mut system.text.String_Builder = new system.text.String_Builder();
    builder.Append("(");
    if self_type.ByteLength() > 0
    {
        builder.Append(self_type);
        builder.Append(" self");
    }
    var first_parameter: bool = self_type.ByteLength() == 0;
    for let parameter: Semantic_Node in children_of_kind(parameters, Parameter)
    {
        if not first_parameter
            { builder.Append(", "); }
        else
            { first_parameter = false; }

        let mutable_binding: bool = node_has_child(parameter, VarKeyword);
        let type_node: Semantic_Node = parameter.children[|parameter.children| - 1];
        builder.Append(convert_type(mutable_binding, type_node));
        builder.Append(" ");
        builder.Append(mangle_field_name(get_text(first_child(parameter, Identifier))));

        if is_main_function
        {
            var type_string: string;
            if type_node.kind == MutableType
                { type_string = get_text(type_node.children[0]); }
            else
                { type_string = get_text(type_node); }
            if type_string == "system.console.Console"
                { emitter.main_function_accepts_console = true; }
            if type_string == "system.console.Arguments"
                { emitter.main_function_accepts_args = true; }
        }
    }
    builder.Append(")");
    return builder.ToString();
}

public convert_method_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, self_type: string) -> string
{
    return convert_parameter_list(emitter, parameters, self_type, false);
}

public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, is_main_function: bool) -> string
{
    return convert_parameter_list(emitter, parameters, "", is_main_function);
}

public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node) -> string
{
    return convert_parameter_list(emitter, parameters, "", false);
}

public convert_expression(syntax: Semantic_Node, builder: mut Source_File_Builder) -> void
{
    if syntax.kind == NewExpression
    {
        var constructor_name: string = "";
        var type_node: Semantic_Node = syntax.children[0];
        if type_node.kind == QualifiedName
        {
            let name_node: Semantic_Node = type_node.children[1];

            // We assume that if there is no type, then it is a named constructor
            if name_node.kind == IdentifierName
                and name_node.referenced_type == none
            {
                // Named constructor
                constructor_name = "__" + get_text(name_node);
                type_node = type_node.children[0];
            }
        }

        let type: Type = type_node.referenced_type;
        assert(type =/= none, get_text(type_node));
        write(builder, convert_type_name(type, false).ToString());
        write(builder, "__0new");
        write(builder, constructor_name);
        write(builder, "__");
        let argument_list: Semantic_Node = syntax.children[1];
        write(builder, node_argument_count(argument_list));
        if |type.type_parameters| > 0
        {
            let params: mut system.text.String_Builder = new system.text.String_Builder();
            convert_type_parameters(params, type);
            write(builder, params.ToString());
        }

        if type.is_value_type
            { convert_expression(argument_list, builder); }
        else
            { convert_reference_type_constructor_arguments(argument_list, builder, convert_type_name(type).ToString()); }
    }
    else if syntax.kind == ArgumentList
    {
        write(builder, "(");
        var first_expression: bool = true;
        for let arg: Semantic_Node in syntax.children
        {
            if arg.kind =/= LeftParen
                and arg.kind =/= RightParen
                and arg.kind =/= Comma
            {
                if first_expression
                    { first_expression = false; }
                else
                    { write(builder, ", "); }
                convert_expression(arg, builder);
            }
        }
        write(builder, ")");
    }
    else if syntax.kind == NotExpression
    {
        // TODO change to other functions based on argument type
        write(builder, "BOOL__0op__not(");
        convert_expression(syntax.children[1], builder);
        write(builder, ")");
    }
    else if syntax.kind == MagnitudeExpression
    {
        // Pipes were removed during semantic tree build
        let expression_node: Semantic_Node = syntax.children[0];
        convert_expression(expression_node, builder);
        convert_member_access(expression_node, builder);
        write(builder, "op__magnitude()");
    }
    else if syntax.kind == ParenthesizedExpression
    {
        convert_expression(syntax.children[1], builder);
    }
    else if syntax.kind == NegateExpression
    {
        write(builder, "int32__0op__negate(");
        convert_expression(syntax.children[0], builder);
        write(builder, ")");
    }
    else if syntax.kind == NoneLiteralExpression
    {
        write(builder, "none");
    }
    else if syntax.kind == SelfExpression
    {
        write(builder, "self");
    }
    else if syntax.kind == NumericLiteralExpression
    {
        write(builder, "(int32){" + get_text(syntax) + "}");
    }
    else if syntax.kind == TrueLiteralExpression
    {
        write(builder, "TRUE");
    }
    else if syntax.kind == FalseLiteralExpression
    {
        write(builder, "FALSE");
    }
    else if syntax.kind == CodePointLiteralExpression
    {
        write(builder, "code_point(" + get_text(syntax) + ")");
    }
    else if syntax.kind == IdentifierName
    {
        write(builder, mangle_field_name(get_text(syntax)));
    }
    else if syntax.kind == StringLiteralExpression
    {
        write(builder, "string(" + get_text(syntax) + ")");
    }
    else if syntax.kind == AssignmentExpression
    {
        let operator: int = syntax.children[1].kind;
        if operator == Equals
        {
            convert_expression(syntax.children[0], builder);
            write(builder, " ");
            write(builder, get_text(syntax.children[1]));
            write(builder, " ");
            convert_expression(syntax.children[2], builder);
        }
        else
        {
            write(builder, "op__");
            if operator == PlusEquals
            {
                write(builder, "add_assign");
            }
            else if operator == MinusEquals
            {
                write(builder, "subtract_assign");
            }
            else
            {
                error(builder, "Unsupported assignment operator " + operator);
            }
            write(builder, "(&(");
            convert_expression(syntax.children[0], builder);
            write(builder, "), ");
            convert_expression(syntax.children[2], builder);
            write(builder, ")");
        }
    }
    else if syntax.kind == EqualExpression
    {
        write(builder, "equal_op(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == NotEqualExpression
    {
        write(builder, "not_equal_op(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == ComparisonExpression
    {
        // TODO assert the left and right types match
        let operator: int = syntax.children[1].kind;
        let type: Type = syntax.children[0].of_type;
        if type =/= none
        {
            write(builder, convert_primitive_type_name(type));
        }
        else
        {
            // TODO we just assume they are `int`s, that could be wrong
            write(builder, "int32");
        }

        if operator == LessThan
        {
            write(builder, "__0op__less_than");
        }
        else if operator == LessThanEquals
        {
            write(builder, "__0op__less_than_or_equal");
        }
        else if operator == GreaterThan
        {
            write(builder, "__0op__greater_than");
        }
        else if operator == GreaterThanEquals
        {
            write(builder, "__0op__greater_than_or_equal");
        }
        else
        {
            error(builder, "Unsupported comparison operator " + operator);
        }
        write(builder, "(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == AddExpression
    {
        let lhs_node: Semantic_Node = syntax.children[0];
        let rhs_node: Semantic_Node = syntax.children[1];
        convert_expression(lhs_node, builder);
        convert_member_access(lhs_node, builder);
        write(builder, "op__add(");
        convert_expression(rhs_node, builder);
        write(builder, ")");
    }
    else if syntax.kind == SubtractExpression
    {
        let lhs_node: Semantic_Node = syntax.children[0];
        let rhs_node: Semantic_Node = syntax.children[1];
        convert_expression(lhs_node, builder);
        convert_member_access(lhs_node, builder);
        write(builder, "op__subtract(");
        convert_expression(rhs_node, builder);
        write(builder, ")");
    }
    else if syntax.kind == MultiplyExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        write(builder, "op__multiply(");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == DivideExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        write(builder, "op__divide(");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == RemainderExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        write(builder, "op__remainder(");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == OrExpression
    {
        // TODO Based on the type of the values involved, either:
        // * bool_op(bool_arg(lhs) || bool_arg(rhs))
        // * ({ T _lhs = lhs; op__true(_lhs) ? _lhs : op__or(_lhs, rhs); })
        // Note: that is a "compound expression"
        write(builder, "bool_op(bool_arg(");
        convert_expression(syntax.children[0], builder);
        write(builder, ") || bool_arg(");
        convert_expression(syntax.children[2], builder);
        write(builder, "))");
    }
    else if syntax.kind == AndExpression
    {
        // TODO Based on the type of the values involved, either:
        // * bool_op(bool_arg(lhs) && bool_arg(rhs))
        // * ({ T _lhs = lhs; op__false(_lhs) ? _lhs : op__and(_lhs, rhs); })
        // Note: that is a "compound expression"
        write(builder, "bool_op(bool_arg(");
        convert_expression(syntax.children[0], builder);
        write(builder, ") && bool_arg(");
        convert_expression(syntax.children[2], builder);
        write(builder, "))");
    }
    else if syntax.kind == InvocationExpression
    {
        convert_expression(syntax.children[0], builder);
        // Assuming we just emitted the function name as a field, tack this on
        let parameters_node: Semantic_Node = syntax.children[1];
        // TODO we don't handle the arguments list correctly yet, so it still has the parens as children
        write(builder, node_argument_count(parameters_node));
        convert_expression(parameters_node, builder);
    }
    else if syntax.kind == MemberAccessExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        convert_expression(syntax.children[1], builder);
    }
    else if syntax.kind == ElementAccessExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        write(builder, "op__Element(");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else
    {
        error(builder, "Could not convert expression of type " + syntax.kind);
    }
}

public convert_reference_type_constructor_arguments(
    syntax: Semantic_Node,
    builder: mut Source_File_Builder,
    type_name: string)
    -> void
{
    assert(syntax.kind == ArgumentList, "");
    write(builder, "(allocate(sizeof(");
    write(builder, type_name);
    write(builder, "))");
    for let arg: Semantic_Node in syntax.children
    {
        if arg.kind =/= LeftParen
            and arg.kind =/= RightParen
            and arg.kind =/= Comma
        {
            write(builder, ", ");
            convert_expression(arg, builder);
        }
    }
    write(builder, ")");
}

public convert_member_access(lhs: Semantic_Node, builder: mut Source_File_Builder) -> void
{
    let type: Type? = lhs.of_type;
    if type =/= none and type.is_value_type // TODO eventually, we shouldn't need to check if the type is null
        and not (type.is_primitive // optional reference types are still pointers
                and unqualified_name(type.name) == "optional"
                and not type.type_parameters[0].is_value_type)
        { write(builder, "."); }
    else
        { write(builder, "->"); }
}

public emit_statement(emitter: mut Emitter, statement: Semantic_Node) -> void
{
    statement_separator_line(emitter.definitions);

    if statement.kind == ReturnStatement
    {
        if |statement.children| == 2
            { write_line(emitter.definitions, "return;"); }
        else
        {
            begin_line(emitter.definitions, "return ");
            convert_expression(statement.children[1], emitter.definitions);
            end_line(emitter.definitions, ";");
        }
    }
    else if statement.kind == LoopStatement
    {
        write_line(emitter.definitions, "for (;;)");
        emit_statement(emitter, statement.children[1]); // Block Statement
    }
    else if statement.kind == Block
    {
        begin_block(emitter.definitions);
        for let block_statement: Semantic_Node in node_statements(statement)
        {
            emit_statement(emitter, block_statement);
        }
        end_block(emitter.definitions);
    }
    else if statement.kind == WhileStatement
    {
        begin_line(emitter.definitions, "while (cond(");
        convert_expression(statement.children[1], emitter.definitions);
        end_line(emitter.definitions, "))");
        emit_statement(emitter, statement.children[2]); // Block Statement
    }
    else if statement.kind == ForStatement
    {
        begin_line(emitter.definitions, "for (");
        let variable_declaration: Semantic_Node = first_child(statement, VariableDeclaration);
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        let name: string = get_text(first_child(variable_declaration, Identifier));
        let type: Semantic_Node = variable_declaration.children[2];
        write(emitter.definitions, convert_type(mutable_binding, type) + " " + mangle_field_name(name));
        write(emitter.definitions, " : *(");
        convert_expression(statement.children[3], emitter.definitions); // expression
        end_line(emitter.definitions, "))");
        emit_statement(emitter, statement.children[4]); // Block Statement
    }
    else if statement.kind == DoWhileStatement
    {
        write_line(emitter.definitions, "do");
        emit_statement(emitter, statement.children[1]); // Block Statement
        begin_line(emitter.definitions, "while (cond(");
        convert_expression(statement.children[3], emitter.definitions);
        end_line(emitter.definitions, "));");
    }
    else if statement.kind == IfStatement
    {
        var if_statement: Semantic_Node? = statement;
        begin_line(emitter.definitions, "");
        loop
        {
            write(emitter.definitions, "if (cond(");
            convert_expression(if_statement.children[1], emitter.definitions);
            end_line(emitter.definitions, "))");
            emit_statement(emitter, if_statement.children[2]); // Block Statement
            let elseClause: Semantic_Node? = first_child(if_statement, ElseClause);
            if elseClause =/= none
            {
                if_statement = first_child(elseClause, IfStatement);
                if if_statement =/= none
                {
                    begin_line(emitter.definitions, "else ");
                }
                else
                {
                    write_line(emitter.definitions, "else");
                    emit_statement(emitter, elseClause.children[1]); // Block Statement
                    break;
                }
            }
            else
                { break; }
        }
    }
    else if statement.kind == BreakStatement
    {
        write_line(emitter.definitions, "break;");
    }
    else if statement.kind == ContinueStatement
    {
        write_line(emitter.definitions, "continue;");
    }
    else if statement.kind == LocalDeclarationStatement
    {
        let variable_declaration: Semantic_Node = first_child(statement, VariableDeclaration);
        let variable_name: string = get_text(first_child(variable_declaration, Identifier));
        let variable_type: Semantic_Node = variable_declaration.children[2];
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        begin_line(emitter.definitions, convert_type(mutable_binding, variable_type));
        write(emitter.definitions, " " + mangle_field_name(variable_name));
        if |variable_declaration.children| > 3
        {
            write(emitter.definitions, " = ");
            convert_expression(variable_declaration.children[3], emitter.definitions);
        }
        end_line(emitter.definitions, ";");
    }
    else if statement.kind == ExpressionStatement
    {
        begin_line(emitter.definitions, "");
        convert_expression(statement.children[0], emitter.definitions);
        end_line(emitter.definitions, ";");
    }
    else
    {
        NOT_IMPLEMENTED("statement.kind=" + statement.kind);
    }
}

public emit_method_body(emitter: mut Emitter, block: Semantic_Node, is_associated_function: bool) -> void
{
    begin_block(emitter.definitions);
    if not is_associated_function
    {
        write_line(emitter.definitions, "auto self = this;");
    }
    for let statement: Semantic_Node in node_statements(block)
    {
        emit_statement(emitter, statement);
    }
    end_block(emitter.definitions);
}

public emit_constructor_body(emitter: mut Emitter, block: Semantic_Node, self_type: string, is_value_type: bool) -> void
{
    // TODO this doesn't support explicit return from constructors
    begin_block(emitter.definitions);
    if is_value_type
    {
        write_line(emitter.definitions, self_type + " self;");
    }
    for let statement: Semantic_Node in node_statements(block)
    {
        emit_statement(emitter, statement);
    }
    write_line(emitter.definitions, "return self;");
    end_block(emitter.definitions);
}

public emit_member_declaration(emitter: mut Emitter, member: Semantic_Node, class_name: string, is_value_type: bool) -> void
{
    if member.kind == ConstructorDeclaration
    {
        let parameters_node: Semantic_Node = first_child(member, ParameterList);
        var new_function_name: string = "new_" + class_name;
        var constructor_full_name: string = class_name + "__0new__";
        let constructor_name_node: Semantic_Node? = first_child(member, Identifier);
        if constructor_name_node =/= none
        {
            let constructor_name: string = get_text(constructor_name_node);
            new_function_name = new_function_name + "__" + constructor_name;
            constructor_full_name = constructor_full_name + constructor_name + "__";
        }
        constructor_full_name = constructor_full_name + |parameters_node.children|;
        var return_type: string = class_name;
        if not is_value_type
            { return_type = return_type + " *_Nonnull"; }
        var constructor_parameters: string;
        if not is_value_type
            { constructor_parameters = convert_method_parameter_list(emitter, parameters_node, return_type); }
        else
            { constructor_parameters = convert_parameter_list(emitter, parameters_node); }

        // Constructor Signature
        var constructor_signature: string = return_type + " " + constructor_full_name + constructor_parameters;

        // Constructor Declaration
        write_line(emitter.function_declarations, constructor_signature + ";");

        // Constructor definition
        element_separator_line(emitter.definitions);
        write_line(emitter.definitions, constructor_signature);
        emit_constructor_body(emitter, first_child(member, Block), return_type, is_value_type);
    }
    else if member.kind == FieldDeclaration
    {
        let variable_declaration: Semantic_Node = first_child(member, VariableDeclaration);
        let field_name: string = get_text(first_child(variable_declaration, Identifier));
        let field_type: Semantic_Node = variable_declaration.children[2];
        let cpp_type: string = convert_type(true, field_type); // because we need to assign them in constructors don't mark fields const
        write_line(emitter.class_declarations, cpp_type + " " + mangle_field_name(field_name) + ";");
    }
    else if member.kind == MethodDeclaration
    {
        let parameters_node: Semantic_Node = first_child(member, ParameterList);
        let self_parameter: Semantic_Node? = first_child(parameters_node, SelfParameter);
        var parameter_count: int = |parameters_node.children|;
        // For now we ignore the self parameter because the caller can't tell if it is a method or function call
        if self_parameter =/= none
            { parameter_count -= 1; }
        let method_name: string = mangle_function_name(get_text(first_child(member, Identifier)), parameter_count);
        let parameters: string = convert_parameter_list(emitter, parameters_node);
        let is_associated_function: bool = self_parameter == none;
        let mutable_self: bool = not is_associated_function and node_has_child(self_parameter, MutableKeyword);
        let return_type_node: Semantic_Node = member.children[3];
        let cpp_type: string = convert_type(true, return_type_node);
        var static_modifier: string = "";
        if is_associated_function
            { static_modifier = "static "; }
        var constModifier: string = "";
        if not mutable_self and not is_associated_function
            { constModifier = " const"; }
        write_line(emitter.class_declarations, static_modifier + cpp_type + " " + method_name + parameters + constModifier + ";");
        element_separator_line(emitter.definitions);
        write_line(emitter.definitions, cpp_type + " " + class_name + "::" + method_name + parameters + constModifier);
        let block: Semantic_Node = first_child(member, Block);
        emit_method_body(emitter, block, is_associated_function);
    }
    else
    {
        error(emitter.definitions, "Could not emit member of type " + member.kind);
    }
}

public emit_default_constructor(emitter: mut Emitter, type_name: string, is_value_type: bool) -> void
{
    let default_constructor_name: string = type_name + "__0new__0";

    var return_type: string = type_name;
    if not is_value_type
        { return_type = return_type + " *_Nonnull"; }

    // Constructor Signature
    var constructor_signature: string = return_type + " " + default_constructor_name + "(";
    if not is_value_type
        { constructor_signature = constructor_signature + return_type + " self"; }
    constructor_signature = constructor_signature + ")";

    // Constructor Declaration
    write_line(emitter.function_declarations, constructor_signature + ";");

     // Constructor definition
    element_separator_line(emitter.definitions);
    begin_line(emitter.definitions, constructor_signature);
    // TODO I probably need to do the default initialization
    if is_value_type
        { end_line(emitter.definitions, " { return {}; }"); }
    else
        { end_line(emitter.definitions, " { return self; }"); }
}

public emit_declaration(emitter: mut Emitter, declaration: Semantic_Node) -> void
{
    if declaration.kind == GlobalDeclaration
    {
        let variable_declaration: Semantic_Node = first_child(declaration, VariableDeclaration);
        let variable_name: string = get_text(first_child(variable_declaration, Identifier));
        let variable_type: Semantic_Node = variable_declaration.children[2];
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        let cpp_type: string = convert_type(mutable_binding, variable_type);
        begin_line(emitter.global_definitions, cpp_type);
        write(emitter.global_definitions, " " + mangle_field_name(variable_name) + " = ");
        let expression: Semantic_Node = variable_declaration.children[3];
        convert_expression(expression, emitter.global_definitions);
        end_line(emitter.global_definitions, ";");
    }
    else if declaration.kind == ClassDeclaration
    {
        let declared_type: Type = declaration.declares_type;
        assert(declared_type =/= none, get_text(first_child(declaration, Identifier)));
        let class_name: string = mangle_name(declared_type);
        write_line(emitter.type_declarations, "typedef struct " + class_name + " " + class_name + ";");
        element_separator_line(emitter.class_declarations);
        write_line(emitter.class_declarations, "struct " + class_name);
        begin_block(emitter.class_declarations);
        var has_constructors: bool = false;
        for let member: Semantic_Node in node_members(declaration)
        {
            has_constructors = has_constructors or member.kind == ConstructorDeclaration;
            emit_member_declaration(emitter, member, class_name, false);
        }
        if not has_constructors
        {
            emit_default_constructor(emitter, class_name, false);
        }
        end_block_with_semicolon(emitter.class_declarations);
    }
    else if declaration.kind == StructDeclaration
    {
        let declared_type: Type = declaration.declares_type;
        assert(declared_type =/= none, get_text(first_child(declaration, Identifier)));
        let struct_name: string = mangle_name(declared_type);
        write_line(emitter.type_declarations, "typedef struct " + struct_name + " " + struct_name + ";");
        element_separator_line(emitter.class_declarations);
        write_line(emitter.class_declarations, "struct " + struct_name);
        begin_block(emitter.class_declarations);
        var has_constructors: bool = false;
        for let member: Semantic_Node in node_members(declaration)
        {
            has_constructors = has_constructors or member.kind == ConstructorDeclaration;
            emit_member_declaration(emitter, member, struct_name, true);
        }
        if not has_constructors
        {
            emit_default_constructor(emitter, struct_name, true);
        }
        end_block_with_semicolon(emitter.class_declarations);
    }
    else if declaration.kind == EnumDeclaration
    {
        let enum_name: string = get_text(first_child(declaration, Identifier));
        write_line(emitter.type_declarations, "enum class " + enum_name + "_;");
        element_separator_line(emitter.class_declarations);
        write_line(emitter.class_declarations, "enum class " + enum_name + "_");
        begin_block(emitter.class_declarations);
        for let member: Semantic_Node in declaration.children
        {
            if member.kind == EnumMemberDeclaration
            {
                let member_name: string = get_text(member.children[0]);
                begin_line(emitter.class_declarations, member_name + "_");
                let member_value: Semantic_Node? = first_child(member, Number);
                if member_value =/= none
                {
                    write(emitter.class_declarations, " = ");
                    write(emitter.class_declarations, get_text(member_value));
                }
                end_line(emitter.class_declarations, ",");
            }
        }
        end_block_with_semicolon(emitter.class_declarations);
    }
    else if declaration.kind == FunctionDeclaration
    {
        let parameters_node: Semantic_Node = first_child(declaration, ParameterList);
        var name: string = get_text(first_child(declaration, Identifier));
        let is_main: bool = name == "main";
        name = mangle_function_name(name, |parameters_node.children|);
        if is_main { emitter.main_function_name = name; }
        let parameters: string = convert_parameter_list(emitter, parameters_node, is_main);
        let return_type_node: Semantic_Node = declaration.children[3];
        let cpp_type: string = convert_type(true, return_type_node);
        // Write out the function declaration for C++ so we can call functions defined after others
        write_line(emitter.function_declarations, cpp_type + " " + name + parameters + ";");
        element_separator_line(emitter.definitions);
        write_line(emitter.definitions, cpp_type + " " + name + parameters);
        if is_main
        {
            if emitter.main_function_return_type =/= ""
                { error(emitter.definitions, "Multiple declarations of main"); }
            emitter.main_function_return_type = cpp_type;
        }
        emit_statement(emitter, first_child(declaration, Block));
    }
    else if declaration.kind == EndOfFileToken
    {
        // Ignore the end of file
    }
    else
    {
        error(emitter.definitions, "Could not emit declaration of type " + declaration.kind);
    }
}

public emit_compilation_unit(emitter: mut Emitter, unit: Compilation_Unit) -> void
{
    for let declaration: Semantic_Node in unit.declarations
    {
        emit_declaration(emitter, declaration);
    }
}

public emit_preamble(emitter: mut Emitter) -> void
{
    // Setup the beginning of each section
    write_line(emitter.type_declarations, "#include \"RuntimeLibrary.hpp\"");
    blank_line(emitter.type_declarations);
    write_line(emitter.type_declarations, "// Type Declarations");
    blank_line(emitter.function_declarations);
    write_line(emitter.function_declarations, "// Function Declarations");
    blank_line(emitter.class_declarations);
    write_line(emitter.class_declarations, "// Class Declarations");
    blank_line(emitter.global_definitions);
    write_line(emitter.global_definitions, "// Global Definitions");
    blank_line(emitter.definitions);
    write_line(emitter.definitions, "// Definitions");
}

public emit_entry_point_adapter(emitter: mut Emitter) -> void
{
    element_separator_line(emitter.definitions);
    write_line(emitter.definitions, "// Entry Point Adapter");
    write_line(emitter.definitions, "int32_t main(int argc, char const *const * argv)");
    begin_block(emitter.definitions);

    for let resource: Source_Text in emitter.resources
    {
        begin_line(emitter.definitions, "resource_manager__->AddResource(string(\"");
        write(emitter.definitions, resource.name);
        write(emitter.definitions, "\"), string(\"");
        write(emitter.definitions, resource.text
                                .Replace("\\", "\\\\")
                                .Replace("\n", "\\n")
                                .Replace("\r", "\\r")
                                .Replace("\"", "\\\""));
        end_line(emitter.definitions, "\"));");
    }
    if |emitter.resources| > 0
    {
        end_line(emitter.definitions, ""); // Use EndLine to avoid having an indent on a blank line
    }

    // TODO should be `new mut`
    let args: mut system.text.String_Builder = new system.text.String_Builder();
    if emitter.main_function_accepts_console
        { args.Append("new system__console__Console__0()"); }
    if emitter.main_function_accepts_args
    {
        if emitter.main_function_accepts_console
            { args.Append(", "); }
        args.Append("new system__console__Arguments__0(argc, argv)");
    }

    if emitter.main_function_return_type == "void"
    {
        write_line(emitter.definitions, emitter.main_function_name + "(" + args.ToString() + ");");
        write_line(emitter.definitions, "return 0;");
    }
    else
    {
        write_line(emitter.definitions, "return " + emitter.main_function_name + "(" + args.ToString() + ").value;");
    }

    end_block(emitter.definitions);
}
