
// Names ending with underscores are reserved.
// Names starting with underscore must be ignore/unused so we will never need to
// construct composite names from them. (they will just be varibles)
// Names with 2 or more underscores in the middle, add one underscore.
// Form compound names by joining with double underscore.
// Prefix names with kind indicator.
// Suffix names with number followed by parameters.
//
// # Primitives
// Have no prefix, contain no underscores. Names chosen to avoid conflicts with C/C++
// * cp: code point
// * i32, u32: signed and unsigned int
// * size, offset
// * f32: float
// * f16d16: fixed point
// * str: string
// * bit:  bool
//
// # Tuples
// Have a prefix of `t_` and are followed by type parameters. For example:
// t_2__i__i: is a pair of ints
// This marks them as types and doesn't conflict with any other types because
// their name can't start with a number.
//
// # Prefixes
// The simple name prefixes are:
// * t_ class/struct
// * m_ method
// * fn_ function
// * op_ operator
// * c_ construct
// * new_ new and construct
// * v_ variable (needed to avoid creating a variable that conflicts with another name)
//
// # Combinable prefixes
// Reference and optional types are formed by a sequence of letters in a prefix
// * t: a type that isn't primitive (i.e. most types except primitives will have 't')
// * r: reference (don't need to distinguish class/struct the type name says that)
// * o: optional
//
// Examples:
// * rt_Foo - reference to `Foo`
// * or_i32: optional reference to a variable holding an int
//
// # Generic Type Parameters
// The number of generic is appended after a double underscore (except for none)
// * t_Foo__3 - number of type parameters
//
// # Function Parameter Types
// Number of parameters is appended after double underscore, even for none.

// Then arguments are listed, double underscore, number of segments followed by
// name prefix (run together).  Primitives can be listed in place of the number
// example: f_bar__3_s__0r_system__text__String_Builder__1__0i32__0string
// example: f_bar__3__0i32__0r_system__text__String_Builder__0__string
// f_bar__baz__3__1_i32__3r_system_text__String_Builder
// first parameter doesn't need  double underscore or zero
// additional abbreviations i=i32, u=u32 c=cp, b=bit
public class Emitter
{
    public let package: Package;
    public let resources: system.collections.List<Source_Text>;

    public var type_declarations: mut Source_File_Builder;
    public var function_declarations: mut Source_File_Builder;
    public var class_declarations: mut Source_File_Builder;
    public var global_definitions: mut Source_File_Builder;
    public var definitions: mut Source_File_Builder;

    // TODO compute these in a semantic analysis phase
    public var main_function_name: string;
    public var main_function_return_type: string;
    public var main_function_accepts_console: bool;
    public var main_function_accepts_args: bool;

    public new(package: Package, resources: system.collections.List<Source_Text>)
    {
        self.package = package;
        self.resources = resources;
    }
}

public emit(emitter: mut Emitter) -> string
{
    emitter.type_declarations = new Source_File_Builder();
    emitter.function_declarations = new Source_File_Builder();
    emitter.class_declarations = new Source_File_Builder();
    emitter.global_definitions = new Source_File_Builder();
    emitter.definitions = new Source_File_Builder();
    emitter.main_function_return_type = "";
    emitter.main_function_accepts_console = false;
    emitter.main_function_accepts_args = false;

    emit_preamble(emitter);

    for let compilation_unit: Compilation_Unit in emitter.package.compilation_units
    {
        emit_compilation_unit(emitter, compilation_unit);
    }

    emit_entry_point_adapter(emitter);

    // TODO all of this should be `string.join()`
    // TODO the `string.join()` call should be optimized into existence by the compiler from addition
    let total_size: int
        = emitter.type_declarations.byte_length()
        + emitter.function_declarations.byte_length()
        + emitter.class_declarations.byte_length()
        + emitter.global_definitions.byte_length()
        + emitter.definitions.byte_length();
    let cpp_code: mut system.text.String_Builder = new system.text.String_Builder()/*.with_capacity(total_size)*/;
    cpp_code.Append(emitter.type_declarations.ToString());
    cpp_code.Append(emitter.function_declarations.ToString());
    cpp_code.Append(emitter.class_declarations.ToString());
    cpp_code.Append(emitter.global_definitions.ToString());
    cpp_code.Append(emitter.definitions.ToString());
    return cpp_code.ToString();
}

// TODO implement and use mangle_name(name: Name)
public mangle_name(name: Name) -> string
{
    // TODO what about name.is_special == true?
    let builder: mut system.text.String_Builder = new system.text.String_Builder();
    if name.kind == TypeName
        { builder.Append("t_"); }
    else if name.kind == FunctionName
        { builder.Append("f_"); }
    else if name.kind == VariableName
        { builder.Append("v_"); }

    var first_segment: bool = true;
    for let segment: string in name.segments
    {
        if first_segment
            { first_segment = false; }
        else
            { builder.Append("__"); }

        if not contains_multi_underscore_runs(segment)
            { builder.Append(segment); }
        else
        {
            // Due to limitations with strings and loops, do the equivalent
            // of a for loop
            var underscores: int = 0;
            var i: int = 0;
            while i < segment.ByteLength()
            {
                if segment[i] == '_'
                    { underscores += 1; }
                else if underscores > 0
                {
                    if underscores >= 2
                    {
                        builder.Append("_");
                    }
                    underscores = 0;
                }
                builder.Append(new string(segment[i], 1)); // really bad memory use
                i += 1;
            }
        }
    }
    return builder.ToString();
}

public contains_multi_underscore_runs(value: string) -> bool
{
    // Due to limitations with strings and loops, do the equivalent
    // of a for loop
    var i: int = 0;
    var last_char_underscore: bool = false;
    while i < value.ByteLength()
    {
        if value[i] == '_'
        {
            if last_char_underscore
                { return true; }
            last_char_underscore = true;
        }
        else
            { last_char_underscore = false; }
        i += 1;
    }
    return false;
}

public convert_primitive_type_name(type: Type) -> string
{
    let name: string = unqualified_name(type.name);
    assert(type.is_primitive, name);
    if name == "bool"
    {
        return "bit";
    }
    else if name == "int"
    {
        return "i32";
    }
    else if name == "uint"
    {
        return "u32";
    }
    else if name == "code_point"
    {
        return "cp";
    }
    else if name == "string"
    {
        return "str";
    }
    else if name == "void"
    {
        return "void";
    }
    else
    {
        NOT_IMPLEMENTED(unqualified_name(type.name));
    }
}

// Converts a type to C++
public convert_type_name(type_node: Semantic_Node) -> mut system.text.String_Builder
{
    assert(type_node.referenced_type =/= none, get_text(type_node));
    return convert_type_name(type_node.referenced_type);
}

public convert_type_name(type: Type) -> mut system.text.String_Builder
{
    let cpp_type: mut system.text.String_Builder = new system.text.String_Builder();
    if type.is_primitive
    {
        cpp_type.Append(convert_primitive_type_name(type));
    }
    else
    {
        cpp_type.Append(mangle_name(type.name));
    }

    if |type.type_parameters| > 0
    {
        cpp_type.Append("<");
        var first: bool = true;
        for let type_parameter: Type in type.type_parameters
        {
            if first { first = false; }
            else { cpp_type.Append(", "); }
            cpp_type.Append(convert_type(true, type_parameter, false));
        }
        cpp_type.Append(">");
    }
    return cpp_type;
}

public convert_reference_type(mutable_binding: bool, var type: Type, nullable: bool) -> string
{
    let cpp_type: mut system.text.String_Builder = convert_type_name(type);
    if not type.is_mutable { cpp_type.Append(" const"); }
    cpp_type.Append(" *");
    if nullable
        { cpp_type.Append("_Nullable"); }
    else
        { cpp_type.Append("_Nonnull"); }
    if not mutable_binding { cpp_type.Append(" const") ; }
    return cpp_type.ToString();
}

// Converts a type to C++
public convert_type(mutable_binding: bool, var type: Type, optional: bool) -> string
{
    assert(type =/= none, "");

    if type.is_primitive and unqualified_name(type.name) == "optional"
    {
        let optional_type: Type = type.type_parameters[0];
        if optional_type.is_value_type
        {
            // optional<T> is a const struct
            let cpp_type: mut system.text.String_Builder = new system.text.String_Builder("p_optional<");
            cpp_type.Append(convert_type(true, optional_type, true));
            cpp_type.Append(">");
            if not mutable_binding and not type.is_mutable
                { cpp_type.Append(" const"); }
            return  cpp_type.ToString();
        }
        else
        {
            return convert_type(mutable_binding, optional_type, true);
        }
    }
    else
    {
        if type.is_value_type
        {
            let cpp_type: mut system.text.String_Builder = convert_type_name(type);
            if not mutable_binding and not type.is_mutable
                { cpp_type.Append(" const"); }
            return cpp_type.ToString();
        }
        else
        {
            return convert_reference_type(mutable_binding, type, optional);
        }
    }
}

public convert_type(mutable_binding: bool, type_node: Semantic_Node) -> string
{
    assert(type_node.referenced_type =/= none, get_text(type_node));
    return convert_type(mutable_binding, type_node.referenced_type, false); // not optional
}

public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, is_main_function: bool) -> string
{
    assert(parameters.kind == ParameterList, "parameters.kind=" + parameters.kind);
    let builder: mut system.text.String_Builder = new system.text.String_Builder();
    builder.Append("(");
    var first_parameter: bool = true;
    for let parameter: Semantic_Node in children_of_kind(parameters, Parameter)
    {
        if not first_parameter
            { builder.Append(", "); }
        else
            { first_parameter = false; }

        let mutable_binding: bool = node_has_child(parameter, VarKeyword);
        let type_node: Semantic_Node = parameter.children[|parameter.children| - 1];
        builder.Append(convert_type(mutable_binding, type_node));
        builder.Append(" ");
        builder.Append(get_text(first_child(parameter, Identifier)));
        builder.Append("_");

        if is_main_function
        {
            var type_string: string;
            if type_node.kind == MutableType
                { type_string = get_text(type_node.children[0]); }
            else
                { type_string = get_text(type_node); }
            if type_string == "system.console.Console"
                { emitter.main_function_accepts_console = true; }
            if type_string == "system.console.Arguments"
                { emitter.main_function_accepts_args = true; }
        }
    }
    builder.Append(")");
    return builder.ToString();
}

public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node) -> string
{
    return convert_parameter_list(emitter, parameters, false);
}

public convert_expression(syntax: Semantic_Node, builder: mut Source_File_Builder) -> void
{
    if syntax.kind == NewExpression
    {
        var constructor_name: string = "";
        var type_node: Semantic_Node = syntax.children[0];
        if type_node.kind == QualifiedName
        {
            let name_node: Semantic_Node = type_node.children[1];

            // We assume that if there is no type, then it is a named constructor
            if name_node.kind == IdentifierName
                and name_node.referenced_type == none
            {
                // Named constructor
                constructor_name = "__" + get_text(name_node);
                type_node = type_node.children[0];
            }
        }

        let type: Type = type_node.referenced_type;
        assert(type =/= none, get_text(type_node));
        builder.Write("new_");
        builder.Write(convert_type_name(type).ToString());
        builder.Write(constructor_name);

        let argumentList: Semantic_Node = syntax.children[1];
        convert_expression(argumentList, builder);
    }
    else if syntax.kind == ArgumentList
    {
        builder.Write("(");
        var first_expression: bool = true;
        for let arg: Semantic_Node in syntax.children
        {
            if arg.kind =/= LeftParen
                and arg.kind =/= RightParen
                and arg.kind =/= Comma
            {
                if first_expression
                    { first_expression = false; }
                else
                    { builder.Write(", "); }
                convert_expression(arg, builder);
            }
        }
        builder.Write(")");
    }
    else if syntax.kind == NotExpression
    {
        // TODO change to other functions based on argument type
        builder.Write("bit_not(");
        convert_expression(syntax.children[1], builder);
        builder.Write(")");
    }
    else if syntax.kind == MagnitudeExpression
    {
        convert_expression(syntax.children[1], builder);
        convert_member_access(syntax.children[1], builder);
        builder.Write("op_magnitude()");
    }
    else if syntax.kind == ParenthesizedExpression
    {
        convert_expression(syntax.children[1], builder);
    }
    else if syntax.kind == NegateExpression
    {
        builder.Write("i32_negate(");
        convert_expression(syntax.children[1], builder);
        builder.Write(")");
    }
    else if syntax.kind == NoneLiteralExpression
    {
        builder.Write("none");
    }
    else if syntax.kind == SelfExpression
    {
        builder.Write("self");
    }
    else if syntax.kind == NumericLiteralExpression
    {
        builder.Write("i32(" + get_text(syntax) + ")");
    }
    else if syntax.kind == TrueLiteralExpression
        or syntax.kind == FalseLiteralExpression
    {
        builder.Write("bit_" + get_text(syntax));
    }
    else if syntax.kind == CodePointLiteralExpression
    {
        builder.Write("cp(" + get_text(syntax) + ")");
    }
    else if syntax.kind == IdentifierName
    {
        builder.Write(get_text(syntax) + "_");
    }
    else if syntax.kind == StringLiteralExpression
    {
        builder.Write("str(" + get_text(syntax) + ")");
    }
    else if syntax.kind == AssignmentExpression
    {
        let operator: int = syntax.children[1].kind;
        if operator == Equals
        {
            convert_expression(syntax.children[0], builder);
            builder.Write(" ");
            builder.Write(get_text(syntax.children[1]));
            builder.Write(" ");
            convert_expression(syntax.children[2], builder);
        }
        else
        {
            convert_expression(syntax.children[0], builder);
            convert_member_access(syntax.children[0], builder);
            builder.Write("op_");
            if operator == PlusEquals
            {
                builder.Write("add_assign");
            }
            else if operator == MinusEquals
            {
                builder.Write("subtract_assign");
            }
            else
            {
                builder.Error("Unsupported assignment operator " + operator);
            }
            builder.Write("(");
            convert_expression(syntax.children[2], builder);
            builder.Write(")");
        }
    }
    else if syntax.kind == EqualExpression
    {
        builder.Write("equal_op(");
        convert_expression(syntax.children[0], builder);
        builder.Write(", ");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == NotEqualExpression
    {
        builder.Write("not_equal_op(");
        convert_expression(syntax.children[0], builder);
        builder.Write(", ");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == ComparisonExpression
    {
        // TODO assert the left and right types match
        let operator: int = syntax.children[1].kind;
        let type: Type = syntax.children[0].of_type;
        if type =/= none
        {
            builder.Write(convert_primitive_type_name(type));
            if operator == LessThan
            {
                builder.Write("_less_than");
            }
            else if operator == LessThanEquals
            {
                builder.Write("_less_than_or_equal");
            }
            else if operator == GreaterThan
            {
                builder.Write("_greater_than");
            }
            else if operator == GreaterThanEquals
            {
                builder.Write("_greater_than_or_equal");
            }
            else
            {
                builder.Error("Unsupported comparison operator " + operator);
            }
            builder.Write("(");
            convert_expression(syntax.children[0], builder);
            builder.Write(", ");
            convert_expression(syntax.children[2], builder);
            builder.Write(")");
        }
        else
        {
            // Old style comparison, method on lhs
            convert_expression(syntax.children[0], builder);
            convert_member_access(syntax.children[0], builder);
            builder.Write("op_");
            if operator == LessThan
            {
                builder.Write("less_than");
            }
            else if operator == LessThanEquals
            {
                builder.Write("less_than_or_equal");
            }
            else if operator == GreaterThan
            {
                builder.Write("greater_than");
            }
            else if operator == GreaterThanEquals
            {
                builder.Write("greater_than_or_equal");
            }
            else
            {
                builder.Error("Unsupported comparison operator " + operator);
            }
            builder.Write("(");
            convert_expression(syntax.children[2], builder);
            builder.Write(")");
        }
    }
    else if syntax.kind == AddExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        builder.Write("op_add(");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == SubtractExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        builder.Write("op_subtract(");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == MultiplyExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        builder.Write("op_multiply(");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == DivideExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        builder.Write("op_divide(");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == RemainderExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        builder.Write("op_remainder(");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else if syntax.kind == OrExpression
    {
        // TODO Based on the type of the values involved, either:
        // * bit_op(bit_arg(lhs) || bit_arg(rhs))
        // * ({ T _lhs = lhs; op_true(_lhs) ? _lhs : op_or(_lhs, rhs); })
        // Note: that is a "compound expression"
        builder.Write("bit_op(bit_arg(");
        convert_expression(syntax.children[0], builder);
        builder.Write(") || bit_arg(");
        convert_expression(syntax.children[2], builder);
        builder.Write("))");
    }
    else if syntax.kind == AndExpression
    {
        // TODO Based on the type of the values involved, either:
        // * bit_op(bit_arg(lhs) && bit_arg(rhs))
        // * ({ T _lhs = lhs; op_false(_lhs) ? _lhs : op_and(_lhs, rhs); })
        // Note: that is a "compound expression"
        builder.Write("bit_op(bit_arg(");
        convert_expression(syntax.children[0], builder);
        builder.Write(") && bit_arg(");
        convert_expression(syntax.children[2], builder);
        builder.Write("))");
    }
    else if syntax.kind == InvocationExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_expression(syntax.children[1], builder);
    }
    else if syntax.kind == MemberAccessExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        convert_expression(syntax.children[1], builder);
    }
    else if syntax.kind == ElementAccessExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        builder.Write("op_Element(");
        convert_expression(syntax.children[2], builder);
        builder.Write(")");
    }
    else
    {
        builder.Error("Could not convert expression of type " + syntax.kind);
    }
}

public convert_member_access(lhs: Semantic_Node, builder: mut Source_File_Builder) -> void
{
    let type: Type? = lhs.of_type;
    if type =/= none and type.is_value_type // TODO eventually, we shouldn't need to check if the type is null
        and not (type.is_primitive // optional reference types are still pointers
                and unqualified_name(type.name) == "optional"
                and not type.type_parameters[0].is_value_type)
        { builder.Write("."); }
    else
        { builder.Write("->"); }
}

public emit_statement(emitter: mut Emitter, statement: Semantic_Node) -> void
{
    emitter.definitions.StatementSeparatorLine();

    if statement.kind == ReturnStatement
    {
        if |statement.children| == 2
            { emitter.definitions.WriteLine("return;"); }
        else
        {
            emitter.definitions.BeginLine("return ");
            convert_expression(statement.children[1], emitter.definitions);
            emitter.definitions.EndLine(";");
        }
    }
    else if statement.kind == LoopStatement
    {
        emitter.definitions.WriteLine("for (;;)");
        emit_statement(emitter, statement.children[1]); // Block Statement
    }
    else if statement.kind == Block
    {
        emitter.definitions.BeginBlock();
        for let block_statement: Semantic_Node in node_statements(statement)
        {
            emit_statement(emitter, block_statement);
        }
        emitter.definitions.EndBlock();
    }
    else if statement.kind == WhileStatement
    {
        emitter.definitions.BeginLine("while (cond(");
        convert_expression(statement.children[1], emitter.definitions);
        emitter.definitions.EndLine("))");
        emit_statement(emitter, statement.children[2]); // Block Statement
    }
    else if statement.kind == ForStatement
    {
        emitter.definitions.BeginLine("for (");
        let variable_declaration: Semantic_Node = first_child(statement, VariableDeclaration);
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        let name: string = get_text(first_child(variable_declaration, Identifier));
        let type: Semantic_Node = variable_declaration.children[2];
        emitter.definitions.Write(convert_type(mutable_binding, type) + " " + name + "_");
        emitter.definitions.Write(" : *(");
        convert_expression(statement.children[3], emitter.definitions); // expression
        emitter.definitions.EndLine("))");
        emit_statement(emitter, statement.children[4]); // Block Statement
    }
    else if statement.kind == DoWhileStatement
    {
        emitter.definitions.WriteLine("do");
        emit_statement(emitter, statement.children[1]); // Block Statement
        emitter.definitions.BeginLine("while (cond(");
        convert_expression(statement.children[3], emitter.definitions);
        emitter.definitions.EndLine("));");
    }
    else if statement.kind == IfStatement
    {
        var if_statement: Semantic_Node? = statement;
        emitter.definitions.BeginLine("");
        loop
        {
            emitter.definitions.Write("if (cond(");
            convert_expression(if_statement.children[1], emitter.definitions);
            emitter.definitions.EndLine("))");
            emit_statement(emitter, if_statement.children[2]); // Block Statement
            let elseClause: Semantic_Node? = first_child(if_statement, ElseClause);
            if elseClause =/= none
            {
                if_statement = first_child(elseClause, IfStatement);
                if if_statement =/= none
                {
                    emitter.definitions.BeginLine("else ");
                }
                else
                {
                    emitter.definitions.WriteLine("else");
                    emit_statement(emitter, elseClause.children[1]); // Block Statement
                    break;
                }
            }
            else
                { break; }
        }
    }
    else if statement.kind == BreakStatement
    {
        emitter.definitions.WriteLine("break;");
    }
    else if statement.kind == ContinueStatement
    {
        emitter.definitions.WriteLine("continue;");
    }
    else if statement.kind == LocalDeclarationStatement
    {
        let variable_declaration: Semantic_Node = first_child(statement, VariableDeclaration);
        let variable_name: string = get_text(first_child(variable_declaration, Identifier));
        let variable_type: Semantic_Node = variable_declaration.children[2];
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        emitter.definitions.BeginLine(convert_type(mutable_binding, variable_type));
        emitter.definitions.Write(" " + variable_name + "_");
        if |variable_declaration.children| > 3
        {
            emitter.definitions.Write(" = ");
            convert_expression(variable_declaration.children[3], emitter.definitions);
        }
        emitter.definitions.EndLine(";");
    }
    else if statement.kind == ExpressionStatement
    {
        emitter.definitions.BeginLine("");
        convert_expression(statement.children[0], emitter.definitions);
        emitter.definitions.EndLine(";");
    }
    else
    {
        NOT_IMPLEMENTED("statement.kind=" + statement.kind);
    }
}

public emit_method_body(emitter: mut Emitter, block: Semantic_Node, is_associated_function: bool) -> void
{
    emitter.definitions.BeginBlock();
    if not is_associated_function
    {
        emitter.definitions.WriteLine("auto self = this;");
    }
    for let statement: Semantic_Node in node_statements(block)
    {
        emit_statement(emitter, statement);
    }
    emitter.definitions.EndBlock();
}

public emit_constructor_body(emitter: mut Emitter, block: Semantic_Node, self_type: string, is_value_type: bool) -> void
{
    // TODO this doesn't support explicit return from constructors
    emitter.definitions.BeginBlock();
    if is_value_type
    {
        emitter.definitions.WriteLine(self_type + " self;");
    }
    else
    {
        emitter.definitions.WriteLine(self_type + " self = this;");
    }
    for let statement: Semantic_Node in node_statements(block)
    {
        emit_statement(emitter, statement);
    }
    emitter.definitions.WriteLine("return self;");
    emitter.definitions.EndBlock();
}

public emit_access_modifer(emitter: mut Emitter, current_access_level: int, access_modifer: int) -> int
{
    if access_modifer =/= current_access_level
    {
        // We avoid the indent by using end_line()
        if access_modifer == PublicKeyword
            or access_modifer == InternalKeyword
        {
            emitter.class_declarations.EndLine("public:");
            return PublicKeyword;
        }
        else if access_modifer == ProtectedKeyword
        {
            emitter.class_declarations.EndLine("public:");
        }
        else if access_modifer == PrivateKeyword
        {
            emitter.class_declarations.EndLine("private:");
        }
        else
        {
            THROW_EXCEPTION("Invalid access modifier in Emitter.emit_member_declaration(). kind is " + access_modifer);
        }
    }
    return access_modifer;
}

public emit_member_declaration(emitter: mut Emitter, member: Semantic_Node, class_name: string, is_value_type: bool, current_access_level: int) -> int
{
    var access_modifer: int = node_access_modifier(member).kind;
    if member.kind == ConstructorDeclaration // always make constructors public so they can be called by `new_` functions
        { access_modifer = PublicKeyword; }
    access_modifer = emit_access_modifer(emitter, current_access_level, access_modifer);
    if member.kind == ConstructorDeclaration
    {
        let parameters: string = convert_parameter_list(emitter, first_child(member, ParameterList));
        var new_function_name: string = "new_" + class_name;
        var constructor_full_name: string = "construct";
        let constructor_name_node: Semantic_Node? = first_child(member, Identifier);
        if constructor_name_node =/= none
        {
            let constructor_name: string = get_text(constructor_name_node);
            new_function_name = new_function_name + "__" + constructor_name;
            constructor_full_name = "construct_" + constructor_name;
        }
        var return_type: string = class_name;
        if not is_value_type
            { return_type = return_type + " *_Nonnull"; }
        // Write out the declaration for C++ so we can call functions defined after others
        emitter.class_declarations.BeginLine("");
        if is_value_type { emitter.class_declarations.Write("static "); }
        emitter.class_declarations.EndLine("auto " + constructor_full_name + parameters + " -> " + return_type + ";");
        emitter.definitions.ElementSeparatorLine();
        emitter.definitions.WriteLine("auto " + class_name + "::" + constructor_full_name + parameters + " -> " + return_type);
        emit_constructor_body(emitter, first_child(member, Block), return_type, is_value_type);
        // Write out new function
        emitter.function_declarations.WriteLine("inline " + return_type + " " + new_function_name + parameters + ";");
        emitter.definitions.ElementSeparatorLine();
        emitter.definitions.WriteLine("inline " + return_type + " " + new_function_name + parameters);
        emitter.definitions.BeginBlock();
        if not is_value_type
            { emitter.definitions.BeginLine("return (new " + class_name + "())->" + constructor_full_name + "("); }
        else
            { emitter.definitions.BeginLine("return " + class_name + "::" + constructor_full_name + "("); }
        var first_parameter: bool = true;
        for let parameter: Semantic_Node in first_child(member, ParameterList).children
        {
            if not first_parameter
                { emitter.definitions.Write(", "); }
            else
                { first_parameter = false; }

            emitter.definitions.Write(get_text(first_child(parameter, Identifier)) + "_");
        }
        emitter.definitions.EndLine(");");
        emitter.definitions.EndBlock();
    }
    else if member.kind == FieldDeclaration
    {
        let variable_declaration: Semantic_Node = first_child(member, VariableDeclaration);
        let field_name: string = get_text(first_child(variable_declaration, Identifier));
        let field_type: Semantic_Node = variable_declaration.children[2];
        let cpp_type: string = convert_type(true, field_type); // because we need to assign them in constructors don't mark fields const
        emitter.class_declarations.WriteLine(cpp_type + " " + field_name + "_;");
    }
    else if member.kind == MethodDeclaration
    {
        let method_name: string = get_text(first_child(member, Identifier));
        let parameters: string = convert_parameter_list(emitter, first_child(member, ParameterList));
        let self_parameter: Semantic_Node? = first_child(first_child(member, ParameterList), SelfParameter);
        let is_associated_function: bool = self_parameter == none;
        let mutable_self: bool = not is_associated_function and node_has_child(self_parameter, MutableKeyword);
        let return_type_node: Semantic_Node = member.children[3];
        let cpp_type: string = convert_type(true, return_type_node);
        var static_modifier: string = "";
        if is_associated_function
            { static_modifier = "static "; }
        var constModifier: string = "";
        if not mutable_self and not is_associated_function
            { constModifier = "const "; }
        emitter.class_declarations.WriteLine(static_modifier + "auto " + method_name + "_" + parameters + " " + constModifier + "-> " + cpp_type + ";");
        emitter.definitions.ElementSeparatorLine();
        emitter.definitions.WriteLine("auto ::" + class_name + "::" + method_name + "_" + parameters + " " + constModifier + "-> " + cpp_type);
        let block: Semantic_Node = first_child(member, Block);
        emit_method_body(emitter, block, is_associated_function);
    }
    else
    {
        emitter.definitions.Error("Could not emit member of type " + member.kind);
    }

    return access_modifer;
}

public emit_default_constructor(emitter: mut Emitter, type_name: string, is_value_type: bool, current_access_level: int) -> void
{
    emit_access_modifer(emitter, current_access_level, PublicKeyword);

    var return_type: string = type_name;
    if not is_value_type
        { return_type = return_type + " *_Nonnull"; }
    // Write out the declaration for C++ so we can call functions defined after others
    emitter.class_declarations.BeginLine("");
    if is_value_type { emitter.class_declarations.Write("static "); }
    emitter.class_declarations.Write("auto construct() -> " + return_type);
    if is_value_type
        { emitter.class_declarations.EndLine(" { return " + type_name + "(); }"); }
    else
        { emitter.class_declarations.EndLine(" { return this; }"); }

    // Write out new function
    emitter.function_declarations.WriteLine("inline " + return_type + " new_" + type_name + "();");
    emitter.definitions.ElementSeparatorLine();
    emitter.definitions.WriteLine("inline " + return_type + " new_" + type_name + "()");
    emitter.definitions.BeginBlock();
    if not is_value_type
        { emitter.definitions.WriteLine("return (new " + type_name + "())->construct();"); }
    else
        { emitter.definitions.WriteLine("return " + type_name + "::construct();"); }
    emitter.definitions.EndBlock();
}

public emit_declaration(emitter: mut Emitter, declaration: Semantic_Node) -> void
{
    if declaration.kind == GlobalDeclaration
    {
        let variable_declaration: Semantic_Node = first_child(declaration, VariableDeclaration);
        let variable_name: string = get_text(first_child(variable_declaration, Identifier));
        let variable_type: Semantic_Node = variable_declaration.children[2];
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        let cpp_type: string = convert_type(mutable_binding, variable_type);
        emitter.global_definitions.BeginLine(cpp_type);
        emitter.global_definitions.Write(" " + variable_name + "_ = ");
        let expression: Semantic_Node = variable_declaration.children[3];
        convert_expression(expression, emitter.global_definitions);
        emitter.global_definitions.EndLine(";");
    }
    else if declaration.kind == ClassDeclaration
    {
        let declared_type: Type = declaration.declares_type;
        assert(declared_type =/= none, get_text(first_child(declaration, Identifier)));
        let class_name: string = mangle_name(declared_type.name);
        emitter.type_declarations.WriteLine("class " + class_name + ";");
        emitter.class_declarations.ElementSeparatorLine();
        emitter.class_declarations.WriteLine("class " + class_name);
        emitter.class_declarations.BeginBlock();
        emitter.class_declarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
        var current_access_level: int = PublicKeyword;
        var has_constructors: bool = false;
        for let member: Semantic_Node in node_members(declaration)
        {
            has_constructors = has_constructors or member.kind == ConstructorDeclaration;
            current_access_level = emit_member_declaration(emitter, member, class_name, false, current_access_level);
        }
        if not has_constructors
        {
            emit_default_constructor(emitter, class_name, false, current_access_level);
        }
        emitter.class_declarations.EndBlockWithSemicolon();
    }
    else if declaration.kind == StructDeclaration
    {
        let declared_type: Type = declaration.declares_type;
        assert(declared_type =/= none, get_text(first_child(declaration, Identifier)));
        let struct_name: string = mangle_name(declared_type.name);
        emitter.type_declarations.WriteLine("struct " + struct_name + ";");
        emitter.class_declarations.ElementSeparatorLine();
        emitter.class_declarations.WriteLine("struct " + struct_name + " final");
        emitter.class_declarations.BeginBlock();
        emitter.class_declarations.EndLine("public:"); // Assume we aren't nested, avoid the indent
        // Write out arrow and dereference operators for using value types like reference types
        // TODO Emit correct code to use value types as value types rather than reference types and drop this code
        emitter.class_declarations.WriteLine(struct_name + " * operator->() { return this; }");
        emitter.class_declarations.WriteLine(struct_name + " const * operator->() const { return this; }");
        emitter.class_declarations.WriteLine(struct_name + " & operator* () { return *this; }");
        emitter.class_declarations.WriteLine(struct_name + " const & operator* () const { return *this; }");
        var current_access_level: int = PublicKeyword;
        var has_constructors: bool = false;
        for let member: Semantic_Node in node_members(declaration)
        {
            has_constructors = has_constructors or member.kind == ConstructorDeclaration;
            current_access_level = emit_member_declaration(emitter, member, struct_name, true, current_access_level);
        }
        if not has_constructors
        {
            emit_default_constructor(emitter, struct_name, true, current_access_level);
        }
        emitter.class_declarations.EndBlockWithSemicolon();
    }
    else if declaration.kind == EnumDeclaration
    {
        let enum_name: string = get_text(first_child(declaration, Identifier));
        emitter.type_declarations.WriteLine("enum class " + enum_name + "_;");
        emitter.class_declarations.ElementSeparatorLine();
        emitter.class_declarations.WriteLine("enum class " + enum_name + "_");
        emitter.class_declarations.BeginBlock();
        for let member: Semantic_Node in declaration.children
        {
            if member.kind == EnumMemberDeclaration
            {
                let member_name: string = get_text(member.children[0]);
                emitter.class_declarations.BeginLine(member_name + "_");
                let member_value: Semantic_Node? = first_child(member, Number);
                if member_value =/= none
                {
                    emitter.class_declarations.Write(" = ");
                    emitter.class_declarations.Write(get_text(member_value));
                }
                emitter.class_declarations.EndLine(",");
            }
        }
        emitter.class_declarations.EndBlockWithSemicolon();
    }
    else if declaration.kind == FunctionDeclaration
    {
        let name: string = get_text(first_child(declaration, Identifier));
        let is_main: bool = name == "main";
        if is_main { emitter.main_function_name = name; }
        let parameters: string = convert_parameter_list(emitter, first_child(declaration, ParameterList), is_main);
        let return_type_node: Semantic_Node = declaration.children[3];
        let cpp_type: string = convert_type(true, return_type_node);
        // Write out the function declaration for C++ so we can call functions defined after others
        emitter.function_declarations.WriteLine("auto " + name + "_" + parameters + " -> " + cpp_type + ";");
        emitter.definitions.ElementSeparatorLine();
        emitter.definitions.WriteLine("auto " + name + "_" + parameters + " -> " + cpp_type);
        if is_main
        {
            if emitter.main_function_return_type =/= ""
                { emitter.definitions.Error("Multiple declarations of main"); }
            emitter.main_function_return_type = cpp_type;
        }
        emit_statement(emitter, first_child(declaration, Block));
    }
    else if declaration.kind == EndOfFileToken
    {
        // Ignore the end of file
    }
    else
    {
        emitter.definitions.Error("Could not emit declaration of type " + declaration.kind);
    }
}

public emit_compilation_unit(emitter: mut Emitter, unit: Compilation_Unit) -> void
{
    for let declaration: Semantic_Node in unit.declarations
    {
        emit_declaration(emitter, declaration);
    }
}

public emit_preamble(emitter: mut Emitter) -> void
{
    // Setup the beginning of each section
    emitter.type_declarations.WriteLine("#include \"RuntimeLibrary.hpp\"");
    emitter.type_declarations.BlankLine();
    emitter.type_declarations.WriteLine("// Type Declarations");
    emitter.function_declarations.BlankLine();
    emitter.function_declarations.WriteLine("// Function Declarations");
    emitter.class_declarations.BlankLine();
    emitter.class_declarations.WriteLine("// Class Declarations");
    emitter.global_definitions.BlankLine();
    emitter.global_definitions.WriteLine("// Global Definitions");
    emitter.definitions.BlankLine();
    emitter.definitions.WriteLine("// Definitions");
}

public emit_entry_point_adapter(emitter: mut Emitter) -> void
{
    emitter.definitions.ElementSeparatorLine();
    emitter.definitions.WriteLine("// Entry Point Adapter");
    emitter.definitions.WriteLine("std::int32_t main(int argc, char const *const * argv)");
    emitter.definitions.BeginBlock();

    emitter.definitions.WriteLine("try");
    emitter.definitions.BeginBlock();

    for let resource: Source_Text in emitter.resources
    {
        emitter.definitions.BeginLine("resource_manager_->AddResource(str(\"");
        emitter.definitions.Write(resource.name);
        emitter.definitions.Write("\"), str(\"");
        emitter.definitions.Write(resource.text
                                .Replace("\\", "\\\\")
                                .Replace("\n", "\\n")
                                .Replace("\r", "\\r")
                                .Replace("\"", "\\\""));
        emitter.definitions.EndLine("\"));");
    }
    if |emitter.resources| > 0
    {
        emitter.definitions.EndLine(""); // Use EndLine to avoid having an indent on a blank line
    }

    // TODO should be `new mut`
    let args: mut system.text.String_Builder = new system.text.String_Builder();
    if emitter.main_function_accepts_console
        { args.Append("new t_system__console__Console()"); }
    if emitter.main_function_accepts_args
    {
        if emitter.main_function_accepts_console
            { args.Append(", "); }
        args.Append("new t_system__console__Arguments(argc, argv)");
    }

    if emitter.main_function_return_type == "void"
    {
        emitter.definitions.WriteLine(emitter.main_function_name + "_(" + args.ToString() + ");");
        emitter.definitions.WriteLine("return 0;");
    }
    else
    {
        emitter.definitions.WriteLine("return " + emitter.main_function_name + "_(" + args.ToString() + ").value;");
    }

    emitter.definitions.EndBlock(); // try
    emitter.definitions.WriteLine("catch(std::exception &ex)");
    emitter.definitions.BeginBlock();
    emitter.definitions.WriteLine("std::printf(\"Program exited due to error:\\n\");");
    emitter.definitions.WriteLine("std::printf(\"%s\", ex.what());");
    emitter.definitions.WriteLine("return 70;"); // Defined by sysexits.h as EX_SOFTWARE
    emitter.definitions.EndBlock();

    emitter.definitions.EndBlock();
}
