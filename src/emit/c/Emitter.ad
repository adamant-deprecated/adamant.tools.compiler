public class Emitter
{
    public let package: Package;
    public let resources: system.collections.List<Source_Text>;

    public var includes: mut Source_File_Builder;
    public var type_id_declaration: mut Source_File_Builder;
    public var type_declarations: mut Source_File_Builder;
    public var function_declarations: mut Source_File_Builder;
    public var class_declarations: mut Source_File_Builder;
    public var global_definitions: mut Source_File_Builder;
    public var definitions: mut Source_File_Builder;

    // TODO compute these in a semantic analysis phase
    public var main_function_name: string;
    public var main_function_return_type: string;
    public var main_function_accepts_console: bool;
    public var main_function_accepts_args: bool;

    public new(package: Package, resources: system.collections.List<Source_Text>)
    {
        self.package = package;
        self.resources = resources;
    }
}

public emit(emitter: mut Emitter) -> string
{
    emitter.includes = new Source_File_Builder();
    emitter.type_id_declaration = new Source_File_Builder();
    emitter.type_declarations = new Source_File_Builder();
    emitter.function_declarations = new Source_File_Builder();
    emitter.class_declarations = new Source_File_Builder();
    emitter.global_definitions = new Source_File_Builder();
    emitter.definitions = new Source_File_Builder();
    emitter.main_function_return_type = "";
    emitter.main_function_accepts_console = false;
    emitter.main_function_accepts_args = false;

    emit_preamble(emitter);

    for let compilation_unit: Compilation_Unit in emitter.package.compilation_units
    {
        emit_compilation_unit(emitter, compilation_unit);
    }

    emit_entry_point_adapter(emitter);

    emit_postamble(emitter);

    // TODO all of this should be `string.join()`
    // TODO the `string.join()` call should be optimized into existence by the compiler from addition
    let total_size: int
        = 0 // Hack so it knows these are integer adds, not string concatenations
        + byte_length(emitter.includes)
        + byte_length(emitter.type_id_declaration)
        + byte_length(emitter.type_declarations)
        + byte_length(emitter.function_declarations)
        + byte_length(emitter.class_declarations)
        + byte_length(emitter.global_definitions)
        + byte_length(emitter.definitions);
    let c_code: mut system.text.String_Builder = new system.text.String_Builder.with_capacity(total_size);
    sb_append(c_code, to_string(emitter.includes));
    sb_append(c_code, to_string(emitter.type_id_declaration));
    sb_append(c_code, to_string(emitter.type_declarations));
    sb_append(c_code, to_string(emitter.function_declarations));
    sb_append(c_code, to_string(emitter.class_declarations));
    sb_append(c_code, to_string(emitter.global_definitions));
    sb_append(c_code, to_string(emitter.definitions));
    return sb_to_string(c_code);
}

public mangle_name(type: Type) -> string
{
    // TODO what about name.is_special == true?
    let builder: mut system.text.String_Builder = new system.text.String_Builder();

    var first_segment: bool = true;
    for let segment: string in type.name.segments
    {
        if first_segment
            { first_segment = false; }
        else
            { sb_append(builder, "__"); }

        if not contains_multi_underscore_runs(segment)
            { sb_append(builder, segment); }
        else
            { append_fixing_underscores(builder, segment); }
    }

    sb_append(builder, "__");
    sb_append(builder, int_to_string(type.type_parameters.count));

    return sb_to_string(builder);
}

public mangle_function_name(name: string, parameter_count: int) -> string
{
    let builder: mut system.text.String_Builder = new system.text.String_Builder();
    if not contains_multi_underscore_runs(name)
        { sb_append(builder, name); }
    else
        { append_fixing_underscores(builder, name); }
    sb_append(builder, "__");
    sb_append(builder, int_to_string(parameter_count));
    return sb_to_string(builder);
}

public mangle_field_name(name: string) -> string
{
      if not contains_multi_underscore_runs(name)
        { return name + "__"; }
    else
    {
        let builder: mut system.text.String_Builder = new system.text.String_Builder();
        append_fixing_underscores(builder, name);
        sb_append(builder, "__");
        return sb_to_string(builder);
    }
}

public contains_multi_underscore_runs(value: string) -> bool
{
    // Due to limitations with strings and loops, do the equivalent
    // of a for loop
    var i: int = 0;
    var last_char_underscore: bool = false;
    while i < string_byte_length(value)
    {
        if value[i] == '_'
        {
            if last_char_underscore
                { return true; }
            last_char_underscore = true;
        }
        else
            { last_char_underscore = false; }
        i += 1;
    }
    return false;
}

public append_fixing_underscores(builder: mut system.text.String_Builder, value: string) -> void
{
    // Due to limitations with strings and loops, do the equivalent
    // of a for loop
    var underscores: int = 0;
    var i: int = 0;
    while i < string_byte_length(value)
    {
        if value[i] == '_'
            { underscores += 1; }
        else if underscores > 0
        {
            if underscores >= 2
            {
                sb_append(builder, "_");
            }
            underscores = 0;
        }
        sb_append(builder, new string(value[i], 1)); // really bad memory use
        i += 1;
    }
}

public convert_primitive_type_name(type: Type) -> string
{
    let name: string = unqualified_name(type.name);
    assert(type.is_primitive, name);
    if name == "bool"
    {
        return "BOOL";
    }
    else if name == "int"
    {
        return "int32";
    }
    else if name == "uint"
    {
        return "uint32";
    }
    else
    {
        return name;
    }
}

// Converts a type to C
// public convert_type_node_name(type_node: Semantic_Node) -> mut system.text.String_Builder
// {
//     assert(type_node.referenced_type =/= none, get_semantic_node_text(type_node));
//     return convert_type_name(type_node.referenced_type);
// }

public convert_type_name(type: Type) -> mut system.text.String_Builder
{
    return convert_type_name(type, true);
}

public convert_type_name(type: Type, include_type_parameters: bool) -> mut system.text.String_Builder
{
    let c_type: mut system.text.String_Builder = new system.text.String_Builder();
    if type.is_primitive
    {
        sb_append(c_type, convert_primitive_type_name(type));
    }
    else
    {
        sb_append(c_type, mangle_name(type));
    }

    // if type.type_parameters.count > 0 and include_type_parameters
    // {
    //     convert_type_name_parameters(c_type, type);
    // }
    return c_type;
}

public convert_type_name_parameters(builder: mut system.text.String_Builder, type: Type) -> void
{
    sb_append(builder, "<");
    var first: bool = true;
    for let type_parameter: Type in type.type_parameters
    {
        if first { first = false; }
        else { sb_append(builder, ", "); }
        sb_append(builder, convert_type(true, type_parameter, false));
    }
    sb_append(builder, ">");
}

public convert_reference_type(mutable_binding: bool, var type: Type, nullable: bool) -> string
{
    let c_type: mut system.text.String_Builder = convert_type_name(type);
    if type.is_mutable
        { sb_append(c_type, " mut"); }
    else
        { sb_append(c_type, " const"); }
    if nullable
        { sb_append(c_type, " opt_ref"); }
    else
        { sb_append(c_type, " ref"); }
    if mutable_binding
        { sb_append(c_type, " mut"); }
    else
        { sb_append(c_type, " const"); }
    return sb_to_string(c_type);
}

// Converts a type to C
public convert_type(mutable_binding: bool, var type: Type, optional: bool) -> string
{
    assert(type =/= none);

    if type.is_primitive and unqualified_name(type.name) == "optional"
    {
        let optional_type: Type = type.type_parameters[0];
        if optional_type.is_value_type
        {
            // optional<T> is a const struct
            let c_type: mut system.text.String_Builder = new system.text.String_Builder("optional__");
            if mutable_binding
                { sb_append(c_type, "0var__"); }
            if type.is_mutable
                { sb_append(c_type, "0mut__"); }
            sb_append(c_type, convert_type(true, optional_type, true));

            return  sb_to_string(c_type);
        }
        else
        {
            return convert_type(mutable_binding, optional_type, true);
        }
    }
    else
    {
        if type.is_value_type
        {
            let c_type: mut system.text.String_Builder = convert_type_name(type);
            if mutable_binding or type.is_mutable
                { sb_append(c_type, " mut"); }
            else
                { sb_append(c_type, " const"); }
            return sb_to_string(c_type);
        }
        else
        {
            return convert_reference_type(mutable_binding, type, optional);
        }
    }
}

public convert_type(mutable_binding: bool, type_node: Semantic_Node) -> string
{
    assert(type_node.referenced_type =/= none, get_semantic_node_text(type_node));
    return convert_type(mutable_binding, type_node.referenced_type, false); // not optional
}

// TODO can't have `self_type` be a nullable string because comparison not implemented yet
public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, self_type: string, is_main_function: bool) -> string
{
    assert(parameters.kind == ParameterList, "parameters.kind=" + int_to_string(parameters.kind));
    let builder: mut system.text.String_Builder = new system.text.String_Builder();
    sb_append(builder, "(");
    if string_byte_length(self_type) > 0
    {
        sb_append(builder, self_type);
        sb_append(builder, " self");
    }
    var first_parameter: bool = string_byte_length(self_type) == 0;
    for let parameter: Semantic_Node in children_of_kind(parameters, Parameter)
    {
        if not first_parameter
            { sb_append(builder, ", "); }
        else
            { first_parameter = false; }

        let mutable_binding: bool = node_has_child(parameter, VarKeyword);
        let type_node: Semantic_Node = parameter.children[parameter.children.count - 1];
        sb_append(builder, convert_type(mutable_binding, type_node));
        sb_append(builder, " ");
        sb_append(builder, mangle_field_name(get_semantic_node_text(first_child(parameter, Identifier))));

        if is_main_function
        {
            var type_string: string;
            if type_node.kind == MutableType
                { type_string = get_semantic_node_text(type_node.children[0]); }
            else
                { type_string = get_semantic_node_text(type_node); }
            if type_string == "system.console.Console"
                { emitter.main_function_accepts_console = true; }
            if type_string == "system.console.Arguments"
                { emitter.main_function_accepts_args = true; }
        }
    }
    sb_append(builder, ")");
    return sb_to_string(builder);
}

public convert_method_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, self_type: string) -> string
{
    return convert_parameter_list(emitter, parameters, self_type, false);
}

public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node, is_main_function: bool) -> string
{
    return convert_parameter_list(emitter, parameters, "", is_main_function);
}

public convert_parameter_list(emitter: mut Emitter, parameters: Semantic_Node) -> string
{
    return convert_parameter_list(emitter, parameters, "", false);
}

public convert_expression(syntax: Semantic_Node, builder: mut Source_File_Builder) -> void
{
    if syntax.kind == NewExpression
    {
        var constructor_name: string = "";
        var type_node: Semantic_Node = syntax.children[0];
        if type_node.kind == QualifiedName
        {
            let name_node: Semantic_Node = type_node.children[1];

            // We assume that if there is no type, then it is a named constructor
            if name_node.kind == IdentifierName
                and name_node.referenced_type == none
            {
                // Named constructor
                constructor_name = "__" + get_semantic_node_text(name_node);
                type_node = type_node.children[0];
            }
        }

        let type: Type = type_node.referenced_type;
        assert(type =/= none, get_semantic_node_text(type_node));
        write(builder, sb_to_string(convert_type_name(type, false)));
        write(builder, "__0new");
        write(builder, constructor_name);
        write(builder, "__");
        let argument_list: Semantic_Node = syntax.children[1];
        write(builder, int_to_string(node_argument_count(argument_list)));
        // if type.type_parameters.count > 0
        // {
        //     let params: mut system.text.String_Builder = new system.text.String_Builder();
        //     convert_type_parameters(params, type);
        //     write(builder, sb_to_string(params));
        // }

        if type.is_value_type
            { convert_expression(argument_list, builder); }
        else
            { convert_reference_type_constructor_arguments(argument_list, builder, sb_to_string(convert_type_name(type))); }
    }
    else if syntax.kind == ArgumentList
    {
        write(builder, "(");
        var first_expression: bool = true;
        for let arg: Semantic_Node in syntax.children
        {
            if arg.kind =/= LeftParen
                and arg.kind =/= RightParen
                and arg.kind =/= Comma
            {
                if first_expression
                    { first_expression = false; }
                else
                    { write(builder, ", "); }
                convert_expression(arg, builder);
            }
        }
        write(builder, ")");
    }
    else if syntax.kind == NotExpression
    {
        // TODO change to other functions based on argument type
        write(builder, "BOOL__0op__not(");
        convert_expression(syntax.children[0], builder);
        write(builder, ")");
    }
    else if syntax.kind == ParenthesizedExpression
    {
        convert_expression(syntax.children[0], builder);
    }
    else if syntax.kind == NegateExpression
    {
        write(builder, "int32__0op__neg(");
        convert_expression(syntax.children[0], builder);
        write(builder, ")");
    }
    else if syntax.kind == NoneLiteralExpression
    {
        write(builder, "none");
    }
    else if syntax.kind == SelfExpression
    {
        write(builder, "self");
    }
    else if syntax.kind == IntegerLiteralExpression
    {
        // Extra parens are needed in some weird cases with macros
        write(builder, "((int32){" + get_semantic_node_text(syntax) + "})");
    }
    else if syntax.kind == TrueLiteralExpression
    {
        write(builder, "TRUE");
    }
    else if syntax.kind == FalseLiteralExpression
    {
        write(builder, "FALSE");
    }
    else if syntax.kind == CodePointLiteralExpression
    {
        // Extra parens are needed in some weird cases with macros
        // TODO write this out as hex or something
        let raw_value: string = get_semantic_node_text(syntax);
        let code_point_value: code_point = code_point_literal_value(raw_value);
        write(builder, "((code_point){/*" + substring(raw_value, 1, string_byte_length(raw_value)-2)
            + "*/0x" + int_to_hex_string(code_point_as_int(code_point_value)) + "})");
    }
    else if syntax.kind == IdentifierName
    {
        write(builder, mangle_field_name(get_semantic_node_text(syntax)));
    }
    else if syntax.kind == StringLiteralExpression
    {
        let value: string = get_semantic_node_text(syntax);
        // Extra parens are needed in some weird cases with macros
        write(builder, "((string){" + int_to_string(literal_length(value)) + ",(uint8_t const*)" + value + "})");
    }
    else if syntax.kind == AssignmentExpression
    {
        let child: Semantic_Node = syntax.children[1];
        let operator: int = child.kind;
        if operator == Equals
        {
            convert_expression(syntax.children[0], builder);
            write(builder, " ");
            write(builder, get_semantic_node_text(syntax.children[1]));
            write(builder, " ");
            convert_expression(syntax.children[2], builder);
        }
        else
        {
            write(builder, "op__");
            if operator == PlusEquals
            {
                write(builder, "add_assign");
            }
            else if operator == MinusEquals
            {
                write(builder, "sub_assign");
            }
            else
            {
                error(builder, "Unsupported assignment operator " + int_to_string(operator));
            }
            write(builder, "(&(");
            convert_expression(syntax.children[0], builder);
            write(builder, "), ");
            convert_expression(syntax.children[2], builder);
            write(builder, ")");
        }
    }
    else if syntax.kind == EqualExpression
    {
        let lhs_node: Semantic_Node = syntax.children[0];
        let rhs_node: Semantic_Node = syntax.children[1];
        var type: Type = lhs_node.of_type;
        if type == none { type = rhs_node.of_type; }
        if type =/= none
        {
            if type.is_primitive and unqualified_name(type.name) == "optional"
                { type = type.type_parameters[0]; }

            if type.is_primitive
                { write(builder, convert_primitive_type_name(type)); }
            else
                { write(builder, "void_ptr"); }
            write(builder, "__0op__equal(");
        }
        else
        {
            // TODO defaulting to this because the compiler often compares to a int kind value
            write(builder, "int32__0op__equal(");
        }
        convert_expression(lhs_node, builder);
        write(builder, ", ");
        convert_expression(rhs_node, builder);
        write(builder, ")");
    }
    else if syntax.kind == NotEqualExpression
    {
        let lhs_node: Semantic_Node = syntax.children[0];
        let rhs_node: Semantic_Node = syntax.children[1];
        var type: Type = lhs_node.of_type;
        if type == none { type = rhs_node.of_type; }
        if type =/= none
        {
            if type.is_primitive and unqualified_name(type.name) == "optional"
                { type = type.type_parameters[0]; }

            if type.is_primitive
                { write(builder, convert_primitive_type_name(type)); }
            else
                { write(builder, "void_ptr"); }
            write(builder, "__0op__not_equal(");
        }
        else
        {
            // TODO defaulting to this because the compiler often compares to a int kind value
            write(builder, "int32__0op__not_equal(");
        }
        convert_expression(lhs_node, builder);
        write(builder, ", ");
        convert_expression(rhs_node, builder);
        write(builder, ")");
    }
    else if syntax.kind == ComparisonExpression
    {
        // TODO assert the left and right types match
        var child: Semantic_Node = syntax.children[1];
        let operator: int = child.kind;
        child = syntax.children[0];
        let type: Type = child.of_type;
        if type =/= none
        {
            write(builder, convert_primitive_type_name(type));
        }
        else
        {
            // TODO we just assume they are `int`s, that could be wrong
            write(builder, "int32");
        }

        if operator == LessThan
        {
            write(builder, "__0op__lt");
        }
        else if operator == LessThanEquals
        {
            write(builder, "__0op__lte");
        }
        else if operator == GreaterThan
        {
            write(builder, "__0op__gt");
        }
        else if operator == GreaterThanEquals
        {
            write(builder, "__0op__gte");
        }
        else
        {
            error(builder, "Unsupported comparison operator " + int_to_string(operator));
        }
        write(builder, "(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else if syntax.kind == AddExpression
    {
        let lhs_node: Semantic_Node = syntax.children[0];
        let rhs_node: Semantic_Node = syntax.children[1];
        var type: Type = lhs_node.of_type;
        if type == none { type == rhs_node.of_type; }
        if type =/= none
        {
            write(builder, convert_primitive_type_name(type));
        }
        else
        {
            // TODO we just assume they are `string`s, that could be wrong
            // Seems more likely that the result of two function calls would be string
            write(builder, "string");
        }
        write(builder, "__0op__add(");
        convert_expression(lhs_node, builder);
        write(builder, ", ");
        convert_expression(rhs_node, builder);
        write(builder, ")");
    }
    else if syntax.kind == SubtractExpression
    {
        let lhs_node: Semantic_Node = syntax.children[0];
        let rhs_node: Semantic_Node = syntax.children[1];
        write(builder, "int32__0op__sub(");
        convert_expression(lhs_node, builder);
        write(builder, ", ");
        convert_expression(rhs_node, builder);
        write(builder, ")");
    }
    else if syntax.kind == MultiplyExpression
    {
        write(builder, "int32__0op__mul(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[1], builder);
        write(builder, ")");
    }
    else if syntax.kind == DivideExpression
    {
        write(builder, "int32__0op__div(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[1], builder);
        write(builder, ")");
    }
    else if syntax.kind == RemainderExpression
    {
        write(builder, "int32__0op__remainder(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[1], builder);
        write(builder, ")");
    }
    else if syntax.kind == OrExpression
    {
        // TODO Based on the type of the values involved, either:
        // * bool_op(bool_arg(lhs) || bool_arg(rhs))
        // * ({ T _lhs = lhs; op__true(_lhs) ? _lhs : op__or(_lhs, rhs); })
        // Note: that is a "compound expression"
        write(builder, "bool_op(bool_arg(");
        convert_expression(syntax.children[0], builder);
        write(builder, ") || bool_arg(");
        convert_expression(syntax.children[1], builder);
        write(builder, "))");
    }
    else if syntax.kind == AndExpression
    {
        // TODO Based on the type of the values involved, either:
        // * bool_op(bool_arg(lhs) && bool_arg(rhs))
        // * ({ T _lhs = lhs; op__false(_lhs) ? _lhs : op__and(_lhs, rhs); })
        // Note: that is a "compound expression"
        write(builder, "bool_op(bool_arg(");
        convert_expression(syntax.children[0], builder);
        write(builder, ") && bool_arg(");
        convert_expression(syntax.children[1], builder);
        write(builder, "))");
    }
    else if syntax.kind == InvocationExpression
    {
        convert_expression(syntax.children[0], builder);
        // Assuming we just emitted the function name as a field, tack this on
        let parameters_node: Semantic_Node = syntax.children[1];
        // TODO we don't handle the arguments list correctly yet, so it still has the parens as children
        write(builder, int_to_string(node_argument_count(parameters_node)));
        convert_expression(parameters_node, builder);
    }
    else if syntax.kind == MemberAccessExpression
    {
        convert_expression(syntax.children[0], builder);
        convert_member_access(syntax.children[0], builder);
        convert_expression(syntax.children[1], builder);
    }
    else if syntax.kind == ElementAccessExpression
    {
        let child: Semantic_Node = syntax.children[0];
        var type: Type = child.of_type;
        if type =/= none
        {
            write(builder, mangle_name(type));
            write(builder, "__0");
        }
        else
        {
            // if we don't know the type, assum List<T>
            write(builder, "system__collections__List__1__0");
        }
        write(builder, "op__element(");
        convert_expression(syntax.children[0], builder);
        write(builder, ", ");
        convert_expression(syntax.children[2], builder);
        write(builder, ")");
    }
    else
    {
        error(builder, "Could not convert expression of type " + int_to_string(syntax.kind));
    }
}

public literal_length(value: string) -> int
{
    var length: int = string_byte_length(value)-2; // start and end quotes
    // Since each escape sequence is two chars, we subtract one for each escape sequence.
    // The this that makes this tricky is escaped backslash `"\\"`
    var escaped: bool = false;
    // Due to limitations with strings and loops, do the equivalent
    // of a for loop
    var i: int = 0;
    while i < string_byte_length(value)
    {
        if value[i] == '\\' and not escaped
        {
            escaped = true;
            length -= 1;
        }
        else
            { escaped = false; }

        i += 1;
    }
    return length;
}

public code_point_literal_value(value: string) -> code_point
{
    let length: int = string_byte_length(value);
    if length == 3
    {
        // Something simple like 'a'
        return value[1];
    }
    else if length == 4
    {
        // Something escaped like '\n'
        if value == "'\\\"'"
            { return '\"'; }
        else if value == "'\\\\'"
            { return '\\'; }
        // TODO '\'' isn't valid Adamant
        else if value == "'\\''"
            { return '\''; }
        // TODO handle the case of '\{'
        else if value == "'\\n'"
            { return '\n'; }
        else if value == "'\\r'"
            { return '\r'; }
        else if value == "'\\0'"
            { return '\0'; }
        else if value == "'\\b'"
            { return '\b'; }
        else if value == "'\\f'"
            { return '\f'; }
        else if value == "'\\t'"
            { return '\t'; }
        else if value == "'\\b'"
            { return '\b'; }
        else
        {
            assert(false, "Unsupported code_point escape sequence "+value);
        }
    }
    else if length == 6
    {
        // Handle things like '\xAF' which we use but may not be part of Adamant
        if substring(value, 0, 3) =/= "'\\x"
        {
            assert(false, "Unsupported code_point escape sequence "+value);
        }
        else
        {
            return int_to_code_point(hex_string_to_int(substring(value, 3, 2)));
        }
    }
    else
    {
        assert(false, "Unsupported code_point escape sequence "+value);
    }

    UNREACHABLE();
}

public convert_reference_type_constructor_arguments(
    syntax: Semantic_Node,
    builder: mut Source_File_Builder,
    type_name: string)
    -> void
{
    assert(syntax.kind == ArgumentList);
    write(builder, "(allocate(sizeof(");
    write(builder, type_name);
    write(builder, "))");
    for let arg: Semantic_Node in syntax.children
    {
        if arg.kind =/= LeftParen
            and arg.kind =/= RightParen
            and arg.kind =/= Comma
        {
            write(builder, ", ");
            convert_expression(arg, builder);
        }
    }
    write(builder, ")");
}

public convert_member_access(lhs: Semantic_Node, builder: mut Source_File_Builder) -> void
{
    let type: Type? = lhs.of_type;
    if type =/= none and type.is_value_type // TODO eventually, we shouldn't need to check if the type is null
        and not (type.is_primitive // optional reference types are still pointers
                and unqualified_name(type.name) == "optional"
                and not as_type(type.type_parameters[0]).is_value_type) // as_type() needed for now because of void_ptr
        { write(builder, "."); }
    else
        { write(builder, "->"); }
}

public as_type(type: Type) -> Type
{
    return type;
}

public emit_statement(emitter: mut Emitter, statement: Semantic_Node) -> void
{
    statement_separator_line(emitter.definitions);

    if statement.kind == ReturnStatement
    {
        if statement.children.count == 2
            { write_line(emitter.definitions, "return;"); }
        else
        {
            begin_line(emitter.definitions, "return ");
            convert_expression(statement.children[1], emitter.definitions);
            end_line(emitter.definitions, ";");
        }
    }
    else if statement.kind == LoopStatement
    {
        write_line(emitter.definitions, "for (;;)");
        emit_statement(emitter, statement.children[1]); // Block Statement
    }
    else if statement.kind == Block
    {
        begin_block(emitter.definitions);
        for let block_statement: Semantic_Node in node_statements(statement)
        {
            emit_statement(emitter, block_statement);
        }
        end_block(emitter.definitions);
    }
    else if statement.kind == WhileStatement
    {
        begin_line(emitter.definitions, "while (cond(");
        convert_expression(statement.children[1], emitter.definitions);
        end_line(emitter.definitions, "))");
        emit_statement(emitter, statement.children[2]); // Block Statement
    }
    else if statement.kind == ForStatement
    {
        // For the code:
        //      for let x: T in expr
        //      {
        //          //body
        //      }
        // Emit:
        //
        //      for(T__0iter mut iter = T__0iterate(expr); T__0next(iter);)
        //      {
        //          T x = T__0current(iter);
        //          body
        //      }
        // Except use `void_ptr`` for all reference types `T` for the iter type and functions

        let variable_declaration: Semantic_Node = first_child(statement, VariableDeclaration);
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        let variable_name: string = get_semantic_node_text(first_child(variable_declaration, Identifier));
        let variable_type_node: Semantic_Node = variable_declaration.children[2];
        let iterator_expression: Semantic_Node = statement.children[3];
        let iterator_over_type: Type = variable_type_node.referenced_type;
        assert(iterator_over_type =/= none, get_semantic_node_text(variable_type_node));
        var iterator_type: string;
        if iterator_over_type.is_primitive
            { iterator_type = convert_primitive_type_name(iterator_over_type); }
        else
            { iterator_type = "void_ptr"; }
        let collection_type: Type = iterator_expression.of_type;
        var iteratable_type: string;
        if collection_type =/= none
            { iteratable_type = mangle_name(collection_type); }
        else
            { iteratable_type = iterator_type; }

        // for statement
        begin_line(emitter.definitions, "for (");
        write(emitter.definitions, iterator_type);
        write(emitter.definitions, "__0iter mut iter = ");
        write(emitter.definitions, iteratable_type);
        write(emitter.definitions, "__0iterate(");
        convert_expression(iterator_expression, emitter.definitions);
        write(emitter.definitions, "); ");
        write(emitter.definitions, iterator_type);
        end_line(emitter.definitions, "__0next(&iter);)");
        // loop block
        begin_block(emitter.definitions);
        // loop variable
        begin_line(emitter.definitions, "");
        write(emitter.definitions, convert_type(mutable_binding, variable_type_node));
        write(emitter.definitions, " ");
        write(emitter.definitions, mangle_field_name(variable_name));
        write(emitter.definitions, " = ");
        write(emitter.definitions, iterator_type);
        end_line(emitter.definitions, "__0current(&iter);");
        // loop body
        let for_loop_body: Semantic_Node = statement.children[4];
        for let block_statement: Semantic_Node in node_statements(for_loop_body)
        {
            emit_statement(emitter, block_statement);
        }
        end_block(emitter.definitions);
    }
    else if statement.kind == DoWhileStatement
    {
        write_line(emitter.definitions, "do");
        emit_statement(emitter, statement.children[1]); // Block Statement
        begin_line(emitter.definitions, "while (cond(");
        convert_expression(statement.children[3], emitter.definitions);
        end_line(emitter.definitions, "));");
    }
    else if statement.kind == IfStatement
    {
        var if_statement: Semantic_Node? = statement;
        begin_line(emitter.definitions, "");
        loop
        {
            write(emitter.definitions, "if (cond(");
            convert_expression(if_statement.children[1], emitter.definitions);
            end_line(emitter.definitions, "))");
            emit_statement(emitter, if_statement.children[2]); // Block Statement
            let else_clause: Semantic_Node? = first_child(if_statement, ElseClause);
            if else_clause =/= none
            {
                if_statement = first_child(else_clause, IfStatement);
                if if_statement =/= none
                {
                    begin_line(emitter.definitions, "else ");
                }
                else
                {
                    write_line(emitter.definitions, "else");
                    emit_statement(emitter, else_clause.children[1]); // Block Statement
                    break;
                }
            }
            else
                { break; }
        }
    }
    else if statement.kind == MatchStatement
    {
        // Don't use begin/end block because we don't want to increase the indent
        begin_line(emitter.definitions, "/* match */ { void const ref const match_value = ");
        convert_expression(statement.children[1], emitter.definitions);
        end_line(emitter.definitions, ";");
        write_line(emitter.definitions, "   switch(*(Type_ID const ref)match_value)");
        begin_block(emitter.definitions);
        for let match_arm: Semantic_Node in statement.children
        {
            if match_arm.kind == MatchArm
            {
                let match_pattern: Semantic_Node = first_child(match_arm, MatchPattern);
                let match_variable_type_node: Semantic_Node = match_pattern.children[2];
                let variable_name: string = get_semantic_node_text(first_child(match_pattern, Identifier));
                let match_block: Semantic_Node = first_child(match_arm, Block);
                assert(match_variable_type_node.referenced_type =/= none, get_semantic_node_text(match_variable_type_node));
                let type_name: string = sb_to_string(convert_type_name(match_variable_type_node.referenced_type));
                write_line(emitter.definitions, "case " + type_name + "__0Type_ID:");
                begin_block(emitter.definitions);
                begin_line(emitter.definitions, convert_type(false, match_variable_type_node));
                write(emitter.definitions, " ");
                write(emitter.definitions, mangle_field_name(variable_name));
                end_line(emitter.definitions, " = match_value;");
                for let block_statement: Semantic_Node in node_statements(match_block)
                {
                    emit_statement(emitter, block_statement);
                }

                end_block(emitter.definitions);
                write_line(emitter.definitions, "break;");
            }
        }
        write_line(emitter.definitions, "default:");
        write_line(emitter.definitions, "   NON_EXHAUSTIVE_MATCH(*(Type_ID const ref)match_value);");
        // TODO write out match arms
        end_block_with(emitter.definitions, "}}");
    }
    else if statement.kind == BreakStatement
    {
        write_line(emitter.definitions, "break;");
    }
    else if statement.kind == ContinueStatement
    {
        write_line(emitter.definitions, "continue;");
    }
    else if statement.kind == LocalDeclarationStatement
    {
        let variable_declaration: Semantic_Node = first_child(statement, VariableDeclaration);
        let variable_name: string = get_semantic_node_text(first_child(variable_declaration, Identifier));
        let variable_type: Semantic_Node = variable_declaration.children[2];
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        begin_line(emitter.definitions, convert_type(mutable_binding, variable_type));
        write(emitter.definitions, " " + mangle_field_name(variable_name));
        if variable_declaration.children.count > 3
        {
            write(emitter.definitions, " = ");
            convert_expression(variable_declaration.children[3], emitter.definitions);
        }
        end_line(emitter.definitions, ";");
    }
    else if statement.kind == ExpressionStatement
    {
        begin_line(emitter.definitions, "");
        convert_expression(statement.children[0], emitter.definitions);
        end_line(emitter.definitions, ";");
    }
    else
    {
        NOT_IMPLEMENTED("statement.kind=" + int_to_string(statement.kind));
    }
}

public emit_method_body(emitter: mut Emitter, block: Semantic_Node, is_associated_function: bool) -> void
{
    begin_block(emitter.definitions);
    if not is_associated_function
    {
        write_line(emitter.definitions, "auto self = this;");
    }
    for let statement: Semantic_Node in node_statements(block)
    {
        emit_statement(emitter, statement);
    }
    end_block(emitter.definitions);
}

public emit_constructor_body(emitter: mut Emitter, block: Semantic_Node, type_name: string, is_value_type: bool) -> void
{
    // TODO this doesn't support explicit return from constructors
    begin_block(emitter.definitions);
    if is_value_type
    {
        write_line(emitter.definitions, type_name + " mut self;");
    }
    else
    {
        write_line(emitter.definitions, "self->type_id = " + type_name + "__0Type_ID;");
    }
    for let statement: Semantic_Node in node_statements(block)
    {
        emit_statement(emitter, statement);
    }
    write_line(emitter.definitions, "return self;");
    end_block(emitter.definitions);
}

public emit_member_declaration(emitter: mut Emitter, member: Semantic_Node, class_name: string, is_value_type: bool) -> void
{
    if member.kind == ConstructorDeclaration
    {
        let parameters_node: Semantic_Node = first_child(member, ParameterList);
        var new_function_name: string = "new_" + class_name;
        var constructor_full_name: string = class_name + "__0new__";
        let constructor_name_node: Semantic_Node? = first_child(member, Identifier);
        if constructor_name_node =/= none
        {
            let constructor_name: string = get_semantic_node_text(constructor_name_node);
            new_function_name = new_function_name + "__" + constructor_name;
            constructor_full_name = constructor_full_name + constructor_name + "__";
        }
        constructor_full_name = constructor_full_name + int_to_string(parameters_node.children.count);
        var return_type: string = class_name + " mut";
        if not is_value_type
            { return_type = return_type + " ref mut"; }
        var constructor_parameters: string;
        if not is_value_type
            { constructor_parameters = convert_method_parameter_list(emitter, parameters_node, class_name + " mut ref const"); }
        else
            { constructor_parameters = convert_parameter_list(emitter, parameters_node); }

        // Constructor Signature
        var constructor_signature: string = return_type + " " + constructor_full_name + constructor_parameters;

        // Constructor Declaration
        write_line(emitter.function_declarations, constructor_signature + ";");

        // Constructor definition
        element_separator_line(emitter.definitions);
        write_line(emitter.definitions, constructor_signature);
        emit_constructor_body(emitter, first_child(member, Block), class_name, is_value_type);
    }
    else if member.kind == FieldDeclaration
    {
        let variable_declaration: Semantic_Node = first_child(member, VariableDeclaration);
        let field_name: string = get_semantic_node_text(first_child(variable_declaration, Identifier));
        let field_type: Semantic_Node = variable_declaration.children[2];
        // because we need to assign them in constructors don't mark fields const
        // TODO it might be better to just not emit a mutability specifier on these types to avoid confusion
        let c_type: string = convert_type(true, field_type);
        write_line(emitter.class_declarations, c_type + " " + mangle_field_name(field_name) + ";");
    }
    else if member.kind == MethodDeclaration
    {
        let parameters_node: Semantic_Node = first_child(member, ParameterList);
        let self_parameter: Semantic_Node? = first_child(parameters_node, SelfParameter);
        var parameter_count: int = parameters_node.children.count;
        // For now we ignore the self parameter because the caller can't tell if it is a method or function call
        if self_parameter =/= none
            { parameter_count -= 1; }
        let method_name: string = mangle_function_name(get_semantic_node_text(first_child(member, Identifier)), parameter_count);
        let parameters: string = convert_parameter_list(emitter, parameters_node);
        let is_associated_function: bool = self_parameter == none;
        let mutable_self: bool = not is_associated_function and node_has_child(self_parameter, MutableKeyword);
        let return_type_node: Semantic_Node = member.children[3];
        let c_type: string = convert_type(true, return_type_node);
        var static_modifier: string = "";
        if is_associated_function
            { static_modifier = "static "; }
        var const_modifier: string = "";
        if not mutable_self and not is_associated_function
            { const_modifier = " const"; }
        write_line(emitter.class_declarations, static_modifier + c_type + " " + method_name + parameters + const_modifier + ";");
        element_separator_line(emitter.definitions);
        write_line(emitter.definitions, c_type + " " + class_name + "::" + method_name + parameters + const_modifier);
        let block: Semantic_Node = first_child(member, Block);
        emit_method_body(emitter, block, is_associated_function);
    }
    else
    {
        error(emitter.definitions, "Could not emit member of type " + int_to_string(member.kind));
    }
}

public emit_default_constructor(emitter: mut Emitter, type_name: string, is_value_type: bool) -> void
{
    let default_constructor_name: string = type_name + "__0new__0";

    // TODO if the type is inherently immutable then we need to emit `const` instead
    var return_type: string = type_name + " mut";
    if not is_value_type
        { return_type = return_type + " ref mut"; }

    // Constructor Signature
    var constructor_signature: string = return_type + " " + default_constructor_name + "(";
    if not is_value_type
        { constructor_signature = constructor_signature + type_name + " mut ref const self"; }
    constructor_signature = constructor_signature + ")";

    // Constructor Declaration
    write_line(emitter.function_declarations, constructor_signature + ";");

    // Constructor definition
    element_separator_line(emitter.definitions);
    begin_line(emitter.definitions, constructor_signature);
    // TODO I probably need to do the default initialization
    if is_value_type
        { end_line(emitter.definitions, " { return (" + return_type + "){}; }"); }
    else
    {
        end_line(emitter.definitions, " { self->type_id = " + type_name + "__0Type_ID; return self; }");
    }
}

public emit_declaration(emitter: mut Emitter, declaration: Semantic_Node) -> void
{
    if declaration.kind == GlobalDeclaration
    {
        let variable_declaration: Semantic_Node = first_child(declaration, VariableDeclaration);
        let variable_name: string = get_semantic_node_text(first_child(variable_declaration, Identifier));
        let variable_type: Semantic_Node = variable_declaration.children[2];
        let mutable_binding: bool = node_has_child(variable_declaration, VarKeyword);
        let c_type: string = convert_type(mutable_binding, variable_type);
        begin_line(emitter.global_definitions, c_type);
        write(emitter.global_definitions, " " + mangle_field_name(variable_name) + " = ");
        let expression: Semantic_Node = variable_declaration.children[3];
        convert_expression(expression, emitter.global_definitions);
        end_line(emitter.global_definitions, ";");
    }
    else if declaration.kind == ClassDeclaration
    {
        let declared_type: Type = declaration.declares_type;
        assert(declared_type =/= none, get_semantic_node_text(first_child(declaration, Identifier)));
        let class_name: string = mangle_name(declared_type);
        write_line(emitter.type_id_declaration, class_name + "__0Type_ID,");
        write_line(emitter.type_declarations, "typedef struct " + class_name + " " + class_name + ";");
        element_separator_line(emitter.class_declarations);
        write_line(emitter.class_declarations, "struct " + class_name);
        begin_block(emitter.class_declarations);
        write_line(emitter.class_declarations, "Type_ID type_id;");
        var has_constructors: bool = false;
        for let member: Semantic_Node in node_members(declaration)
        {
            has_constructors = has_constructors or member.kind == ConstructorDeclaration;
            emit_member_declaration(emitter, member, class_name, false);
        }
        if not has_constructors
        {
            emit_default_constructor(emitter, class_name, false);
        }
        end_block_with_semicolon(emitter.class_declarations);
    }
    else if declaration.kind == StructDeclaration
    {
        let declared_type: Type = declaration.declares_type;
        assert(declared_type =/= none, get_semantic_node_text(first_child(declaration, Identifier)));
        let struct_name: string = mangle_name(declared_type);
        write_line(emitter.type_declarations, "typedef struct " + struct_name + " " + struct_name + ";");
        element_separator_line(emitter.class_declarations);
        write_line(emitter.class_declarations, "struct " + struct_name);
        begin_block(emitter.class_declarations);
        var has_constructors: bool = false;
        for let member: Semantic_Node in node_members(declaration)
        {
            has_constructors = has_constructors or member.kind == ConstructorDeclaration;
            emit_member_declaration(emitter, member, struct_name, true);
        }
        if not has_constructors
        {
            emit_default_constructor(emitter, struct_name, true);
        }
        end_block_with_semicolon(emitter.class_declarations);
    }
    else if declaration.kind == EnumDeclaration
    {
        let enum_name: string = get_semantic_node_text(first_child(declaration, Identifier));
        write_line(emitter.type_declarations, "enum " + enum_name + "_");
        begin_block(emitter.type_declarations);
        for let member: Semantic_Node in declaration.children
        {
            if member.kind == EnumMemberDeclaration
            {
                let member_name: string = get_semantic_node_text(member.children[0]);
                begin_line(emitter.type_declarations, member_name + "_");
                let member_value: Semantic_Node? = first_child(member, Integer);
                if member_value =/= none
                {
                    write(emitter.type_declarations, " = ");
                    write(emitter.type_declarations, get_semantic_node_text(member_value));
                }
                end_line(emitter.type_declarations, ",");
            }
        }
        end_block_with_semicolon(emitter.type_declarations);
        write_line(emitter.type_declarations, "typedef enum " + enum_name + "_ " + enum_name +"_;");
    }
    else if declaration.kind == FunctionDeclaration
    {
        let parameters_node: Semantic_Node = first_child(declaration, ParameterList);
        var name: string = get_semantic_node_text(first_child(declaration, Identifier));
        let is_main: bool = name == "main";
        name = mangle_function_name(name, parameters_node.children.count);
        if is_main { emitter.main_function_name = name; }
        let parameters: string = convert_parameter_list(emitter, parameters_node, is_main);
        let return_type_node: Semantic_Node = declaration.children[3];
        // TODO const/mut doesn't really apply to the outer level of return types. This matches C.
        let c_type: string = convert_type(true, return_type_node);
        // Write out the function declaration for C so we can call functions defined after others
        write_line(emitter.function_declarations, c_type + " " + name + parameters + ";");
        element_separator_line(emitter.definitions);
        write_line(emitter.definitions, c_type + " " + name + parameters);
        if is_main
        {
            if emitter.main_function_return_type =/= ""
                { error(emitter.definitions, "Multiple declarations of main"); }
            emitter.main_function_return_type = c_type;
        }
        emit_statement(emitter, first_child(declaration, Block));
    }
    else if declaration.kind == EndOfFile
    {
        // Ignore the end of file
    }
    else
    {
        error(emitter.definitions, "Could not emit declaration of type " + int_to_string(declaration.kind));
    }
}

public emit_compilation_unit(emitter: mut Emitter, unit: Compilation_Unit) -> void
{
    for let declaration: Semantic_Node in unit.declarations
    {
        emit_declaration(emitter, declaration);
    }
}

public emit_preamble(emitter: mut Emitter) -> void
{
    // Setup the beginning of each section
    write_line(emitter.includes, "#include \"RuntimeLibrary.h\"");
    blank_line(emitter.type_id_declaration);
    write_line(emitter.type_id_declaration, "// Type ID Declarations");
    write_line(emitter.type_id_declaration, "enum Type_ID");
    begin_block(emitter.type_id_declaration);
    write_line(emitter.type_id_declaration, "never__0Type__ID = 0,");
    blank_line(emitter.type_declarations);
    write_line(emitter.type_declarations, "// Type Declarations");
    blank_line(emitter.function_declarations);
    write_line(emitter.function_declarations, "// Function Declarations");
    blank_line(emitter.class_declarations);
    write_line(emitter.class_declarations, "// Class Declarations");
    blank_line(emitter.global_definitions);
    write_line(emitter.global_definitions, "// Global Definitions");
    blank_line(emitter.definitions);
    write_line(emitter.definitions, "// Definitions");
}

public emit_entry_point_adapter(emitter: mut Emitter) -> void
{
    element_separator_line(emitter.definitions);
    write_line(emitter.definitions, "// Entry Point Adapter");
    write_line(emitter.definitions, "int32_t main(int argc, char const ptr const ptr argv)");
    begin_block(emitter.definitions);

    for let resource: Source_Text in emitter.resources
    {
        let resource_name: string = "\""+resource.name+"\"";
        var resource_text: string = resource.text;
        resource_text = string_replace(resource_text, "\\", "\\\\");
        resource_text = string_replace(resource_text, "\n", "\\n");
        resource_text = string_replace(resource_text, "\r", "\\r");
        resource_text = string_replace(resource_text, "\"", "\\\"");
        resource_text = "\""+resource_text+"\"";
        begin_line(emitter.definitions, "add_resource((string){"+int_to_string(literal_length(resource_name))+",(uint8_t const*)");
        write(emitter.definitions, resource_name);
        write(emitter.definitions, "}, (string){"+int_to_string(literal_length(resource_text))+",(uint8_t const*)");
        write(emitter.definitions, resource_text);
        end_line(emitter.definitions, "});");
    }
    if emitter.resources.count > 0
    {
        end_line(emitter.definitions, ""); // Use end_line to avoid having an indent on a blank line
    }

    // TODO should be `new mut`
    let args: mut system.text.String_Builder = new system.text.String_Builder();
    if emitter.main_function_accepts_console
        { sb_append(args, "allocate(sizeof(system__console__Console__0))"); }
    if emitter.main_function_accepts_args
    {
        if emitter.main_function_accepts_console
            { sb_append(args, ", "); }
        sb_append(args, "convert_arguments(argc, argv)");
    }

    if emitter.main_function_return_type == "void mut"
    {
        write_line(emitter.definitions, emitter.main_function_name + "(" + sb_to_string(args) + ");");
        write_line(emitter.definitions, "return 0;");
    }
    else
    {
        write_line(emitter.definitions, "return " + emitter.main_function_name + "(" + sb_to_string(args) + ").value;");
    }

    end_block(emitter.definitions);
}

public emit_postamble(emitter: mut Emitter) -> void
{
    // Close the Type_ID enum
    end_block_with_semicolon(emitter.type_id_declaration);
    write_line(emitter.type_id_declaration, "typedef enum Type_ID Type_ID;");
}

